(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global['@yellicode/angular'] = {})));
}(this, (function (exports) { 'use strict';

    /**
     * Extract from the Angular Core API, adapted so that it can be used
     * for code generation.
     */
    (function (ChangeDetectionStrategy) {
        /**
         * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated
         * until reactivated by setting the strategy to `Default` (`CheckAlways`).
         * Change detection can still be explictly invoked.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        /**
         * Use the default `CheckAlways` strategy, in which change detection is automatic until
         * explicitly deactivated.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
    (function (ViewEncapsulation) {
        /**
         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
         * Element and pre-processing the style rules provided via {@link Component#styles styles} or
         * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all
         * selectors.
         *
         * This is the default option.
         */
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        /**
         * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.
         * Use the native encapsulation mechanism of the renderer.
         *
         * For the DOM this means using the deprecated [Shadow DOM
         * v0](https://w3c.github.io/webcomponents/spec/shadow/) and
         * creating a ShadowRoot for Component's Host Element.
         */
        ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
        /**
         * Don't provide any template or style encapsulation.
         */
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        /**
         * Use Shadow DOM to encapsulate styles.
         *
         * For the DOM this means using modern [Shadow
         * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
         * creating a ShadowRoot for Component's Host Element.
         *
         * ### Example
         * {@example core/ts/metadata/encapsulation.ts region='longform'}
         */
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));

    /**
     * Provides utility functions for generating Angular 2+ application code.
     */
    class AngularWriter {
        /**
        * Writes a full Angular '@Component' class decorator using the provided configuration.
        */
        static writeComponentDecorator(writer, config) {
            writer.writeDecoratorCodeBlock('Component', () => {
                AngularWriter.writeComponentConfig(writer, config);
            });
        }
        /**
         * Writes Angular component configuration that can be used inside a component class decorator.
         * Use writeComponentDecorator() to write a full '@Component' class decorator.
         */
        static writeComponentConfig(writer, config) {
            const keys = Object.keys(config);
            keys.forEach((key, index) => {
                writer.writeIndent();
                const value = config[key];
                writer.write(`${key}: ${AngularWriter.stringifyComponentProperty(key, value)}`);
                if (index < keys.length - 1)
                    writer.write(',');
                writer.writeEndOfLine();
            });
        }
        /**
        * Writes a full Angular '@NgModule' class decorator using the provided configuration.
        */
        static writeModuleDecorator(writer, config) {
            writer.writeDecoratorCodeBlock('NgModule', () => {
                AngularWriter.writeComponentConfig(writer, config);
            });
        }
        /**
         * Writes Angular module configuration that can be used inside a module class decorator.
         * Use writeModuleDecorator() to write a full '@NgModule' class decorator.
         */
        static writeModuleConfig(writer, config) {
            const keys = Object.keys(config);
            keys.forEach((key, index) => {
                writer.writeIndent();
                const value = config[key];
                writer.write(`${key}: ${AngularWriter.stringifyModuleProperty(key, value)}`);
                if (index < keys.length - 1)
                    writer.write(',');
                writer.writeEndOfLine();
            });
        }
        /**
        * Writes a route configuration for the specified component, with the specified route path.
        */
        static writeRoute(writer, route) {
            writer.writeLine('{');
            writer.increaseIndent();
            writer.writeLine(`path: '${route.path}',`);
            writer.writeLine(`component: ${route.componentName}`);
            writer.decreaseIndent();
            writer.writeLine('},');
        }
        static stringifyModuleProperty(key, value) {
            switch (key) {
                case 'bootstrap':
                case 'declarations':
                case 'entryComponents':
                case 'imports':
                case 'exports':
                case 'providers':
                case 'schemas':
                    return AngularWriter.stringifyObjectArray(value);
                default: break;
            }
            if (typeof (value) == typeof (true)) {
                return value ? 'true' : 'false';
            }
            return `'${value}'`;
        }
        static stringifyComponentProperty(key, value) {
            switch (key) {
                case 'changeDetection':
                    return `ChangeDetectionStrategy.${exports.ChangeDetectionStrategy[value]}`;
                case 'encapsulation':
                    return `ViewEncapsulation.${exports.ViewEncapsulation[value]}`;
                case 'entryComponents':
                case 'providers':
                case 'viewProviders':
                    return AngularWriter.stringifyObjectArray(value);
                case 'host':
                    return AngularWriter.stringifyKeyValuePair(value);
                default:
                    break;
            }
            if (typeof (value) == typeof (true)) {
                return value ? 'true' : 'false';
            }
            if (value instanceof Array) {
                return AngularWriter.stringifyStringArray(value);
            }
            // The value is a string
            else
                return `'${value}'`;
        }
        static stringifyObjectArray(arr) {
            if (!arr.length)
                return '[]';
            return `[${arr.join(', ')}]`;
        }
        static stringifyStringArray(arr) {
            if (!arr.length)
                return '[]';
            return `[${arr.map(item => `'${item}'`).join(', ')}]`;
        }
        static stringifyKeyValuePair(value) {
            // {'key1': 'value1', 'key2': 'value2'}
            const keys = Object.keys(value);
            return `{ ${keys.map(k => `'${k}': '${value[k]}'`).join(', ')} }`;
        }
    }

    exports.AngularWriter = AngularWriter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
