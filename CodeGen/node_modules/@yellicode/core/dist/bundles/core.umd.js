(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('uuid'), require('os')) :
	typeof define === 'function' && define.amd ? define(['exports', 'uuid', 'os'], factory) :
	(factory((global['@yellicode/core'] = {}),global.uuid,global.os));
}(this, (function (exports,uuid,os) { 'use strict';

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Contains simple utility methods that deal with strings.
 */
class StringUtility {
    static wordWrap(str, width) {
        const result = [];
        if (width < 1 || str == null || str.length <= width)
            return result;
        const len = str.length;
        let rangeMax = len - width; // we don't need to split after this position
        let rangeStart = 0;
        let subString;
        while (rangeStart < rangeMax) {
            let subLength;
            let rangeEnd = rangeStart + width;
            // First test for newlines in this range. If so, don't split on word break but on the newline.
            var ixNewLine = str.indexOf("\n", rangeStart);
            if (ixNewLine > -1 && ixNewLine > rangeStart && ixNewLine < rangeEnd) {
                subLength = ixNewLine - rangeStart;
                subString = str.substr(rangeStart, subLength);
                rangeStart = rangeStart + subLength + 1;
                result.push(subString);
                continue;
            }
            // No newlines. Find the last wordbreak in the range.
            let ix = str.lastIndexOf(" ", rangeEnd); // find the last word break
            let rangeStartNext = 0;
            if (ix > -1 && ix != rangeStart - 1) {
                subLength = ix - rangeStart;
                if (subLength > 0) {
                    rangeStartNext = rangeStart + subLength + 1; // +1 to skip the whitespace
                }
                //else { // not needed anymore because of the maxPos check
                //    sub = str.substr(pos);
                //    newPos = len + 1;
                //}
            }
            else {
                // The range has no whitespace. 
                subLength = width;
                rangeStartNext = rangeStart + width;
            }
            subString = str.substr(rangeStart, subLength);
            rangeStart = rangeStartNext;
            result.push(subString.trim());
        }
        // Add the remainder
        if (rangeStart < len) {
            subString = str.substr(rangeStart);
            result.push(subString);
        }
        //  console.debug(result);
        return result;
    }
    /**
     * Makes the first character of the string uppercase.
     */
    static capitalize(str) {
        if (str == null || str.length === 0)
            return str;
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    /**
     * Makes the first character of the string lowercase.
     */
    static unCapitalize(str) {
        if (str == null || str.length === 0)
            return str;
        return str.charAt(0).toLowerCase() + str.slice(1);
    }
    /**
     * Returns a boolean value indicating if the string is upperCase.
     */
    static isUpperCase(str) {
        if (!str)
            return false;
        return (str === str.toUpperCase() && str !== str.toLowerCase());
    }
    /**
     * Returns a boolean value indicating if the string is lowerCase.
     */
    static isLowerCase(str) {
        if (!str)
            return false;
        return (str === str.toLowerCase() && str !== str.toUpperCase());
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Provides helper functions for converting the casing of names.
 */
class NameUtility {
    /**
    * Makes the first character of the string uppercase.
    */
    static capitalize(input) {
        if (!input)
            return input;
        return StringUtility.capitalize(input);
    }
    /**
     * Makes the first character of the string lowercase.
     */
    static unCapitalize(input) {
        if (!input)
            return input;
        return StringUtility.unCapitalize(input);
    }
    /**
     * Converts a UpperCamelCase or lowerCamelCase string to a kebab-case (aka dash-case) string.
     * @param input A camelCase or UpperCamelCase string.
     * @returns a kebab-case (aka dash-case) string, meaning all lowercase with a dash separating words.
     */
    static camelToKebabCase(input) {
        if (!input)
            return input;
        const result = [];
        for (var i = 0, len = input.length; i < len; i++) {
            var c = input.charAt(i);
            const upperCase = c.toUpperCase();
            const lowerCase = c.toLowerCase();
            const isUpperCase = (c === upperCase && c !== lowerCase);
            if (isUpperCase && i > 0 && i < len - 1) {
                let insertHyphen = true;
                if (i < len - 1 && StringUtility.isUpperCase(input.charAt(i + 1))) {
                    // The next character is also uppercase
                    insertHyphen = false;
                }
                if (insertHyphen) {
                    result.push('-');
                }
            }
            result.push(lowerCase);
        }
        return result.join('');
    }
    /**
     * Converts a UpperCamelCase string to a lowerCamelCase string.
     * @param input A UpperCamelCase string.
     * @returns a lowerCamelCase string.
     */
    static upperToLowerCamelCase(input) {
        if (!input)
            return input;
        let done = false;
        let isPreviousMatch = false;
        const result = new Array(input.length);
        for (var i = 0, len = input.length; i < len; i++) {
            var c = input.charAt(i);
            if (!done) {
                const upperCase = c.toUpperCase();
                const lowerCase = c.toLowerCase();
                const isMatch = (c === upperCase && c !== lowerCase);
                if (isMatch) {
                    // The character is upperCase, make it lowerCase      
                    c = lowerCase;
                }
                else {
                    // The character is lowerCase. We are done, but..                
                    if (isPreviousMatch && i > 1) {
                        // ... if we converted the previous char to lowercase, make it uppercase again.    
                        // For example: ISBNNumber would become isbnNumber instead of isbnnumber
                        result[i - 1] = result[i - 1].toUpperCase();
                    }
                    done = true;
                }
                isPreviousMatch = isMatch;
            }
            result[i] = c;
        }
        return result.join('');
    }
    /**
   * Converts a lowerCamelCase string to a UpperCamelCase string.
   * @param input A lowerCamelCase string.
   * @returns a UpperCamelCase string.
   */
    static lowerToUpperCamelCase(input) {
        return StringUtility.capitalize(input);
    }
    /**
     * Converts a kebab-case, lowerCamelCase or UpperCamelCase string to an ALL_UPPER_CASE string.
     * @param input A kebab-case (aka dash-case), lowerCamelCase or UpperCamelCase string.
     * @returns an ALL_UPPER_CASE string.
     */
    static toAllUpperCase(input) {
        if (!input)
            return input;
        const result = [];
        for (var i = 0, len = input.length; i < len; i++) {
            var c = input.charAt(i);
            const upperCase = c.toUpperCase();
            const lowerCase = c.toLowerCase();
            const isUpperCase = (c === upperCase && c !== lowerCase);
            const isDash = c === '-';
            if ((isDash || isUpperCase) && i > 0 && i < len - 1) {
                let insertHyphen = true;
                if (i < len - 1 && StringUtility.isUpperCase(input.charAt(i + 1))) {
                    // The next character is also uppercase
                    insertHyphen = false;
                }
                if (insertHyphen) {
                    result.push('_');
                }
            }
            if (!isDash)
                result.push(upperCase);
        }
        return result.join('');
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Contains helper methods that can be used by custom code writers and templates.
 */
class CodeWriterUtility {
    /**
     * Wraps the provided string input to a specified maximum width.
     * @argument str The string to be wrapped.
     * @argument width The maximum width of the wrapped text in characters.
     * @returns A string array containing all lines.
     */
    static wordWrap(str, width) {
        const result = [];
        if (width < 1 || str == null || str.length <= width)
            return result;
        const len = str.length;
        let rangeMax = len - width; // we don't need to split after this position
        let rangeStart = 0;
        let subString;
        while (rangeStart < rangeMax) {
            let subLength;
            let rangeEnd = rangeStart + width;
            // First test for newlines in this range. If so, don't split on word break but on the newline.
            var ixNewLine = str.indexOf("\n", rangeStart);
            if (ixNewLine > -1 && ixNewLine > rangeStart && ixNewLine < rangeEnd) {
                subLength = ixNewLine - rangeStart;
                subString = str.substr(rangeStart, subLength);
                rangeStart = rangeStart + subLength + 1;
                result.push(subString);
                continue;
            }
            // No newlines. Find the last wordbreak in the range.
            let ix = str.lastIndexOf(" ", rangeEnd); // find the last word break
            let rangeStartNext = 0;
            if (ix > -1 && ix != rangeStart - 1) {
                subLength = ix - rangeStart;
                if (subLength > 0) {
                    rangeStartNext = rangeStart + subLength + 1; // +1 to skip the whitespace
                }
                //else { // not needed anymore because of the maxPos check
                //    sub = str.substr(pos);
                //    newPos = len + 1;
                //}
            }
            else {
                // The range has no whitespace. 
                subLength = width;
                rangeStartNext = rangeStart + width;
            }
            subString = str.substr(rangeStart, subLength);
            rangeStart = rangeStartNext;
            result.push(subString.trim());
        }
        // Add the remainder
        if (rangeStart < len) {
            subString = str.substr(rangeStart);
            result.push(subString);
        }
        //  console.debug(result);
        return result;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Enumerates the possible Yellicode logging levels.
 */

(function (LogLevel) {
    LogLevel[LogLevel["None"] = 0] = "None";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Verbose"] = 4] = "Verbose";
})(exports.LogLevel || (exports.LogLevel = {}));
(function (LogLevel) {
    function parse(str) {
        if (!str)
            return null;
        switch (str.toLowerCase()) {
            case 'none': return LogLevel.None;
            case 'error': return LogLevel.Error;
            case 'warning': return LogLevel.Warning;
            case 'info': return LogLevel.Info;
            case 'verbose': return LogLevel.Verbose;
            default: return null;
        }
    }
    LogLevel.parse = parse;
})(exports.LogLevel || (exports.LogLevel = {}));
/**
 * A Logger implementation that logs to the default Console.
 */
class ConsoleLogger {
    constructor(console, level = exports.LogLevel.Info, includeTimestamp = false) {
        this.console = console;
        this.level = level;
        this.includeTimestamp = includeTimestamp;
    }
    verbose(message) {
        if (this.level < exports.LogLevel.Verbose)
            return;
        this.write("Verbose", message);
    }
    ;
    info(message) {
        if (this.level < exports.LogLevel.Info)
            return;
        this.write("Info", message);
    }
    ;
    warn(message) {
        if (this.level < exports.LogLevel.Warning)
            return;
        this.write("Warning", message);
    }
    ;
    error(message) {
        if (this.level < exports.LogLevel.Error)
            return;
        this.write("Error", message);
    }
    ;
    log(message, level) {
        switch (level) {
            case exports.LogLevel.Verbose:
                this.verbose(message);
                break;
            case exports.LogLevel.Info:
                this.info(message);
                break;
            case exports.LogLevel.Warning:
                this.warn(message);
                break;
            case exports.LogLevel.Error:
                this.error(message);
                break;
        }
    }
    write(level, message) {
        if (!this.includeTimestamp) {
            this.console.log(`${level}: ${message}`);
            return;
        }
        var d = new Date();
        var time = d.toLocaleTimeString();
        var ms = ConsoleLogger.padMilliseconds(d.getMilliseconds());
        this.console.log(`${time}:${ms} - ${level}: ${message}`);
    }
    static padMilliseconds(num, length = 3) {
        if (('' + num).length >= length)
            return num;
        var lead = '0' + new Array(length).join('0');
        return (lead + num).slice(-length);
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
const HEX_LIST = '0123456789abcdef';
const B64_LIST = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const STRING_LENGTH = 22; // Actually 24 characters for a base64 encoded Guid, but the padding "==" is removed.
class UniqueId {
    static create() {
        const guid = uuid.v4();
        let encoded = UniqueId.guidToBase64(guid, UniqueId.isLittleEndian);
        // Modify for use in a URL https://en.wikipedia.org/wiki/Base64#URL_applications
        encoded = encoded.replace("/", "_").replace("+", "-");
        return encoded.substring(0, STRING_LENGTH); // remove the padding "=="
    }
    static guidToBase64(g, le) {
        // Credits: https://stackoverflow.com/a/9998010/9370196
        var s = g.replace(/[^0-9a-f]/ig, '').toLowerCase();
        if (s.length != 32)
            return '';
        if (le)
            s = s.slice(6, 8) + s.slice(4, 6) + s.slice(2, 4) + s.slice(0, 2) +
                s.slice(10, 12) + s.slice(8, 10) +
                s.slice(14, 16) + s.slice(12, 14) +
                s.slice(16);
        s += '0';
        var a, p, q;
        var r = '';
        var i = 0;
        while (i < 33) {
            a = (HEX_LIST.indexOf(s.charAt(i++)) << 8) |
                (HEX_LIST.indexOf(s.charAt(i++)) << 4) |
                (HEX_LIST.indexOf(s.charAt(i++)));
            p = a >> 6;
            q = a & 63;
            r += B64_LIST.charAt(p) + B64_LIST.charAt(q);
        }
        r += '==';
        return r;
    }
}
UniqueId.isLittleEndian = os.endianness() === 'LE';

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Performs a sequence of model transforms, where the output of each transform is
 * the input of the next transform.
 */
class ModelTransformPipeline {
    /**
     * Creates a new ModelTransformPipeline, optionally initialized with a collection of transforms.
     * @param transform sAny transforms to initialize the pipeline with.
     */
    constructor(...transforms) {
        this.transforms = transforms || [];
    }
    /**
    * Adds a new collection of transforms to the pipeline.
    * @param transforms The transforms to be added.
    */
    addRange(...transforms) {
        transforms.forEach(t => {
            this.transforms.push(t);
        });
    }
    /**
     * Adds a new transform to the pipeline.
     * @param transform The transform to be added.
     */
    add(transform) {
        if (!transform)
            return;
        this.transforms.push(transform);
    }
    /**
    * Transforms the source model by applying the specified transforms in sequence.
    * @returns The output of the last transform that was applied.
    */
    transform(model) {
        if (this.transforms == null)
            return model;
        let transformedModel = model;
        this.transforms.forEach(t => {
            transformedModel = t.transform(transformedModel);
        });
        return transformedModel;
    }
}

/**
 * The abstract base class for all code writers. This writer implements the TextWriter interface by decorating
 * the TextWriter provided in the constructor.
 */
class CodeWriter {
    // NOTE: only documenting the get accessors because the TS compiler we use for doc generation concats the doc 
    // comments for the getter and setter.
    /**
    * Gets or sets the end of line string. The default value is platform dependent.
    */
    get endOfLineString() {
        return this.writer.endOfLineString;
    }
    set endOfLineString(value) {
        this.writer.endOfLineString = value;
    }
    /**
     * Gets or sets the indent string. The default value is a '\t' (tab character).
    */
    get indentString() {
        return this.writer.indentString;
    }
    set indentString(value) {
        this.writer.indentString = value;
    }
    /**
     * Constructor. Creates a new CodeWriter that uses the provided TextWriter internally.
     * @param writer A TextWriter object. In a code generation template, a TextWriter instance can be obtained by calling any of the generate...()
     * functions on the current CodeGenerator.
     */
    constructor(writer) {
        this.writer = writer;
    }
    /******************************************************************************
     *                          TextWriter delegation
    ******************************************************************************/
    /**
     * Writes a string value to the output.
     * @param value The string value to be written.
     */
    write(value) {
        this.writer.write(value);
        return this;
    }
    ;
    /**
    * Writes a single whitespace character to the output.
    */
    writeWhiteSpace() {
        this.writer.writeWhiteSpace();
        return this;
    }
    /**
    * Writes a new line to the output. The line is indented automatically. The line is ended with the endOfLineString.
    * @param value The line to write. When omitted, only the endOfLineString is written.
    */
    writeLine(value) {
        this.writer.writeLine(value);
        return this;
    }
    ;
    /**
   * Writes a collection of lines to the output. Each line is indented automatically and ended with the endOfLineString.
   * @param values The lines to write.
   * @param delimiter An optional delimiter to be written at the end of each line, except for the last one.
   */
    writeLines(values, delimiter) {
        this.writer.writeLines(values, delimiter);
        return this;
    }
    /**
     * Writes a new line to the output while temporarily increasing the indent. The line is ended with the endOfLineString.
     * @param value The line to write.
     */
    writeLineIndented(value) {
        this.writer.writeLineIndented(value);
        return this;
    }
    /**
     * Writes the endOfLineString to the output.
     * @param value Any value to write before the endOfLineString string is written.
     */
    writeEndOfLine(value) {
        this.writer.writeEndOfLine(value);
        return this;
    }
    ;
    /**
      * Writes the contents of the specified file to the output.
      * @param fileName The path of the file, relative to the template.
      * @param encoding Optional: the encoding that is used for the file. The default is 'utf-8'.
      */
    writeFile(path, encoding) {
        this.writer.writeFile(path, encoding);
        return this;
    }
    /**
    * Writes the contents of the specified file region to the output.
    * @param regionName The name of the region to write. The region should be marked using "/// <region>code goes here...</region>".
    * @param fileName The path of the file, relative to the template.
    * @param encoding The encoding that is used for the file. The default is 'utf-8'.
    */
    writeFileRegion(regionName, path, encoding) {
        return this.writer.writeFileRegion(regionName, path, encoding);
    }
    /**
    * Writes the current indentString to the output.
    */
    writeIndent() {
        this.writer.writeIndent();
        return this;
    }
    ;
    /**
    * Increases the current indent, which is prefixed to each line of the output.
    */
    increaseIndent() {
        this.writer.increaseIndent();
        return this;
    }
    /**
    * Decreases the current indent, which is prefixed to each line of the output.
    */
    decreaseIndent() {
        this.writer.decreaseIndent();
        return this;
    }
    /**
     * Resets any indentation, causing new line writes to start at the first character position.
     */
    clearIndent() {
        this.writer.clearIndent();
        return this;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

exports.StringUtility = StringUtility;
exports.NameUtility = NameUtility;
exports.CodeWriterUtility = CodeWriterUtility;
exports.ConsoleLogger = ConsoleLogger;
exports.UniqueId = UniqueId;
exports.ModelTransformPipeline = ModelTransformPipeline;
exports.CodeWriter = CodeWriter;

Object.defineProperty(exports, '__esModule', { value: true });

})));
