/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Performs a sequence of model transforms, where the output of each transform is
 * the input of the next transform.
 */
var ModelTransformPipeline = /** @class */ (function () {
    /**
     * Creates a new ModelTransformPipeline, optionally initialized with a collection of transforms.
     * @param transform sAny transforms to initialize the pipeline with.
     */
    function ModelTransformPipeline() {
        var transforms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            transforms[_i] = arguments[_i];
        }
        this.transforms = transforms || [];
    }
    /**
    * Adds a new collection of transforms to the pipeline.
    * @param transforms The transforms to be added.
    */
    ModelTransformPipeline.prototype.addRange = function () {
        var _this = this;
        var transforms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            transforms[_i] = arguments[_i];
        }
        transforms.forEach(function (t) {
            _this.transforms.push(t);
        });
    };
    /**
     * Adds a new transform to the pipeline.
     * @param transform The transform to be added.
     */
    ModelTransformPipeline.prototype.add = function (transform) {
        if (!transform)
            return;
        this.transforms.push(transform);
    };
    /**
    * Transforms the source model by applying the specified transforms in sequence.
    * @returns The output of the last transform that was applied.
    */
    ModelTransformPipeline.prototype.transform = function (model) {
        if (this.transforms == null)
            return model;
        var transformedModel = model;
        this.transforms.forEach(function (t) {
            transformedModel = t.transform(transformedModel);
        });
        return transformedModel;
    };
    return ModelTransformPipeline;
}());
export { ModelTransformPipeline };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwtdHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21vZGVsLXRyYW5zZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFZSDs7O0dBR0c7QUFDSDtJQUdJOzs7T0FHRztJQUNIO1FBQVksb0JBQXVDO2FBQXZDLFVBQXVDLEVBQXZDLHFCQUF1QyxFQUF2QyxJQUF1QztZQUF2QywrQkFBdUM7O1FBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7OztNQUdFO0lBQ0sseUNBQVEsR0FBZjtRQUFBLGlCQUlDO1FBSmUsb0JBQXVDO2FBQXZDLFVBQXVDLEVBQXZDLHFCQUF1QyxFQUF2QyxJQUF1QztZQUF2QywrQkFBdUM7O1FBQ25ELFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDO1lBQ2hCLEtBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7T0FHRztJQUNJLG9DQUFHLEdBQVYsVUFBVyxTQUFpQztRQUN4QyxJQUFJLENBQUMsU0FBUztZQUFFLE9BQU87UUFFdkIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7TUFHRTtJQUNLLDBDQUFTLEdBQWhCLFVBQWlCLEtBQWE7UUFDMUIsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUk7WUFDdkIsT0FBTyxLQUFLLENBQUM7UUFFakIsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFDN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBQSxDQUFDO1lBQ3JCLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUNyRCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sZ0JBQWdCLENBQUM7SUFDNUIsQ0FBQztJQUNMLDZCQUFDO0FBQUQsQ0FBQyxBQTdDRCxJQTZDQyJ9