(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('path'), require('fs'), require('@yellicode/elements'), require('@yellicode/core')) :
	typeof define === 'function' && define.amd ? define(['exports', 'path', 'fs', '@yellicode/elements', '@yellicode/core'], factory) :
	(factory((global['@yellicode/templating'] = {}),global.path,global.fs,global.elements,global.core));
}(this, (function (exports,path,fs,elements,core) { 'use strict';

/**
 * Specifies (from inside a template) how to deal with generating files that already exist.
 */

(function (OutputMode) {
    /**
     * The output file will be truncated if it exists. This is the default value.
     */
    OutputMode[OutputMode["Overwrite"] = 0] = "Overwrite";
    /**
     * The output file will not be truncated if it already exists. Use this option if you want
     * to update the file manually once it is generated.
     */
    OutputMode[OutputMode["Once"] = 1] = "Once";
    /**
     * The template output will be appended to the file if it already exists. The file is created if it
     * does not exist.
     */
    OutputMode[OutputMode["Append"] = 2] = "Append";
})(exports.OutputMode || (exports.OutputMode = {}));

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * The default implementation of the FileRegionMapper interface.
 * Uses the format "/// &lt;${regionName}&gt; ... /// &lt;/${regionName}&gt;".
 */
class DefaultRegionMarkerFormatter {
    /**
    * Gets a string that uniquely identifies the start of a region.
    * @param regionName The name of the region.
    * @returns A string in the format "/// &lt;${regionName}&gt;".
    */
    getRegionStartMarker(regionName) {
        return `/// <${regionName}>`;
    }
    /**
    * Gets a string that uniquely identifies the end of a region.
    * @param regionName The name of the region.
    * @returns A string in the format "/// &lt;/${regionName}&gt;".
    */
    getRegionEndMarker(regionName) {
        return `/// </${regionName}>`;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
const fs$1 = require('fs');
const path$1 = require('path');
const os = require('os');
/**
 * Internal writer class that is passed to WriterBase implementations. We don't let people inherit from TextWriter directly because
 * we want to control the instantiation and lifetime of each StreamWriter instance.
 */
class StreamWriter {
    /**
     * Constructor. Creates a new StreamWriter that writes to the provided WritableStream.
     * @param stream A Node.js WritableStream instance.
     * @param regionMarkerFormatter An optional RegionMarkerFormatter.
     */
    constructor(stream, regionMarkerFormatter) {
        this.stream = stream;
        this.indent = 0;
        this.textFileCache = {};
        this.endOfLineString = os.EOL;
        this.indentString = "\t";
        this.templateDirName = path$1.resolve('.');
        this.fileRegionMapper = regionMarkerFormatter == null ? new DefaultRegionMarkerFormatter() : regionMarkerFormatter;
    }
    /******************************************************************************
     *                          TextWriter implementation
    ******************************************************************************/
    /**
    * Writes a new line to the output. The line is indented automatically. The line is ended with the endOfLineString.
    * @param value The line to write. When omitted, only the endOfLineString is written.
    */
    writeLine(value) {
        if (value) {
            this.stream.write(this.createIndentString() + value + this.endOfLineString);
        }
        else
            this.stream.write(this.endOfLineString);
        return this;
    }
    ;
    /**
    * Writes a collection of lines to the output. Each line is indented automatically and ended with the endOfLineString.
    * @param values The lines to write.
    * @param delimiter An optional delimiter to be written at the end of each line, except for the last one.
    */
    writeLines(values, delimiter) {
        if (!values)
            return this;
        const len = values.length;
        values.forEach((value, index) => {
            this.stream.write(this.createIndentString() + value);
            if (delimiter && index < len - 1) {
                this.stream.write(delimiter);
            }
            this.stream.write(this.endOfLineString);
        });
        return this;
    }
    /**
     * Writes a new line to the output while temporarily increasing the indent. The line is ended with the endOfLineString.
     * @param value The line to write.
     */
    writeLineIndented(value) {
        this.stream.write(this.indentString + this.createIndentString() + value + this.endOfLineString);
        return this;
    }
    writeEndOfLine(value) {
        if (value) {
            this.stream.write(value);
        }
        this.stream.write(this.endOfLineString);
        return this;
    }
    writeIndent() {
        this.stream.write(this.createIndentString());
        return this;
    }
    ;
    write(value) {
        if (value == null)
            return this; // avoid 'May not write null values to stream'
        this.stream.write(value);
        return this;
    }
    ;
    writeWhiteSpace() {
        this.write(" ");
        return this;
    }
    increaseIndent() {
        this.indent++;
        return this;
    }
    decreaseIndent() {
        if (this.indent > 0) {
            this.indent--;
        }
        return this;
    }
    clearIndent() {
        this.indent = 0;
        return this;
    }
    writeFile(path$$1, encoding) {
        const fullPath = this.resolveFileName(path$$1);
        const contents = this.readTextFile(fullPath, false, encoding);
        if (contents == null || contents.length <= 0)
            return this;
        this.stream.write(contents);
        return this;
    }
    writeFileRegion(regionName, path$$1, encoding) {
        if (this.fileRegionMapper == null || regionName == null || regionName.length === 0 || path$$1 == null || path$$1.length === 0)
            return false;
        const fullPath = this.resolveFileName(path$$1);
        const contents = this.readTextFile(fullPath, true, encoding);
        if (contents == null || contents.length <= 0)
            return false;
        // First find the region match 
        const regionStartMarker = this.fileRegionMapper.getRegionStartMarker(regionName);
        const regionStartIndex = contents.indexOf(regionStartMarker);
        if (regionStartIndex < 0) {
            return false;
        }
        const regionEndMarker = this.fileRegionMapper.getRegionEndMarker(regionName);
        const regionEndIndex = contents.indexOf(regionEndMarker, regionStartIndex);
        if (regionEndIndex < 0) {
            return false;
        }
        var region = contents.substring(regionStartIndex + regionStartMarker.length, regionEndIndex);
        this.stream.write(region);
        this.writeEndOfLine();
        return true;
    }
    /******************************************************************************
     *                         End of TextWriter implementation
    ******************************************************************************/
    createIndentString() {
        var result = "";
        for (let i = 0; i < this.indent; i++) {
            result += this.indentString;
        }
        return result;
    }
    ;
    resolveFileName(fileName) {
        return path$1.join(this.templateDirName, fileName);
    }
    readTextFile(path$$1, useCache, encoding) {
        if (useCache && this.textFileCache.hasOwnProperty(path$$1)) {
            return this.textFileCache[path$$1];
        }
        if (!fs$1.existsSync(path$$1)) {
            //  this.writeLine(`Cannot write the contents of file '${fullPath}' because the file does not exist.`);
            if (useCache) {
                this.textFileCache[path$$1] = null;
            }
            return undefined;
        }
        if (encoding != null) {
            encoding = encoding.toLowerCase();
        }
        else
            encoding = 'utf-8';
        var contents = fs$1.readFileSync(path$$1, encoding);
        if (contents == null || contents.length === 0)
            return undefined;
        // Remove any utf-8 BOM if there is any
        if (encoding === 'utf-8' && contents.charCodeAt(0) === 0xFEFF) {
            contents = contents.slice(1);
        }
        if (useCache) {
            this.textFileCache[path$$1] = contents;
        }
        return contents;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
const fs$2 = require('fs');
const path$2 = require('path');
class FileSystemUtility {
    static makeDirectoryRecursive(dir) {
        const baseDir = path$2.dirname(dir);
        // Base dir exists, no recursion necessary
        if (fs$2.existsSync(baseDir)) {
            fs$2.mkdirSync(dir, parseInt('0777', 8));
            return;
        }
        // Base dir does not exist, go recursive
        FileSystemUtility.makeDirectoryRecursive(baseDir);
        // Base dir created, can create dir
        fs$2.mkdirSync(dir, parseInt('0777', 8));
    }
    static ensureDirectory(dir) {
        if (fs$2.existsSync(dir)) {
            return;
        }
        FileSystemUtility.makeDirectoryRecursive(dir);
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Uses the active host process logger for log message.
 */
class ToHostLogger {
    log(message, level) {
        const processMessage = { log: { level: level, message: message } };
        process.send(processMessage); // https://github.com/Microsoft/TypeScript/issues/10158
    }
    verbose(message) {
        this.log(message, core.LogLevel.Verbose);
    }
    info(message) {
        this.log(message, core.LogLevel.Info);
    }
    warn(message) {
        this.log(message, core.LogLevel.Warning);
    }
    error(message) {
        this.log(message, core.LogLevel.Error);
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
class InternalGenerator {
    constructor() {
        this.outputMode = exports.OutputMode.Overwrite;
        this.modelBuilderResult = null;
        this.modelBuilderPromise = null;
        this.parseProcessArgs(process.argv);
        const startedMessage = { cmd: 'processStarted' };
        this.sendProcessMessage(startedMessage);
        this.logger = new ToHostLogger();
    }
    parseProcessArgs(args) {
        for (let index = 0; index < args.length; index++) {
            const val = args[index];
            if (val === '--templateArgs') {
                this.templateArgs = InternalGenerator.parseTemplateArgs(args, index);
            }
            else if (val === '--outputMode') {
                this.outputMode = InternalGenerator.parseOutputMode(args, index) || this.outputMode;
            }
        }
    }
    static parseOutputMode(args, index) {
        if (args.length <= index + 1)
            return null;
        const outputModeString = args[index + 1];
        switch (outputModeString) {
            case 'append':
                return exports.OutputMode.Append;
            case 'once':
                return exports.OutputMode.Once;
            case 'overwrite':
                return exports.OutputMode.Overwrite;
            default:
                return null;
        }
    }
    static parseTemplateArgs(args, index) {
        if (args.length <= index + 1)
            return null;
        const templateArgsString = args[index + 1];
        if (templateArgsString.length > 0) {
            return JSON.parse(templateArgsString);
        }
        return null;
    }
    sendProcessMessage(message) {
        process.send(message); // https://github.com/Microsoft/TypeScript/issues/10158        
    }
    generate(options, template) {
        this.generateInternal(options, (writer) => {
            template(writer);
            return Promise.resolve();
        });
    }
    generateAsync(options, template) {
        this.generateInternal(options, template);
    }
    /**
     * Executes the provided template using the model that was configured in the code generation configuration.
     */
    generateFromModel(options, template) {
        this.getModel(options)
            .then((model) => {
            this.generateInternal(options, (writer) => {
                template(writer, model);
                return Promise.resolve();
            });
        }).catch((err) => {
            console.log(err);
        });
    }
    generateFromModelAsync(options, template) {
        this.getModel(options)
            .then((model) => {
            this.generateInternal(options, (writer) => {
                return template(writer, model);
            });
        }).catch((err) => {
            console.log(err);
        });
    }
    generateInternal(options, callback) {
        // Get the working directory. The host will make sure that this is the directory in which the template resides.
        const templateDirName = path.resolve('./');
        // console.log('Generator: Template directory name is \'%s\'', templateDirName);
        const fullOutputFileName = path.join(templateDirName, options.outputFile);
        // Ensure that the directory exists        
        FileSystemUtility.ensureDirectory(path.dirname(fullOutputFileName));
        // Let the host know that we started something so that we don't get killed
        var startedMessage = { cmd: 'generateStarted' };
        this.sendProcessMessage(startedMessage);
        // console.log('Generator: Generating file \'%s\'...', fullOutputFileName);
        const mode = options.outputMode === undefined ? this.outputMode : options.outputMode;
        if (mode === exports.OutputMode.Once && fs.existsSync(fullOutputFileName)) {
            // Don't regenerate the file
            var finishedMessage = { cmd: 'generateFinished' };
            this.sendProcessMessage(finishedMessage);
            return;
        }
        const flags = mode === exports.OutputMode.Append ? 'a' : 'w';
        const writeStream = fs.createWriteStream(fullOutputFileName, { flags: flags });
        writeStream.once('open', (fd) => {
            var cw = new StreamWriter(writeStream, options.regionMarkerFormatter);
            callback(cw)
                .then(() => {
                writeStream.end();
                // console.log('Generator: Finished generating \'%s\'...', fullOutputFileName);
                // Let the host know that we are done
                var finishedMessage = { cmd: 'generateFinished' };
                this.sendProcessMessage(finishedMessage);
            });
        });
    }
    /**
    * Loads the model that was configured in the code generation configuration.
    */
    getModel(options) {
        const codeModelOptions = options || {};
        const parseJson = codeModelOptions.noParse !== true;
        if (this.modelBuilderResult || this.modelBuilderPromise) {
            return this.getModelFromModelBuilder(options);
        }
        const promise = new Promise((resolve$$1, reject) => {
            process.on('message', (m) => {
                if (m.cmd !== 'setModel') {
                    return;
                }
                if (!m.modelData) {
                    return reject('The host returned an empty model. Please make sure that a model has been configured for this template.');
                }
                let model;
                // Should we parse the model into a Yellicode model?                                
                if (parseJson && elements.ModelReader.canRead(m.modelData)) {
                    // The modelData will contain a Yellicode document with two main nodes: a 'model' node and an optional 'profiles' node.
                    // We need to parse the entire document (because profiles must be applied) and then return
                    // just the model part.
                    const document = elements.ModelReader.readDocument(m.modelData);
                    if (document) {
                        model = document.model;
                    }
                    else
                        model = null;
                }
                else
                    model = m.modelData; // return plain JSON
                // Apply transforms                
                let targetModel;
                if (model && codeModelOptions.modelTransform) {
                    targetModel = codeModelOptions.modelTransform.transform(model);
                }
                else
                    targetModel = model;
                resolve$$1(targetModel);
            });
        });
        var getModelMessage = { cmd: 'getModel' };
        this.sendProcessMessage(getModelMessage);
        return promise;
    }
    getModelFromModelBuilder(options) {
        const codeModelOptions = options || {};
        const applyTransform = (model) => {
            if (model && codeModelOptions.modelTransform) {
                return codeModelOptions.modelTransform.transform(model);
            }
            return model;
        };
        if (this.modelBuilderResult) {
            // this.logger.verbose('getModelFromModelBuilder: returning current modelBuilderResult.');            
            return Promise.resolve(applyTransform(this.modelBuilderResult));
        }
        else if (this.modelBuilderPromise) {
            // this.logger.verbose('getModelFromModelBuilder: waiting for modelBuilderPromise.');
            return this
                .modelBuilderPromise
                .then(((m) => {
                // this.logger.verbose('getModelFromModelBuilder: modelBuilderPromise done.');
                return applyTransform(m);
            }));
        }
        else
            return Promise.reject('An unexpected internal error has occured.'); // either modelBuilderResult or modelBuilderPromise will have a value, see getModel
    }
    buildModel(builder) {
        // We need to signal the CLI that we started something async and that is should not kill us.
        // Use the 'generateStarted' / 'generateFinished' commands for now, although we should really use a different command.        
        this.logger.verbose(`Generator.buildModel starting...`);
        this.sendProcessMessage({ cmd: 'generateStarted' });
        // Set up a promise to be returned to the caller, althoug it is optional to use it.
        let resolveFunctionPromise;
        let rejectFunctionPromise;
        const functionPromise = new Promise((resolve$$1, reject) => {
            // resolve when builder resolves
            resolveFunctionPromise = resolve$$1;
            rejectFunctionPromise = reject;
        });
        this.modelBuilderResult = null;
        this.modelBuilderPromise = builder()
            .then((result) => {
            this.modelBuilderResult = result;
            // var d2 = new Date();
            // this.logger.verbose(`${d2.getMinutes()}:${d2.getMilliseconds()}: buildModel finished`);
            this.logger.verbose(`Generator.buildModel finished.`);
            resolveFunctionPromise(result);
            // Let the host know that we are 'done'                
            this.sendProcessMessage({ cmd: 'generateFinished' });
            return result;
        })
            .catch((e) => rejectFunctionPromise(e));
        return functionPromise;
    }
}
const Generator = new InternalGenerator();

/**
 * The abstract base class for all code writers. This writer implements the TextWriter interface by decorating
 * the TextWriter provided in the constructor.
 * @deprecated CodeWriter has moved to the 'yellicode/core' package, please update your references.
 */
class CodeWriter {
    // NOTE: only documenting the get accessors because the TS compiler we use for doc generation concats the doc 
    // comments for the getter and setter.
    /**
    * Gets or sets the end of line string. The default value is platform dependent.
    */
    get endOfLineString() {
        return this.writer.endOfLineString;
    }
    set endOfLineString(value) {
        this.writer.endOfLineString = value;
    }
    /**
     * Gets or sets the indent string. The default value is a '\t' (tab character).
    */
    get indentString() {
        return this.writer.indentString;
    }
    set indentString(value) {
        this.writer.indentString = value;
    }
    /**
     * Constructor. Creates a new CodeWriter that uses the provided TextWriter internally.
     * @param writer A TextWriter object. In a code generation template, a TextWriter instance can be obtained by calling any of the generate...()
     * functions on the current CodeGenerator.
     */
    constructor(writer) {
        console.warn(`CodeWriter has moved to the '@yellicode/core' package, please update your references.`);
        this.writer = writer;
    }
    /******************************************************************************
     *                          TextWriter delegation
    ******************************************************************************/
    /**
     * Writes a string value to the output.
     * @param value The string value to be written.
     */
    write(value) {
        this.writer.write(value);
        return this;
    }
    ;
    /**
    * Writes a single whitespace character to the output.
    */
    writeWhiteSpace() {
        this.writer.writeWhiteSpace();
        return this;
    }
    /**
    * Writes a new line to the output. The line is indented automatically. The line is ended with the endOfLineString.
    * @param value The line to write. When omitted, only the endOfLineString is written.
    */
    writeLine(value) {
        this.writer.writeLine(value);
        return this;
    }
    ;
    /**
   * Writes a collection of lines to the output. Each line is indented automatically and ended with the endOfLineString.
   * @param values The lines to write.
   * @param delimiter An optional delimiter to be written at the end of each line, except for the last one.
   */
    writeLines(values, delimiter) {
        this.writer.writeLines(values, delimiter);
        return this;
    }
    /**
     * Writes a new line to the output while temporarily increasing the indent. The line is ended with the endOfLineString.
     * @param value The line to write.
     */
    writeLineIndented(value) {
        this.writer.writeLineIndented(value);
        return this;
    }
    /**
     * Writes the endOfLineString to the output.
     * @param value Any value to write before the endOfLineString string is written.
     */
    writeEndOfLine(value) {
        this.writer.writeEndOfLine(value);
        return this;
    }
    ;
    /**
      * Writes the contents of the specified file to the output.
      * @param fileName The path of the file, relative to the template.
      * @param encoding Optional: the encoding that is used for the file. The default is 'utf-8'.
      */
    writeFile(path$$1, encoding) {
        this.writer.writeFile(path$$1, encoding);
        return this;
    }
    /**
    * Writes the contents of the specified file region to the output.
    * @param regionName The name of the region to write. The region should be marked using "/// <region>code goes here...</region>".
    * @param fileName The path of the file, relative to the template.
    * @param encoding The encoding that is used for the file. The default is 'utf-8'.
    */
    writeFileRegion(regionName, path$$1, encoding) {
        return this.writer.writeFileRegion(regionName, path$$1, encoding);
    }
    /**
    * Writes the current indentString to the output.
    */
    writeIndent() {
        this.writer.writeIndent();
        return this;
    }
    ;
    /**
    * Increases the current indent, which is prefixed to each line of the output.
    */
    increaseIndent() {
        this.writer.increaseIndent();
        return this;
    }
    /**
    * Decreases the current indent, which is prefixed to each line of the output.
    */
    decreaseIndent() {
        this.writer.decreaseIndent();
        return this;
    }
    /**
     * Resets any indentation, causing new line writes to start at the first character position.
     */
    clearIndent() {
        this.writer.clearIndent();
        return this;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Contains helper methods that can be used by custom code writers and templates.
 * @deprecated CodeWriterUtility has moved to the 'yellicode/core' package, please update your references.
 */
class CodeWriterUtility {
    /**
     * Wraps the provided string input to a specified maximum width.
     * @argument str The string to be wrapped.
     * @argument width The maximum width of the wrapped text in characters.
     * @returns A string array containing all lines.
     */
    static wordWrap(str, width) {
        console.warn(`CodeWriterUtility has moved to the '@yellicode/core' package, please update your references.`);
        const result = [];
        if (width < 1 || str == null || str.length <= width)
            return result;
        const len = str.length;
        let rangeMax = len - width; // we don't need to split after this position
        let rangeStart = 0;
        let subString;
        while (rangeStart < rangeMax) {
            let subLength;
            let rangeEnd = rangeStart + width;
            // First test for newlines in this range. If so, don't split on word break but on the newline.
            var ixNewLine = str.indexOf("\n", rangeStart);
            if (ixNewLine > -1 && ixNewLine > rangeStart && ixNewLine < rangeEnd) {
                subLength = ixNewLine - rangeStart;
                subString = str.substr(rangeStart, subLength);
                rangeStart = rangeStart + subLength + 1;
                result.push(subString);
                continue;
            }
            // No newlines. Find the last wordbreak in the range.
            let ix = str.lastIndexOf(" ", rangeEnd); // find the last word break
            let rangeStartNext = 0;
            if (ix > -1 && ix != rangeStart - 1) {
                subLength = ix - rangeStart;
                if (subLength > 0) {
                    rangeStartNext = rangeStart + subLength + 1; // +1 to skip the whitespace
                }
                //else { // not needed anymore because of the maxPos check
                //    sub = str.substr(pos);
                //    newPos = len + 1;
                //}
            }
            else {
                // The range has no whitespace. 
                subLength = width;
                rangeStartNext = rangeStart + width;
            }
            subString = str.substr(rangeStart, subLength);
            rangeStart = rangeStartNext;
            result.push(subString.trim());
        }
        // Add the remainder
        if (rangeStart < len) {
            subString = str.substr(rangeStart);
            result.push(subString);
        }
        //  console.debug(result);
        return result;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Provides helper functions for converting names.
 */
class NameUtility {
    /**
    * Makes the first character of the string uppercase.
    * @deprecated NameUtility has moved to the 'yellicode/core' package, please update your references.
    */
    static capitalize(input) {
        console.warn(`NameUtility has moved to the '@yellicode/core' package, please update your references.`);
        if (!input)
            return input;
        return core.StringUtility.capitalize(input);
    }
    /**
     * Makes the first character of the string lowercase.
     * @deprecated NameUtility has moved to the 'yellicode/core' package, please update your references.
     */
    static unCapitalize(input) {
        console.warn(`NameUtility has moved to the '@yellicode/core' package, please update your references.`);
        if (!input)
            return input;
        return core.StringUtility.unCapitalize(input);
    }
    /**
     * Converts a UpperCamelCase or lowerCamelCase string to a kebab-case (aka dash-case) string.
     * @param input A camelCase or UpperCamelCase string.
     * @returns a kebab-case (aka dash-case) string, meaning all lowercase with a dash separating words.
     * @deprecated NameUtility has moved to the 'yellicode/core' package, please update your references.
     */
    static camelToKebabCase(input) {
        console.warn(`NameUtility has moved to the '@yellicode/core' package, please update your references.`);
        if (!input)
            return input;
        const result = [];
        for (var i = 0, len = input.length; i < len; i++) {
            var c = input.charAt(i);
            const upperCase = c.toUpperCase();
            const lowerCase = c.toLowerCase();
            const isUpperCase = (c === upperCase && c !== lowerCase);
            if (isUpperCase && i > 0 && i < len - 1) {
                let insertHyphen = true;
                if (i < len - 1 && core.StringUtility.isUpperCase(input.charAt(i + 1))) {
                    // The next character is also uppercase
                    insertHyphen = false;
                }
                if (insertHyphen) {
                    result.push('-');
                }
            }
            result.push(lowerCase);
        }
        return result.join('');
    }
    /**
     * Converts a UpperCamelCase string to a lowerCamelCase string.
     * @param input A UpperCamelCase string.
     * @returns a lowerCamelCase string.
     * @deprecated NameUtility has moved to the 'yellicode/core' package, please update your references.
     */
    static upperToLowerCamelCase(input) {
        console.warn(`NameUtility has moved to the '@yellicode/core' package, please update your references.`);
        if (!input)
            return input;
        let done = false;
        let isPreviousMatch = false;
        const result = new Array(input.length);
        for (var i = 0, len = input.length; i < len; i++) {
            var c = input.charAt(i);
            if (!done) {
                const upperCase = c.toUpperCase();
                const lowerCase = c.toLowerCase();
                const isMatch = (c === upperCase && c !== lowerCase);
                if (isMatch) {
                    // The character is upperCase, make it lowerCase      
                    c = lowerCase;
                }
                else {
                    // The character is lowerCase. We are done, but..                
                    if (isPreviousMatch && i > 1) {
                        // ... if we converted the previous char to lowercase, make it uppercase again.    
                        // For example: ISBNNumber would become isbnNumber instead of isbnnumber
                        result[i - 1] = result[i - 1].toUpperCase();
                    }
                    done = true;
                }
                isPreviousMatch = isMatch;
            }
            result[i] = c;
        }
        return result.join('');
    }
    /**
   * Converts a lowerCamelCase string to a UpperCamelCase string.
   * @param input A lowerCamelCase string.
   * @returns a UpperCamelCase string.
   * @deprecated NameUtility has moved to the 'yellicode/core' package, please update your references.
   */
    static lowerToUpperCamelCase(input) {
        console.warn(`NameUtility has moved to the '@yellicode/core' package, please update your references.`);
        return core.StringUtility.capitalize(input);
    }
    /**
     * Converts a kebab-case, lowerCamelCase or UpperCamelCase string to an ALL_UPPER_CASE string.
     * @param input A kebab-case (aka dash-case), lowerCamelCase or UpperCamelCase string.
     * @returns an ALL_UPPER_CASE string.
     * @deprecated NameUtility has moved to the 'yellicode/core' package, please update your references.
     */
    static toAllUpperCase(input) {
        console.warn(`NameUtility has moved to the '@yellicode/core' package, please update your references.`);
        if (!input)
            return input;
        const result = [];
        for (var i = 0, len = input.length; i < len; i++) {
            var c = input.charAt(i);
            const upperCase = c.toUpperCase();
            const lowerCase = c.toLowerCase();
            const isUpperCase = (c === upperCase && c !== lowerCase);
            const isDash = c === '-';
            if ((isDash || isUpperCase) && i > 0 && i < len - 1) {
                let insertHyphen = true;
                if (i < len - 1 && core.StringUtility.isUpperCase(input.charAt(i + 1))) {
                    // The next character is also uppercase
                    insertHyphen = false;
                }
                if (insertHyphen) {
                    result.push('_');
                }
            }
            if (!isDash)
                result.push(upperCase);
        }
        return result.join('');
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Default implementation of the TypeNameProvider interface. This implementation
 * returns type names as-is, but allows inheritors to provide their own implementation
 * by overriding getTypeNameForType and/or getTypeNameForTypedElement.
 * @deprecated DefaultTypeNameProvider has moved to the 'yellicode/elements' package, please update your references.
 */
class DefaultTypeNameProvider {
    constructor() {
        console.warn(`DefaultTypeNameProvider has moved to the '@yellicode/elements' package, please update your references.`);
    }
    getTypeName(typeOrTypedElement) {
        if (elements.isTypedElement(typeOrTypedElement)) {
            // The argument is a typedElement            
            const isMultiValued = elements.isMultiplicityElement(typeOrTypedElement) && typeOrTypedElement.isMultivalued();
            return this.getTypeNameForTypedElement(typeOrTypedElement, elements.isDataType(typeOrTypedElement.type), isMultiValued);
        }
        else {
            // The argument is a type
            return this.getTypeNameForType(typeOrTypedElement, elements.isDataType(typeOrTypedElement));
        }
    }
    /**
    * Returns the name of the provided type. This function is also called by getTypeNameOfTypedElement() if that function is not overridden.
    * @param type The type information.
    * @param isDataType Indicates if the type is a data type (that is, an Enumeration, PrimitiveType or DataType).
    */
    getTypeNameForType(type, isDataType$$1) {
        // Note: we don't use isDataType in this default implementation, but it is considered relevant for implementers.
        return type ? type.name : null;
    }
    /**
    * Returns the name of the provided element's type. Internally, this function calls getTypeNameForType for the type, but
    * you should override this function if you need to provide different type names for a type depending on the context.
    * For example, you may return a different type name for a property or parameter that is multi-valued.
    * @param typedElement Any element that has a type.
    * @param isDataType Indicates if the element's type is a data type (that is, an Enumeration, PrimitiveType or DataType).
    * @param isMultiValued Indicates if the TypedElement is multi-valued (that is, has an upper bound greater than 1).
    */
    getTypeNameForTypedElement(typedElement, isDataType$$1, isMultiValued) {
        // Note: we don't use isMultiValued in this default implementation, but it is considered relevant for implementers.
        return this.getTypeNameForType(typedElement.type, isDataType$$1);
    }
    /**
     * DEPRECATED: Returns the name of the provided element's data type. Override this function to map primitives and other data types
     * (both built-in or types exported from a profile) to the target language. The default implementation calls the
     * getDataTypeNameForType function using the type of the typedElement.
     * @param typedElement Any TypedElement instance.
     * @deprecated Please override getTypeNameForTypedElement instead.
     */
    getDataTypeName(typedElement) {
        console.warn(`DefaultTypeNameProvider.getDataTypeName is deprecated. Please override getTypeNameForTypedElement instead.`);
        const isMultiValued = elements.isMultiplicityElement(typedElement) && typedElement.isMultivalued();
        return this.getTypeNameForTypedElement(typedElement, true, isMultiValued);
    }
    /**
    * DEPRECATED: Returns the name of the provided data type. Override this function to map primitives and other data types
    * (both built-in or types exported from a profile) to the target language.
    * @param type The type information.
    * @deprecated Please override getTypeNameForType instead.
    */
    getDataTypeNameForType(type) {
        console.warn(`DefaultTypeNameProvider.getDataTypeNameForType is deprecated. Please override getTypeNameForType instead.`);
        return this.getTypeNameForType(type, true);
    }
    /**
     * DEPRECATED: Returns the name of the provided element's complex type (any type that is not a DataType). Override this function to provide
     * a custom name for the complex type. The default implementation calls the getComplexTypeNameForType function using
     * the type of the typedElement.
     * @param typedElement Any TypedElement instance.
     * @deprecated Please override getTypeNameForTypedElement instead.
     */
    getComplexTypeName(typedElement) {
        console.warn(`DefaultTypeNameProvider.getComplexTypeName is deprecated. Please override getTypeNameForTypedElement instead.`);
        const isMultiValued = elements.isMultiplicityElement(typedElement) && typedElement.isMultivalued();
        return this.getTypeNameForTypedElement(typedElement, false, isMultiValued);
    }
    /**
    * DEPRECATED: Returns the name of the provided complex type (any type that is not a DataType). Override this function to provide
    * a custom name for the complex type.
    * @param type The type information.
    * @deprecated Please override getTypeNameForType instead.
    */
    getComplexTypeNameForType(type) {
        console.warn(`DefaultTypeNameProvider.getComplexTypeNameForType is deprecated. Please override getTypeNameForType instead.`);
        return this.getTypeNameForType(type, false);
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Performs a sequence of model transforms, where the output of each transform is
 * the input of the next transform.
 * @deprecated ModelTransformPipeline has moved to the 'yellicode/core' package, please update your references.
 */
class ModelTransformPipeline {
    /**
     * Creates a new ModelTransformPipeline, optionally initialized with a collection of transforms.
     * @param transform sAny transforms to initialize the pipeline with.
     */
    constructor(...transforms) {
        console.warn(`ModelTransformPipeline has moved to the '@yellicode/core' package, please update your references.`);
        this.transforms = transforms || [];
    }
    /**
    * Adds a new collection of transforms to the pipeline.
    * @param transforms The transforms to be added.
    */
    addRange(...transforms) {
        transforms.forEach(t => {
            this.transforms.push(t);
        });
    }
    /**
     * Adds a new transform to the pipeline.
     * @param transform The transform to be added.
     */
    add(transform) {
        if (!transform)
            return;
        this.transforms.push(transform);
    }
    /**
    * Transforms the source model by applying the specified transforms in sequence.
    * @returns The output of the last transform that was applied.
    */
    transform(model) {
        if (this.transforms == null)
            return model;
        let transformedModel = model;
        this.transforms.forEach(t => {
            transformedModel = t.transform(transformedModel);
        });
        return transformedModel;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * A base class for transforms that need to be applied recursively to all nested packaged elements
 * in a model or package.
 * @deprecated PackagedElementTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class PackagedElementTransform {
    constructor() {
        console.warn(`PackagedElementTransform has moved to the 'yellicode/elements' package, please update your references.`);
    }
    /**
     * Transforms the package and returns the transformation result.
     * @param pack The package or model to transform.
     */
    transform(pack) {
        if (pack == null)
            return pack;
        this.transformElement(pack);
        this.transformPackageRecursive(pack);
        return pack;
    }
    transformPackageRecursive(pack) {
        if (pack.packagedElements == null)
            return;
        pack.packagedElements.forEach((element) => {
            this.transformElement(element);
            if (elements.ElementTypeUtility.isPackage(element.elementType)) {
                this.transformPackageRecursive(element);
            }
        });
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Transforms a Model or Package by returning just the Package that matches a specified expression.
 * @deprecated PackageFilterTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class PackageFilterTransform {
    /**
     * Constructor. Creates a new PackageFilterTransform that only includes the package with the specified name.
     * @param expression The name of the package. If the name ends with a forward-slash ('/'), nested
     * packages will be included. The expression is case-insensitive.
     */
    constructor(expression) {
        console.warn(`PackageFilterTransform has moved to the 'yellicode/elements' package, please update your references.`);
        if (!expression) {
            throw `Unable to filter packages. The filter expression cannot be empty.`;
        }
        const normalizedExpression = expression.toLowerCase();
        if (normalizedExpression.endsWith('/')) {
            this.includeNestedPackages = true;
            this.packageName = normalizedExpression.substring(0, normalizedExpression.length - 1);
        }
        else {
            this.packageName = normalizedExpression;
            this.includeNestedPackages = false;
        }
    }
    /**
     * Transforms the source Model or Package and returns the first Package that matches the expression.
     * The result will be empty if the package could not be found.
     * @param source The Model or Package to transform.
     */
    transform(source) {
        if (!source || !source.packagedElements)
            return source;
        const pack = PackageFilterTransform.findPackageRecursive(source, (pack) => {
            return (pack.name != null) && (pack.name.toLowerCase() === this.packageName);
        });
        if (!pack)
            throw `Unable to filter packages. Could not find any nested package with name '${this.packageName}'.`;
        // Remove any nested packages if needed
        if (!this.includeNestedPackages && pack.packagedElements != null) {
            pack.packagedElements = pack.packagedElements.filter(e => !(elements.ElementTypeUtility.isPackage(e.elementType)));
        }
        return pack;
    }
    static findPackageRecursive(root, predicate) {
        if (predicate(root))
            return root;
        if (root.packagedElements == null)
            return null;
        // We use a for loop so that we can easily return when we 
        for (var i = 0, len = root.packagedElements.length; i < len; i++) {
            const packagedElement = root.packagedElements[i];
            if (packagedElement.elementType === elements.ElementType.package) {
                const childResult = PackageFilterTransform.findPackageRecursive(packagedElement, predicate);
                if (childResult != null)
                    return childResult;
            }
        }
        return null;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// Note: using plural words here to avoid using reserved keywords.
/**
 * Enumerates which element types to be renamed when performing rename transforms.
 */

(function (RenameTargets) {
    /**
     * No elements are renamed.
     */
    RenameTargets[RenameTargets["none"] = 0] = "none";
    /**
     * Classes are renamed.
     */
    RenameTargets[RenameTargets["classes"] = 1] = "classes";
    /**
     * Interfaces are renamed.
     */
    RenameTargets[RenameTargets["interfaces"] = 2] = "interfaces";
    /**
     * Properties are renamed.
     */
    RenameTargets[RenameTargets["properties"] = 4] = "properties";
    /**
     * Operations are renamed.
     */
    RenameTargets[RenameTargets["operations"] = 8] = "operations";
    /**
     * Operation parameters are renamed.
     */
    RenameTargets[RenameTargets["parameters"] = 16] = "parameters";
    /**
     * Enumerations are renamed.
     */
    RenameTargets[RenameTargets["enumerations"] = 32] = "enumerations";
    /**
     * Enumeration literals are renamed.
     */
    RenameTargets[RenameTargets["enumerationLiterals"] = 64] = "enumerationLiterals";
    /**
     * All members are renamed: properties, operations, parameters and enumerationLiterals.
     */
    RenameTargets[RenameTargets["allMembers"] = 92] = "allMembers";
    /**
     * All elements are renamed.
     */
    RenameTargets[RenameTargets["all"] = 127] = "all";
})(exports.RenameTargets || (exports.RenameTargets = {}));
/**
 * A base class for renaming classes, interfaces, properties, operations parameters, enumerations and enumeration literals.
 * @deprecated RenamingTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class RenamingTransform extends PackagedElementTransform {
    /**
     * Constructor. Creates a new RenamingTransform with the specified targets.
     * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
     */
    constructor(targets) {
        console.warn(`RenamingTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super();
        this.targets = targets == null ? exports.RenameTargets.all : targets;
    }
    hasTarget(target) {
        if (this.targets & target)
            return true;
        else
            return false;
    }
    transformElement(element) {
        if (!elements.ElementTypeUtility.isMemberedClassifier(element.elementType))
            return;
        if (this.hasTarget(exports.RenameTargets.classes) && elements.ElementTypeUtility.isClass(element.elementType)) {
            element.name = this.rename(element.name, element);
        }
        if (this.hasTarget(exports.RenameTargets.interfaces) && elements.ElementTypeUtility.isInterface(element.elementType)) {
            element.name = this.rename(element.name, element);
        }
        // The element has OwnedAttributes and OwnedOperations
        var classifier = element;
        if (classifier.ownedAttributes != null && this.hasTarget(exports.RenameTargets.properties)) {
            classifier.ownedAttributes.forEach(att => {
                att.name = this.rename(att.name, att);
            });
        }
        if (classifier.ownedOperations != null) {
            classifier.ownedOperations.forEach(op => {
                if (this.hasTarget(exports.RenameTargets.operations)) {
                    op.name = this.rename(op.name, op);
                }
                if (this.hasTarget(exports.RenameTargets.parameters)) {
                    op.ownedParameters.forEach(p => {
                        p.name = this.rename(p.name, p);
                    });
                }
            });
        }
        if (elements.ElementTypeUtility.isEnumeration(element.elementType)) {
            var enumeration = element;
            if (this.hasTarget(exports.RenameTargets.enumerations)) {
                enumeration.name = this.rename(enumeration.name, enumeration);
            }
            if (enumeration.ownedLiterals != null && this.hasTarget(exports.RenameTargets.enumerationLiterals)) {
                enumeration.ownedLiterals.forEach(literal => {
                    literal.name = this.rename(literal.name, literal);
                });
            }
        }
    }
}
/**
 * A transform that capitalizes its rename targets, that is, makes the
 * first character uppercase.
 * @deprecated CapitalizingTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class CapitalizingTransform extends RenamingTransform {
    /**
     * Constructor. Creates a new CapitalizingTransform with the specified targets.
     * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
     */
    constructor(targets) {
        console.warn(`CapitalizingTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super(targets);
    }
    rename(name, target) {
        return NameUtility.capitalize(name);
    }
}
/**
 * A transform that uncapitalizes its rename targets, that is, makes the
 * first character lowercase.
 * @deprecated UnCapitalizingTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class UnCapitalizingTransform extends RenamingTransform {
    /**
     * Constructor. Creates a new UnCapitalizingTransform with the specified targets.
     * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
     */
    constructor(targets) {
        console.warn(`UnCapitalizingTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super(targets);
    }
    rename(name, target) {
        return NameUtility.unCapitalize(name);
    }
}
/**
 * A transform that converts its rename targets from UpperCamelCase to lowerCamelCase.
 *  @deprecated UpperToLowerCamelCaseTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class UpperToLowerCamelCaseTransform extends RenamingTransform {
    /**
       * Constructor. Creates a new UpperToLowerCamelCaseTransform with the specified targets.
       * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
       */
    constructor(targets) {
        console.warn(`UpperToLowerCamelCaseTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super(targets);
    }
    rename(name, target) {
        return NameUtility.upperToLowerCamelCase(name);
    }
}
/**
 * A transform that converts its rename targets from lowerCamelCase to UpperCamelCase.
 * @deprecated LowerToUpperCamelCaseTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class LowerToUpperCamelCaseTransform extends RenamingTransform {
    /**
       * Constructor. Creates a new LowerToUpperCamelCaseTransform with the specified targets.
       * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
       */
    constructor(targets) {
        console.warn(`LowerToUpperCamelCaseTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super(targets);
    }
    rename(name, target) {
        return NameUtility.lowerToUpperCamelCase(name);
    }
}
/**
 * A transform that adds a prefix to its rename targets.
 * @deprecated PrefixingTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class PrefixingTransform extends RenamingTransform {
    /**
    * Constructor. Creates a new PrefixingTransform with the specified targets.
    * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
    */
    constructor(targets, prefix) {
        console.warn(`PrefixingTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super(targets);
        this.prefix = prefix;
    }
    rename(name, target) {
        return this.prefix + name;
    }
}
/**
 * A transform that adds a suffix to its rename targets.
 * @deprecated SuffixingTransform has moved to the 'yellicode/elements' package, please update your references.
 */
class SuffixingTransform extends RenamingTransform {
    /**
    * Constructor. Creates a new SuffixingTransform with the specified targets.
    * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
    */
    constructor(targets, suffix) {
        console.warn(`SuffixingTransform has moved to the 'yellicode/elements' package, please update your references.`);
        super(targets);
        this.suffix = suffix;
    }
    rename(name, target) {
        return name + this.suffix;
    }
}

/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

exports.Generator = Generator;
exports.CodeWriter = CodeWriter;
exports.CodeWriterUtility = CodeWriterUtility;
exports.NameUtility = NameUtility;
exports.DefaultTypeNameProvider = DefaultTypeNameProvider;
exports.ModelTransformPipeline = ModelTransformPipeline;
exports.PackagedElementTransform = PackagedElementTransform;
exports.PackageFilterTransform = PackageFilterTransform;
exports.RenamingTransform = RenamingTransform;
exports.CapitalizingTransform = CapitalizingTransform;
exports.UnCapitalizingTransform = UnCapitalizingTransform;
exports.UpperToLowerCamelCaseTransform = UpperToLowerCamelCaseTransform;
exports.LowerToUpperCamelCaseTransform = LowerToUpperCamelCaseTransform;
exports.PrefixingTransform = PrefixingTransform;
exports.SuffixingTransform = SuffixingTransform;

Object.defineProperty(exports, '__esModule', { value: true });

})));
