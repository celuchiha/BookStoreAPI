/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * Performs a sequence of model transforms, where the output of each transform is
 * the input of the next transform.
 * @deprecated ModelTransformPipeline has moved to the 'yellicode/core' package, please update your references.
 */
var ModelTransformPipeline = /** @class */ (function () {
    /**
     * Creates a new ModelTransformPipeline, optionally initialized with a collection of transforms.
     * @param transform sAny transforms to initialize the pipeline with.
     */
    function ModelTransformPipeline() {
        var transforms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            transforms[_i] = arguments[_i];
        }
        console.warn("ModelTransformPipeline has moved to the '@yellicode/core' package, please update your references.");
        this.transforms = transforms || [];
    }
    /**
    * Adds a new collection of transforms to the pipeline.
    * @param transforms The transforms to be added.
    */
    ModelTransformPipeline.prototype.addRange = function () {
        var _this = this;
        var transforms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            transforms[_i] = arguments[_i];
        }
        transforms.forEach(function (t) {
            _this.transforms.push(t);
        });
    };
    /**
     * Adds a new transform to the pipeline.
     * @param transform The transform to be added.
     */
    ModelTransformPipeline.prototype.add = function (transform) {
        if (!transform)
            return;
        this.transforms.push(transform);
    };
    /**
    * Transforms the source model by applying the specified transforms in sequence.
    * @returns The output of the last transform that was applied.
    */
    ModelTransformPipeline.prototype.transform = function (model) {
        if (this.transforms == null)
            return model;
        var transformedModel = model;
        this.transforms.forEach(function (t) {
            transformedModel = t.transform(transformedModel);
        });
        return transformedModel;
    };
    return ModelTransformPipeline;
}());
export { ModelTransformPipeline };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwtdHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3RyYW5zZm9ybXMvbW9kZWwtdHJhbnNmb3JtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQWFIOzs7O0dBSUc7QUFDSDtJQUdJOzs7T0FHRztJQUNIO1FBQVksb0JBQXVDO2FBQXZDLFVBQXVDLEVBQXZDLHFCQUF1QyxFQUF2QyxJQUF1QztZQUF2QywrQkFBdUM7O1FBQy9DLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUdBQW1HLENBQUMsQ0FBQztRQUNsSCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7TUFHRTtJQUNLLHlDQUFRLEdBQWY7UUFBQSxpQkFJQztRQUplLG9CQUF1QzthQUF2QyxVQUF1QyxFQUF2QyxxQkFBdUMsRUFBdkMsSUFBdUM7WUFBdkMsK0JBQXVDOztRQUNuRCxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQztZQUNoQixLQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSSxvQ0FBRyxHQUFWLFVBQVcsU0FBaUM7UUFDeEMsSUFBSSxDQUFDLFNBQVM7WUFBRSxPQUFPO1FBRXZCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7O01BR0U7SUFDSywwQ0FBUyxHQUFoQixVQUFpQixLQUFhO1FBQzFCLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJO1lBQ3ZCLE9BQU8sS0FBSyxDQUFDO1FBRWpCLElBQUksZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1FBQzdCLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQztZQUNyQixnQkFBZ0IsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDckQsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLGdCQUFnQixDQUFDO0lBQzVCLENBQUM7SUFDTCw2QkFBQztBQUFELENBQUMsQUE5Q0QsSUE4Q0MifQ==