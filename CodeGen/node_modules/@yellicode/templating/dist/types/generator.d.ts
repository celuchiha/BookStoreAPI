import * as elements from '@yellicode/elements';
import { TextWriter } from './text-writer';
import { RegionMarkerFormatter } from './region-marker-formatter';
import { ModelTransform } from "./transforms/model-transform";
/**
 * Defines the options for retrieving a model to be used as input for code generation.
 */
export interface CodeModelOptions<TSource, TTarget> {
    /**
     * Specifies an optional model transform that is applied to the model before it is returned.
     */
    modelTransform?: ModelTransform<TSource, TTarget>;
    /**
     * When true, no attempt will be made to parse the JSON data as a Yellicode model and the plain JSON
     * data will be returned.
     */
    noParse?: boolean;
}
/**
 * Defines the options for generating a code file with the CodeGenerator.
 */
export interface CodeGenerationOptions {
    /**
     * The path of the output file, relative to the template file.
     */
    outputFile: string;
    /**
     * Indicates what to do if the output file already exists. By default, the output file will be overwritten,
     * unless a diffent mode is configured in the 'outputMode' setting for this template in the codegenconfig.json.
     * If outputMode has a value, the template configuration will be ignored.
     */
    outputMode?: OutputMode;
    /**
     * Provides an optional RegionMarkerFormatter that provides region start- and end markers based on a region name.
     * Region markers must be used in files that must to be merged with generated code.
     * If not specified, the default region marker format is used.
     */
    regionMarkerFormatter?: RegionMarkerFormatter;
}
/**
 * Combines the CodeGenerationOptions and CodeModelOptions for the generateFromModel function.
 */
export interface ModelBasedCodeGenerationOptions<TModel, TTargetModel> extends CodeGenerationOptions, CodeModelOptions<TModel, TTargetModel> {
}
/**
 * The primary interface for code generation using a template. An instance can be
 * obtained by importing the exported "Generator" constant into the template.
 */
export interface CodeGenerator {
    /**
     * Gets any template arguments that were configured for the template instance in the codegenconfig.json file.
     */
    templateArgs: any | null;
    /**
     * Executes the specified code generation template without any model.
     * @param options The code generation options.
     * @param template A callback function that writes code to the provided TextWriter.
     */
    generate(options: CodeGenerationOptions, template: (writer: TextWriter) => void): void;
    /**
     * Executes the specified code generation template without any model.
     * @param options The code generation options.
     * @param template A callback function that writes code to the provided TextWriter. This callback should
     * return a Promise<void> when writing has finished.
     */
    generateAsync(options: CodeGenerationOptions, template: (writer: TextWriter) => Promise<void>): void;
    /**
     * Gets the model that is configured for the current template.
     * @param options The model options.
     */
    getModel<TSource = elements.Model, TTarget = TSource>(options?: CodeModelOptions<TSource, TTarget>): Promise<TTarget>;
    /**
     * Executes the specified code generation template with the model that is configured for the current template.
     * @param options The code generation options.
     */
    generateFromModel<TSourceModel = elements.Model, TTargetModel = TSourceModel>(options: ModelBasedCodeGenerationOptions<TSourceModel, TTargetModel>, template: (writer: TextWriter, model: TTargetModel) => void): void;
    /**
     * Executes the specified code generation template with the model that is configured for the current template.
     * @param options The code generation options.
     * @param template A callback function that writes code to the provided TextWriter. This callback should
     * return a Promise<void> when writing has finished.
     */
    generateFromModelAsync<TSourceModel = elements.Model, TTargetModel = TSourceModel>(options: ModelBasedCodeGenerationOptions<TSourceModel, TTargetModel>, template: (writer: TextWriter, model: TTargetModel) => Promise<void>): void;
}
export declare enum OutputMode {
    /**
     * The output file will be truncated if it exists. This is the default value.
     */
    Overwrite = 0,
    /**
     * The output file will not be truncated if it already exists. Use this option if you want
     * to update the file manually once it is generated.
     */
    Once = 1,
    /**
     * The template output will be appended to the file if it already exists. The file is created if it
     * does not exist.
     */
    Append = 2
}
export declare const Generator: CodeGenerator;
