/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
import * as path from 'path';
import * as fs from 'fs';
import { ModelReader } from '@yellicode/elements';
import { StreamWriter } from './stream-writer';
import { FileSystemUtility } from './file-system-utility';
import { OutputMode } from './options';
import { ToHostLogger } from './to-host-logger';
class InternalGenerator {
    constructor() {
        this.outputMode = OutputMode.Overwrite;
        this.modelBuilderResult = null;
        this.modelBuilderPromise = null;
        this.parseProcessArgs(process.argv);
        const startedMessage = { cmd: 'processStarted' };
        this.sendProcessMessage(startedMessage);
        this.logger = new ToHostLogger();
    }
    parseProcessArgs(args) {
        for (let index = 0; index < args.length; index++) {
            const val = args[index];
            if (val === '--templateArgs') {
                this.templateArgs = InternalGenerator.parseTemplateArgs(args, index);
            }
            else if (val === '--outputMode') {
                this.outputMode = InternalGenerator.parseOutputMode(args, index) || this.outputMode;
            }
        }
    }
    static parseOutputMode(args, index) {
        if (args.length <= index + 1)
            return null;
        const outputModeString = args[index + 1];
        switch (outputModeString) {
            case 'append':
                return OutputMode.Append;
            case 'once':
                return OutputMode.Once;
            case 'overwrite':
                return OutputMode.Overwrite;
            default:
                return null;
        }
    }
    static parseTemplateArgs(args, index) {
        if (args.length <= index + 1)
            return null;
        const templateArgsString = args[index + 1];
        if (templateArgsString.length > 0) {
            return JSON.parse(templateArgsString);
        }
        return null;
    }
    sendProcessMessage(message) {
        process.send(message); // https://github.com/Microsoft/TypeScript/issues/10158        
    }
    generate(options, template) {
        this.generateInternal(options, (writer) => {
            template(writer);
            return Promise.resolve();
        });
    }
    generateAsync(options, template) {
        this.generateInternal(options, template);
    }
    /**
     * Executes the provided template using the model that was configured in the code generation configuration.
     */
    generateFromModel(options, template) {
        this.getModel(options)
            .then((model) => {
            this.generateInternal(options, (writer) => {
                template(writer, model);
                return Promise.resolve();
            });
        }).catch((err) => {
            console.log(err);
        });
    }
    generateFromModelAsync(options, template) {
        this.getModel(options)
            .then((model) => {
            this.generateInternal(options, (writer) => {
                return template(writer, model);
            });
        }).catch((err) => {
            console.log(err);
        });
    }
    generateInternal(options, callback) {
        // Get the working directory. The host will make sure that this is the directory in which the template resides.
        const templateDirName = path.resolve('./');
        // console.log('Generator: Template directory name is \'%s\'', templateDirName);
        const fullOutputFileName = path.join(templateDirName, options.outputFile);
        // Ensure that the directory exists        
        FileSystemUtility.ensureDirectory(path.dirname(fullOutputFileName));
        // Let the host know that we started something so that we don't get killed
        var startedMessage = { cmd: 'generateStarted' };
        this.sendProcessMessage(startedMessage);
        // console.log('Generator: Generating file \'%s\'...', fullOutputFileName);
        const mode = options.outputMode === undefined ? this.outputMode : options.outputMode;
        if (mode === OutputMode.Once && fs.existsSync(fullOutputFileName)) {
            // Don't regenerate the file
            var finishedMessage = { cmd: 'generateFinished' };
            this.sendProcessMessage(finishedMessage);
            return;
        }
        const flags = mode === OutputMode.Append ? 'a' : 'w';
        const writeStream = fs.createWriteStream(fullOutputFileName, { flags: flags });
        writeStream.once('open', (fd) => {
            var cw = new StreamWriter(writeStream, options.regionMarkerFormatter);
            callback(cw)
                .then(() => {
                writeStream.end();
                // console.log('Generator: Finished generating \'%s\'...', fullOutputFileName);
                // Let the host know that we are done
                var finishedMessage = { cmd: 'generateFinished' };
                this.sendProcessMessage(finishedMessage);
            });
        });
    }
    /**
    * Loads the model that was configured in the code generation configuration.
    */
    getModel(options) {
        const codeModelOptions = options || {};
        const parseJson = codeModelOptions.noParse !== true;
        if (this.modelBuilderResult || this.modelBuilderPromise) {
            return this.getModelFromModelBuilder(options);
        }
        const promise = new Promise((resolve, reject) => {
            process.on('message', (m) => {
                if (m.cmd !== 'setModel') {
                    return;
                }
                if (!m.modelData) {
                    return reject('The host returned an empty model. Please make sure that a model has been configured for this template.');
                }
                let model;
                // Should we parse the model into a Yellicode model?                                
                if (parseJson && ModelReader.canRead(m.modelData)) {
                    // The modelData will contain a Yellicode document with two main nodes: a 'model' node and an optional 'profiles' node.
                    // We need to parse the entire document (because profiles must be applied) and then return
                    // just the model part.
                    const document = ModelReader.readDocument(m.modelData);
                    if (document) {
                        model = document.model;
                    }
                    else
                        model = null;
                }
                else
                    model = m.modelData; // return plain JSON
                // Apply transforms                
                let targetModel;
                if (model && codeModelOptions.modelTransform) {
                    targetModel = codeModelOptions.modelTransform.transform(model);
                }
                else
                    targetModel = model;
                resolve(targetModel);
            });
        });
        var getModelMessage = { cmd: 'getModel' };
        this.sendProcessMessage(getModelMessage);
        return promise;
    }
    getModelFromModelBuilder(options) {
        const codeModelOptions = options || {};
        const applyTransform = (model) => {
            if (model && codeModelOptions.modelTransform) {
                return codeModelOptions.modelTransform.transform(model);
            }
            return model;
        };
        if (this.modelBuilderResult) {
            // this.logger.verbose('getModelFromModelBuilder: returning current modelBuilderResult.');            
            return Promise.resolve(applyTransform(this.modelBuilderResult));
        }
        else if (this.modelBuilderPromise) {
            // this.logger.verbose('getModelFromModelBuilder: waiting for modelBuilderPromise.');
            return this
                .modelBuilderPromise
                .then(((m) => {
                // this.logger.verbose('getModelFromModelBuilder: modelBuilderPromise done.');
                return applyTransform(m);
            }));
        }
        else
            return Promise.reject('An unexpected internal error has occured.'); // either modelBuilderResult or modelBuilderPromise will have a value, see getModel
    }
    buildModel(builder) {
        // We need to signal the CLI that we started something async and that is should not kill us.
        // Use the 'generateStarted' / 'generateFinished' commands for now, although we should really use a different command.        
        this.logger.verbose(`Generator.buildModel starting...`);
        this.sendProcessMessage({ cmd: 'generateStarted' });
        // Set up a promise to be returned to the caller, althoug it is optional to use it.
        let resolveFunctionPromise;
        let rejectFunctionPromise;
        const functionPromise = new Promise((resolve, reject) => {
            // resolve when builder resolves
            resolveFunctionPromise = resolve;
            rejectFunctionPromise = reject;
        });
        this.modelBuilderResult = null;
        this.modelBuilderPromise = builder()
            .then((result) => {
            this.modelBuilderResult = result;
            // var d2 = new Date();
            // this.logger.verbose(`${d2.getMinutes()}:${d2.getMilliseconds()}: buildModel finished`);
            this.logger.verbose(`Generator.buildModel finished.`);
            resolveFunctionPromise(result);
            // Let the host know that we are 'done'                
            this.sendProcessMessage({ cmd: 'generateFinished' });
            return result;
        })
            .catch((e) => rejectFunctionPromise(e));
        return functionPromise;
    }
}
export const Generator = new InternalGenerator();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWwtZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVybmFsLWdlbmVyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUV6QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFbEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTFELE9BQU8sRUFBRSxVQUFVLEVBQTRFLE1BQU0sV0FBVyxDQUFDO0FBQ2pILE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVoRDtJQU9JO1FBTFEsZUFBVSxHQUFlLFVBQVUsQ0FBQyxTQUFTLENBQUM7UUFDOUMsdUJBQWtCLEdBQWUsSUFBSSxDQUFDO1FBQ3RDLHdCQUFtQixHQUF3QixJQUFJLENBQUM7UUFJcEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQyxNQUFNLGNBQWMsR0FBb0IsRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQztRQUNsRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ3JDLENBQUM7SUFFTyxnQkFBZ0IsQ0FBQyxJQUFjO1FBQ25DLEtBQUssSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQzlDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN4QixJQUFJ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