(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@yellicode/elements'), require('@yellicode/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@yellicode/elements', '@yellicode/core'], factory) :
    (factory((global['@yellicode/csharp'] = {}),global.elements,global.core));
}(this, (function (exports,elements,core) { 'use strict';

    /**
     * Enumerates the possible collection types to generated for properties and parameters.
     */
    (function (CollectionType) {
        CollectionType[CollectionType["ICollection"] = 0] = "ICollection";
        CollectionType[CollectionType["IEnumerable"] = 1] = "IEnumerable";
        CollectionType[CollectionType["IList"] = 2] = "IList";
    })(exports.CollectionType || (exports.CollectionType = {}));
    (function (NamespaceFeatures) {
        NamespaceFeatures[NamespaceFeatures["None"] = 0] = "None";
        NamespaceFeatures[NamespaceFeatures["All"] = 0] = "All";
    })(exports.NamespaceFeatures || (exports.NamespaceFeatures = {}));
    (function (ClassFeatures) {
        ClassFeatures[ClassFeatures["None"] = 0] = "None";
        ClassFeatures[ClassFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        ClassFeatures[ClassFeatures["Generalizations"] = 2] = "Generalizations";
        ClassFeatures[ClassFeatures["InterfaceRealizations"] = 4] = "InterfaceRealizations";
        ClassFeatures[ClassFeatures["All"] = 7] = "All";
    })(exports.ClassFeatures || (exports.ClassFeatures = {}));
    (function (StructFeatures) {
        StructFeatures[StructFeatures["None"] = 0] = "None";
        StructFeatures[StructFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        StructFeatures[StructFeatures["InterfaceRealizations"] = 2] = "InterfaceRealizations";
        StructFeatures[StructFeatures["All"] = 3] = "All";
    })(exports.StructFeatures || (exports.StructFeatures = {}));
    (function (InterfaceFeatures) {
        InterfaceFeatures[InterfaceFeatures["None"] = 0] = "None";
        InterfaceFeatures[InterfaceFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        InterfaceFeatures[InterfaceFeatures["Generalizations"] = 2] = "Generalizations";
        InterfaceFeatures[InterfaceFeatures["All"] = 3] = "All";
    })(exports.InterfaceFeatures || (exports.InterfaceFeatures = {}));
    (function (EnumFeatures) {
        EnumFeatures[EnumFeatures["None"] = 0] = "None";
        EnumFeatures[EnumFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        /**
         * Writes enumeration member initializers. This flag only applies when values are provided in the model.
         */
        EnumFeatures[EnumFeatures["Initializers"] = 2] = "Initializers";
        EnumFeatures[EnumFeatures["All"] = 3] = "All";
    })(exports.EnumFeatures || (exports.EnumFeatures = {}));
    (function (EnumMemberFeatures) {
        EnumMemberFeatures[EnumMemberFeatures["None"] = 0] = "None";
        EnumMemberFeatures[EnumMemberFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        /**
         * Writes enumeration member initializers. This flag only applies when values are provided in the model.
         */
        EnumMemberFeatures[EnumMemberFeatures["Initializers"] = 2] = "Initializers";
        EnumMemberFeatures[EnumMemberFeatures["All"] = 3] = "All";
    })(exports.EnumMemberFeatures || (exports.EnumMemberFeatures = {}));
    (function (PropertyFeatures) {
        PropertyFeatures[PropertyFeatures["None"] = 0] = "None";
        PropertyFeatures[PropertyFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        /**
         * The access modifier if the owner is not an Interface.
         */
        PropertyFeatures[PropertyFeatures["AccessModifier"] = 2] = "AccessModifier";
        PropertyFeatures[PropertyFeatures["OptionalModifier"] = 4] = "OptionalModifier";
        PropertyFeatures[PropertyFeatures["All"] = 7] = "All";
    })(exports.PropertyFeatures || (exports.PropertyFeatures = {}));
    (function (MethodFeatures) {
        MethodFeatures[MethodFeatures["None"] = 0] = "None";
        MethodFeatures[MethodFeatures["XmlDocSummary"] = 1] = "XmlDocSummary";
        MethodFeatures[MethodFeatures["XmlDocParameters"] = 2] = "XmlDocParameters";
        MethodFeatures[MethodFeatures["XmlDocReturns"] = 4] = "XmlDocReturns";
        /**
        * The access modifier if the owner is not an Interface.
        */
        MethodFeatures[MethodFeatures["AccessModifier"] = 8] = "AccessModifier";
        MethodFeatures[MethodFeatures["All"] = 15] = "All";
    })(exports.MethodFeatures || (exports.MethodFeatures = {}));

    const reservedKeywords = ["abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
        "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new",
        "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
        "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"];
    /**
     * Returns true if the input string is a reserved C# keyword.
     * @param input Any input string to check.
     */
    function isReservedKeyword(input) {
        if (!input)
            return false;
        return (reservedKeywords.indexOf(input) >= 0);
    }

    class CSharpTypeNameProvider extends elements.DefaultTypeNameProvider {
        getTypeNameForType(type, isDataType) {
            if (!type)
                return null;
            if (isDataType) {
                if (elements.isPrimitiveBoolean(type))
                    return "bool";
                if (elements.isPrimitiveInteger(type))
                    return "int";
                if (elements.isPrimitiveReal(type))
                    return "double"; // By default, a real numeric literal on the right side of the assignment operator is treated as double (https://msdn.microsoft.com/en-us/library/b1e65aza.aspx)
                if (elements.isPrimitiveString(type))
                    return "string";
                if (elements.isPrimitiveObject(type))
                    return "object";
            }
            return super.getTypeNameForType(type, isDataType);
        }
        static canBeNullable(typedElement, csTypeName) {
            if (!typedElement || !csTypeName)
                return false;
            // A collection cannot be nullable
            if (elements.isMultiplicityElement(typedElement) && typedElement.isMultivalued()) {
                return false;
            }
            // Check the mapped type name (it could come from a custom TypeNameProvider) 
            switch (csTypeName) { // the following cannot be nullable:
                case 'string':
                case 'System.String':
                case 'object':
                case 'System.Object':
                    return false;
            }
            // Check the type itself
            const type = typedElement.type;
            if (!type)
                return false;
            return elements.isEnumeration(type) || elements.isDataType(type); // isDataType includes PrimitiveType      
        }
    }

    class CSharpCommentWriter {
        constructor(writer, maxCommentWidth) {
            this.writer = writer;
            this.maxCommentWidth = maxCommentWidth;
        }
        writeDelimitedCommentParagraph(text) {
            if (text == null)
                return;
            const lines = [text];
            this.writer.writeLine("/*");
            this.writeCommentLines(lines, "* ");
            this.writer.writeLine("*/");
        }
        writeDelimitedCommentLines(lines) {
            if (lines == null)
                return;
            this.writer.writeLine("/*");
            this.writeCommentLines(lines, "* ");
            this.writer.writeLine("*/");
        }
        writeCommentLines(lines, prefix) {
            if (!lines)
                return;
            lines.forEach(line => {
                if (line == null)
                    return;
                if (this.maxCommentWidth > 0 && line.length > this.maxCommentWidth) {
                    // See if we can split the line
                    const split = core.CodeWriterUtility.wordWrap(line, this.maxCommentWidth);
                    split.forEach(s => {
                        this.writer.writeLine(`${prefix}${s}`);
                    });
                }
                else
                    this.writer.writeLine(`${prefix}${line}`);
            });
        }
    }

    class XmlDocUtility {
        static getXmlDocLineForParameter(parameter) {
            if (!parameter.xmlDocSummary)
                return null;
            const commentBodies = XmlDocUtility.joinCommentBodies(parameter.xmlDocSummary);
            return `<param name=\"${parameter.name}\">${commentBodies}</param>`;
        }
        static getXmlDocLineForReturnParameter(method) {
            if (!method.xmlDocReturns)
                return null;
            const commentBodies = XmlDocUtility.joinCommentBodies(method.xmlDocReturns);
            return `<returns>${commentBodies}</returns>`;
        }
        static getXmlDocLinesForInOutParameters(parameters) {
            if (!parameters)
                return [];
            var lines = [];
            parameters.forEach((p) => {
                const l = XmlDocUtility.getXmlDocLineForParameter(p);
                if (l)
                    lines.push(l);
            });
            return lines;
        }
        static joinCommentBodies(bodies) {
            if (!bodies)
                return '';
            return bodies.join(' ');
        }
    }

    class DefinitionBuilder {
        constructor(typeNameProvider) {
            this.typeNameProvider = typeNameProvider;
        }
        buildNamespaceDefinition(pack, options) {
            if (!options)
                options = {};
            // We have no namespace features yet, but the NamespaceFeatures type is there for future extension
            const features = (options.features === undefined) ? exports.NamespaceFeatures.All : options.features;
            let name;
            if (options.writeFullName) {
                const allPackages = pack.getNestingPackages();
                allPackages.push(pack); // add the package itself
                name = allPackages.map(p => p.name).join('.');
            }
            else
                name = pack.name;
            return { name: name };
        }
        buildClassDefinition(type, options) {
            // Initialize options and features
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.ClassFeatures.All : options.features;
            // Build the base definition
            const definition = DefinitionBuilder.buildTypeDefinition(type, !!(features & exports.ClassFeatures.XmlDocSummary), options);
            // Build the class-specific definition
            definition.inherits = DefinitionBuilder.buildInherits(type, options.inherits);
            definition.implements = DefinitionBuilder.buildImplements(type, options.implements);
            if (elements.isClass(type)) {
                definition.isAbstract = type.isAbstract || options.isAbstract;
            }
            return definition;
        }
        buildStructDefinition(type, options) {
            // Initialize options and features
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.StructFeatures.All : options.features;
            // Build the base definition
            const definition = DefinitionBuilder.buildTypeDefinition(type, !!(features & exports.StructFeatures.XmlDocSummary), options);
            // Build the struct-specific definition        
            definition.implements = DefinitionBuilder.buildImplements(type, options.implements);
            return definition;
        }
        buildInterfaceDefinition(type, options) {
            // Initialize options and features
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.InterfaceFeatures.All : options.features;
            // Build the base definition
            const definition = DefinitionBuilder.buildTypeDefinition(type, !!(features & exports.InterfaceFeatures.XmlDocSummary), options);
            // Build the interface-specific definition
            definition.inherits = DefinitionBuilder.buildInherits(type, options.inherits);
            return definition;
        }
        buildEnumMemberDefinition(literal, isLast, options) {
            // Initialize options and features
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.EnumMemberFeatures.All : options.features;
            const buildInitializers = !!(features & exports.EnumFeatures.Initializers);
            // Build the base definition
            const definition = DefinitionBuilder.buildDefinitionBase(literal, !!(features & exports.EnumMemberFeatures.XmlDocSummary));
            // Build the member-specific definition
            definition.isLast = isLast || false;
            if (buildInitializers && literal.specification != null) { // using '!=' on purpose  
                const specification = literal.specification;
                definition.value = elements.isLiteralInteger(specification) ? specification.value : undefined;
            }
            return definition;
        }
        buildEnumDefinition(type, options) {
            // Initialize options and features
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.EnumFeatures.All : options.features;
            // Build the base definition         
            const definition = DefinitionBuilder.buildDefinitionBase(type, !!(features & exports.EnumFeatures.XmlDocSummary));
            // Build the enum-specific definition
            definition.accessModifier = DefinitionBuilder.getAccessModifierString(type.visibility);
            // Build enum members
            if (elements.isEnumeration(type) && type.ownedLiterals) {
                const members = [];
                // Pass on enum features to enum member features
                let memberFeatures = exports.EnumMemberFeatures.None;
                if (features & exports.EnumFeatures.XmlDocSummary)
                    memberFeatures |= exports.EnumMemberFeatures.XmlDocSummary;
                if (features & exports.EnumFeatures.Initializers)
                    memberFeatures |= exports.EnumMemberFeatures.Initializers;
                type.ownedLiterals.forEach((literal, index) => {
                    let isLast = index === type.ownedLiterals.length - 1;
                    const member = this.buildEnumMemberDefinition(literal, isLast, { features: memberFeatures });
                    members.push(member);
                });
                definition.members = members;
            }
            return definition;
        }
        buildPropertyDefinition(property, options) {
            // Initialize options and features
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.PropertyFeatures.All : options.features;
            const ownerIsInterface = elements.isInterface(property.owner);
            // Build the base definition         
            const definition = DefinitionBuilder.buildDefinitionBase(property, !!(features & exports.PropertyFeatures.XmlDocSummary));
            // Build the property-specific definition
            const typename = this.getFullTypeName(property, options.collectionType || null, 'object');
            definition.accessModifier = DefinitionBuilder.getAccessModifierString(property.visibility);
            definition.isVirtual = options.virtual;
            definition.typeName = typename;
            if (!ownerIsInterface && (features & exports.PropertyFeatures.AccessModifier))
                definition.accessModifier = DefinitionBuilder.getAccessModifierString(property.visibility);
            if ((features & exports.PropertyFeatures.OptionalModifier) &&
                property.lower === 0 &&
                CSharpTypeNameProvider.canBeNullable(property, typename)) {
                definition.isNullable = true;
            }
            definition.noSetter = property.isReadOnly || property.isDerived;
            definition.defaultValue = DefinitionBuilder.getDefaultValueString(property.defaultValue);
            return definition;
        }
        buildMethodDefinition(operation, options) {
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.MethodFeatures.All : options.features;
            const ownerIsInterface = elements.isInterface(operation.owner);
            // Build the base definition         
            const definition = DefinitionBuilder.buildDefinitionBase(operation, !!(features & exports.MethodFeatures.XmlDocSummary));
            definition.isConstructor = operation.isConstructor;
            definition.isStatic = operation.isStatic;
            definition.isPartial = options.isPartial;
            if (!operation.isConstructor) {
                definition.isAbstract = options.isAbstract || (!options.isVirtual && operation.isAbstract);
                definition.isVirtual = options.isVirtual;
            }
            if (!ownerIsInterface)
                definition.accessModifier = DefinitionBuilder.getAccessModifierString(operation.visibility);
            // Get the return type and documentation
            if (!operation.isConstructor) {
                var returnParameter = operation.getReturnParameter();
                if (returnParameter) {
                    definition.returnTypeName = this.getFullTypeName(returnParameter, options.collectionType || null);
                    if (features & exports.MethodFeatures.XmlDocReturns) {
                        definition.xmlDocReturns = DefinitionBuilder.buildXmlDocSummary(operation);
                    }
                }
            }
            // Build parameter definitions      
            definition.parameters = this.buildParameterDefinitions(operation.ownedParameters, options);
            return definition;
        }
        buildParameterDefinitions(params, options) {
            if (!options)
                options = {};
            const features = (options.features === undefined) ? exports.MethodFeatures.All : options.features;
            const inOutParameters = [];
            if (!params)
                return inOutParameters;
            params.forEach(p => {
                if (p.direction === elements.ParameterDirectionKind.return)
                    return;
                const typeName = this.getFullTypeName(p, options.collectionType || null, 'object');
                const paramDefinition = DefinitionBuilder.buildDefinitionBase(p, !!(features & exports.MethodFeatures.XmlDocParameters));
                paramDefinition.isOutput = p.direction === elements.ParameterDirectionKind.out;
                paramDefinition.isReference = p.direction === elements.ParameterDirectionKind.inout;
                paramDefinition.isNullable = p.lower === 0 && CSharpTypeNameProvider.canBeNullable(p, typeName);
                paramDefinition.typeName = typeName;
                paramDefinition.defaultValue = DefinitionBuilder.getDefaultValueString(p.defaultValue),
                    inOutParameters.push(paramDefinition);
            });
            return inOutParameters;
        }
        static buildInherits(type, additional) {
            if (!elements.isClassifier(type)) {
                return;
            }
            const allNames = [];
            if (type.generalizations) {
                // todo: allow qualifiedName
                allNames.push(...type.generalizations.map(g => g.general.name));
            }
            if (additional) {
                allNames.push(...additional);
            }
            return allNames.length ? allNames : undefined;
        }
        static buildImplements(type, additional) {
            if (!elements.isBehavioredClassifier(type)) {
                return;
            }
            const allNames = [];
            if (type.interfaceRealizations) {
                // todo: allow qualifiedName 
                allNames.push(...type.interfaceRealizations.map(ir => ir.contract.name));
            }
            if (additional) {
                allNames.push(...additional);
            }
            return allNames.length ? allNames : undefined;
        }
        static buildXmlDocSummary(element) {
            if (!element.ownedComments || !element.ownedComments.length) {
                return undefined;
            }
            return element.ownedComments.map(c => c.body);
        }
        static buildTypeDefinition(type, buildXmlDocSummary, options) {
            var definition = DefinitionBuilder.buildDefinitionBase(type, buildXmlDocSummary);
            definition.accessModifier = DefinitionBuilder.getAccessModifierString(type.visibility);
            definition.isPartial = options.isPartial;
            return definition;
        }
        static buildDefinitionBase(element, buildXmlDocSummary) {
            var definition = {
                name: element.name,
                xmlDocSummary: buildXmlDocSummary ? DefinitionBuilder.buildXmlDocSummary(element) : undefined
            };
            return definition;
        }
        static getDefaultValueString(defaultValue) {
            if (!defaultValue)
                return undefined;
            return elements.isLiteralString(defaultValue) ?
                `"${defaultValue.value}"` :
                defaultValue.getStringValue();
        }
        static getAccessModifierString(visibility) {
            switch (visibility) {
                case elements.VisibilityKind.public:
                    return 'public';
                case elements.VisibilityKind.private:
                    return 'private';
                case elements.VisibilityKind.protected:
                    return 'protected';
                case elements.VisibilityKind.package:
                    return 'internal';
                default:
                    return undefined;
            }
        }
        getFullTypeName(typedElement, collectionType, fallback) {
            const typeName = this.typeNameProvider.getTypeName(typedElement) || fallback;
            if (!typeName)
                return; // no type name and no fallback
            if (elements.isMultiplicityElement(typedElement) && typedElement.isMultivalued()) {
                switch (collectionType) {
                    case exports.CollectionType.IList:
                        return `IList<${typeName}>`;
                    case exports.CollectionType.IEnumerable:
                        return `IEnumerable<${typeName}>`;
                    default:
                        return `ICollection<${typeName}>`;
                }
            }
            else
                return typeName;
        }
    }

    /**
     * A CodeWriter for writing C# code from code generation templates. This writer can write classes, interfaces, structs and enumerations and also
     * contains functions for writing namespace blocks and using directives. The CSharpWriter is compatible with Yellicode models but can also work
     * independently.
     */
    class CSharpWriter extends core.CodeWriter {
        /**
         * Constructor. Creates a new CSharpWriter instance using the TextWriter and options provided.
         * @param writer The template's current TextWriter.
         * @param options Optional: the global options for this writer.
         */
        constructor(writer, options) {
            super(writer);
            if (!options)
                options = {};
            this.typeNameProvider = options.typeNameProvider || new CSharpTypeNameProvider();
            this.definitionBuilder = new DefinitionBuilder(this.typeNameProvider);
            this.commentWriter = new CSharpCommentWriter(writer, options.maxCommentWidth || 100);
        }
        /**
         * Writes 1 or more using directives, each on a new line.
         * @param values A collection of strings, typically namespace names.
         */
        writeUsingDirectives(...values) {
            values.forEach(v => {
                this.writeLine(`using ${v};`);
            });
            return this;
        }
        /**
         * Writes an indented block of code, wrapped in opening and closing brackets.
         * @param contents A callback function that writes the contents.
         */
        writeCodeBlock(contents) {
            this.writeLine('{');
            this.increaseIndent();
            if (contents)
                contents(this);
            this.decreaseIndent();
            this.writeLine('}');
            return this;
        }
        ;
        writeNamespaceBlock(data, contents, options) {
            if (!data)
                return this;
            const definition = (elements.isPackage(data)) ?
                this.definitionBuilder.buildNamespaceDefinition(data, options) :
                data;
            this.writeLine(`namespace ${definition.name}`);
            this.writeCodeBlock(contents);
            return this;
        }
        ;
        writeClassBlock(data, contents, options) {
            if (!data)
                return this;
            const definition = (elements.isType(data)) ?
                this.definitionBuilder.buildClassDefinition(data, options) :
                data;
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            this.writeIndent();
            this.writeAccessModifier(definition);
            if (definition.isAbstract) {
                this.write('abstract ');
            }
            if (definition.isPartial) {
                this.write('partial ');
            }
            this.write(`class ${definition.name}`);
            let hasGeneralizations = false;
            hasGeneralizations = this.writeInherits(definition.inherits);
            this.writeImplements(hasGeneralizations, definition.implements);
            this.writeEndOfLine();
            this.writeCodeBlock(contents);
            return this;
        }
        writeStructBlock(data, contents, options) {
            if (!data)
                return this;
            const definition = (elements.isType(data)) ?
                this.definitionBuilder.buildStructDefinition(data, options) :
                data;
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            this.writeIndent();
            this.writeAccessModifier(definition);
            if (definition.isPartial) {
                this.write('partial ');
            }
            this.write(`struct ${definition.name}`);
            this.writeImplements(false, definition.implements);
            this.writeEndOfLine();
            this.writeCodeBlock(contents);
            return this;
        }
        writeInterfaceBlock(data, contents, options) {
            if (!data)
                return this;
            const definition = (elements.isType(data)) ?
                this.definitionBuilder.buildInterfaceDefinition(data, options) :
                data;
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            this.writeIndent();
            this.writeAccessModifier(definition);
            if (definition.isPartial) {
                this.write('partial ');
            }
            this.write(`interface ${definition.name}`);
            this.writeInherits(definition.inherits);
            this.writeEndOfLine();
            this.writeCodeBlock(contents);
            return this;
        }
        writeEnumerationBlock(data, contents, options) {
            if (!data)
                return this;
            const definition = (elements.isType(data)) ?
                this.definitionBuilder.buildEnumDefinition(data, options) :
                data;
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            this.writeIndent();
            this.writeAccessModifier(definition);
            this.write(`enum ${definition.name}`);
            this.writeEndOfLine();
            this.writeCodeBlock(contents);
            return this;
        }
        writeEnumeration(data, options) {
            if (!data)
                return this;
            const definition = (elements.isType(data)) ?
                this.definitionBuilder.buildEnumDefinition(data, options) :
                data;
            this.writeEnumerationBlock(definition, () => {
                if (definition.members) {
                    definition.members.forEach(memberDefinition => {
                        this.writeEnumMember(memberDefinition);
                    });
                }
            });
            return this;
        }
        writeEnumMember(data, options, isLast) {
            if (!data)
                return this;
            const definition = (elements.isEnumerationLiteral(data)) ?
                this.definitionBuilder.buildEnumMemberDefinition(data, isLast, options) :
                data;
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            this.writeIndent();
            this.write(definition.name);
            if (definition.value != null) { // using '!=' on purpose  
                this.write(` = ${definition.value}`);
            }
            if (!definition.isLast) {
                this.write(',');
            }
            this.writeEndOfLine();
            return this;
        }
        writeMethodDeclaration(data, options) {
            if (!data)
                return this;
            const definition = (elements.isOperation(data)) ?
                this.definitionBuilder.buildMethodDefinition(data, options) :
                data;
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            if (definition.parameters) {
                this.writeXmlDocParagraph(XmlDocUtility.getXmlDocLinesForInOutParameters(definition.parameters));
            }
            const xmlDocReturns = XmlDocUtility.getXmlDocLineForReturnParameter(definition);
            if (xmlDocReturns) {
                this.writeXmlDocParagraph([xmlDocReturns]);
            }
            this.writeIndent();
            if (!definition.isPartial) {
                this.writeAccessModifier(definition); // Partial methods are implicitly private                  
            }
            if (definition.isStatic) {
                this.write('static ');
            }
            else if (definition.isAbstract) {
                this.write('abstract ');
            }
            else if (definition.isVirtual) {
                this.write('virtual ');
            }
            if (definition.isPartial) {
                this.write('partial ');
            }
            if (definition.isPartial)
                this.write('void '); // partial methods must return void, intentional trailing white space
            else
                this.write(`${definition.returnTypeName || 'void'} `); // intentional trailing white space
            this.write(`${definition.name}(`);
            if (definition.parameters) {
                this.writeInOutParameters(definition.parameters);
            }
            this.write(');');
            this.writeEndOfLine();
            return this;
        }
        writeMethodBlock(data, contents, options) {
            if (!data)
                return this;
            const definition = (elements.isOperation(data)) ?
                this.definitionBuilder.buildMethodDefinition(data, options) :
                data;
            // Write the documentation
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            if (definition.parameters) {
                this.writeXmlDocParagraph(XmlDocUtility.getXmlDocLinesForInOutParameters(definition.parameters));
            }
            const xmlDocReturns = definition.isConstructor ? null : XmlDocUtility.getXmlDocLineForReturnParameter(definition);
            if (xmlDocReturns) {
                this.writeXmlDocParagraph([xmlDocReturns]);
            }
            // Start of the actual method      
            this.writeIndent();
            if (!definition.isPartial) {
                this.writeAccessModifier(definition); // Partial methods are implicitly private                  
            }
            if (definition.isStatic) {
                this.write('static ');
            }
            else if (definition.isAbstract) {
                this.write('abstract ');
            }
            else if (definition.isVirtual) {
                this.write('virtual ');
            }
            if (definition.isPartial) {
                this.write('partial ');
            }
            // Write the return type
            if (!definition.isConstructor) {
                if (definition.isPartial)
                    this.write('void '); // partial methods must return void, intentional trailing white space
                else
                    this.write(`${definition.returnTypeName || 'void'} `); // intentional trailing white space
            }
            this.write(`${definition.name}(`);
            if (definition.parameters) {
                this.writeInOutParameters(definition.parameters);
            }
            this.write(')');
            if (definition.isAbstract) {
                this.writeEndOfLine(';');
            }
            else {
                this.writeEndOfLine();
                this.writeCodeBlock(contents);
            }
            return this;
        }
        writeInOutParameters(data, options) {
            if (!data || !data.length) // without at least 1 element, we cannot determine the type
                return this;
            const definitions = elements.isParameter(data[0]) ?
                this.definitionBuilder.buildParameterDefinitions(data, options) : data;
            if (!definitions.length)
                return this;
            let i = 0;
            definitions.forEach(p => {
                if (i > 0) {
                    this.write(', ');
                }
                if (p.isOutput) {
                    this.write('out ');
                }
                else if (p.isReference) {
                    this.write('ref '); // The ref keyword can be used for both value- and reference types
                }
                this.write(p.typeName);
                if (p.isNullable) {
                    this.write('?');
                }
                this.write(` ${p.name}`);
                if (p.defaultValue) {
                    this.write(` = ${p.defaultValue}`);
                }
                i++;
            });
            return this;
        }
        writeAutoProperty(data, options) {
            if (!data)
                return this;
            const definition = (elements.isProperty(data)) ?
                this.definitionBuilder.buildPropertyDefinition(data, options) :
                data;
            if (definition.hasGetter != null) {
                console.warn('PropertyDefinition.hasGetter is deprecated. A getter is now written by default. Please use noGetter if you want to omit it.');
            }
            if (definition.hasSetter != null) {
                console.warn('PropertyDefinition.hasSetter is deprecated. A setter is now written by default. Please use noSetter if you want to omit it.');
            }
            this.writePropertyStart(definition);
            this.write(' { ');
            if (!definition.noGetter)
                this.write('get;');
            if (!definition.noSetter) {
                if (!definition.noGetter)
                    this.write(' ');
                this.write('set;');
            }
            this.write(' }');
            if (definition.defaultValue !== undefined) {
                this.write(` = ${definition.defaultValue};`);
            }
            this.writeEndOfLine();
            return this;
        }
        writePropertyBlock(data, getterContents, setterContents, options) {
            if (!data)
                return this;
            const definition = (elements.isProperty(data)) ?
                this.definitionBuilder.buildPropertyDefinition(data, options) :
                data;
            this.writePropertyStart(definition);
            this.writeEndOfLine();
            this.writeCodeBlock(() => {
                if (getterContents) {
                    this.writeLine('get');
                    this.writeCodeBlock(getterContents);
                }
                if (setterContents) {
                    this.writeLine('set');
                    this.writeCodeBlock(setterContents);
                }
            });
            return this;
        }
        writePropertyStart(definition) {
            if (definition.xmlDocSummary) {
                this.writeXmlDocSummary(definition.xmlDocSummary);
            }
            // Start a new, indented line        
            this.writeIndent();
            // Access modifier
            this.writeAccessModifier(definition);
            // Virtual
            if (definition.isVirtual) {
                this.write('virtual ');
            }
            // Type
            this.write(definition.typeName);
            if (definition.isNullable) {
                this.write('?');
            }
            // Name               
            this.write(` ${definition.name}`);
        }
        writeAccessModifier(data) {
            if (!data)
                return this;
            const accessModifier = (typeof data == 'number') ?
                DefinitionBuilder.getAccessModifierString(data) : // VisibilityKind
                data.accessModifier; // TypeDefinition
            if (!accessModifier)
                return this;
            this.write(accessModifier);
            this.writeWhiteSpace();
            return this;
        }
        getTypeName(element) {
            if (!element)
                return null;
            return this.typeNameProvider.getTypeName(element);
        }
        // #region deprecated
        /**
         * Writes a method declaration without a body.
         * @deprecated Use the writeMethodDeclaration() function instead.
         */
        writeInterfaceMethod(operation, options) {
            console.warn('writeInterfaceMethod is deprecated. Use the writeMethodDeclaration() function instead. ');
            this.writeMethodDeclaration(operation, options);
            return this;
        }
        /**
         * Writes an indented block of code, wrapped in a method declaration and opening and closing brackets.
         * @deprecated Use the writeMethodBlock() function instead.
         */
        writeClassMethodBlock(operation, contents, options) {
            console.warn('writeClassMethodBlock is deprecated. Use the writeMethodBlock() function instead. ');
            this.writeMethodBlock(operation, contents, options);
            return this;
        }
        writeXmlDocSummary(data) {
            if (elements.isNamedElement(data)) { // we have no isElement check, but this will do            
                data = DefinitionBuilder.buildXmlDocSummary(data);
            }
            if (!data)
                return this;
            const array = [];
            array.push('<summary>');
            if (typeof data == 'string') {
                // string
                array.push(data);
            }
            else {
                // string[]           
                array.push(...data);
            }
            array.push('</summary>');
            this.commentWriter.writeCommentLines(array, '/// ');
            return this;
        }
        writeXmlDocParagraph(data) {
            if (data == null)
                return this;
            let lines;
            if (typeof data == 'string') {
                lines = [data];
            }
            else
                lines = data;
            this.commentWriter.writeCommentLines(lines, '/// ');
            return this;
        }
        /**
         * Writes a paragraph of xml doc comments, each line starting with forward slashes '/// '.
         * @param lines
         * @deprecated Please use writeXmlDocParagraph instead.
         */
        writeXmlDocLines(lines) {
            console.warn('writeXmlDocLines is deprecated. Use the writeXmlDocParagraph() function instead.');
            if (lines == null)
                return this;
            this.commentWriter.writeCommentLines(lines, '/// ');
            return this;
        }
        writeDelimitedCommentParagraph(data) {
            if (typeof data == 'string') {
                this.commentWriter.writeDelimitedCommentParagraph(data);
            }
            else
                this.commentWriter.writeDelimitedCommentLines(data);
            return this;
        }
        writeDelimitedCommentLines(paragraph) {
            console.warn('writeDelimitedCommentLines is deprecated. Use the writeDelimitedCommentParagraph() function instead.');
            this.commentWriter.writeDelimitedCommentLines(paragraph);
            return this;
        }
        //#endregion Xml Docs    
        joinWrite(collection, separator, getStringFunc) {
            let isFirst = true;
            collection.forEach(c => {
                const value = getStringFunc(c);
                if (!value)
                    return;
                if (isFirst) {
                    isFirst = false;
                }
                else
                    this.write(separator);
                this.write(value);
            });
        }
        writeInherits(inherits) {
            if (!inherits || !inherits.length)
                return false;
            this.write(' : ');
            this.joinWrite(inherits, ', ', name => name);
            return true;
        }
        writeImplements(hasGeneralizations, impl) {
            if (!impl || !impl.length)
                return false;
            this.write(hasGeneralizations ? ', ' : ' : ');
            this.joinWrite(impl, ', ', name => name);
            return true;
        }
    }

    /**
     * Prefixes reserved C# keywords with a "@". This applies to:
     * - Class names
     * - Interface names
     * - Enumeration names
     * - Attribute names
     * - Operation names
     * - Operation parameter names
     */
    class CSReservedKeywordTransform extends elements.RenamingTransform {
        constructor(targets = elements.RenameTargets.all) {
            super(targets);
        }
        rename(name, target) {
            if (!isReservedKeyword(name))
                return name;
            return `@${name}`;
        }
    }

    exports.isReservedKeyword = isReservedKeyword;
    exports.CSharpTypeNameProvider = CSharpTypeNameProvider;
    exports.CSharpWriter = CSharpWriter;
    exports.CSReservedKeywordTransform = CSReservedKeywordTransform;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
