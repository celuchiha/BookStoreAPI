(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@yellicode/elements'), require('@yellicode/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@yellicode/elements', '@yellicode/core'], factory) :
    (factory((global['@yellicode/typescript'] = {}),global.elements,global.core));
}(this, (function (exports,elements,core) { 'use strict';

    /**
     * Defines options for dealing with elements that are 'optional', meaning that they have a lower bound of 0.
     */
    (function (OptionalityModifier) {
        /**
         * Don't write any modifier.
         */
        OptionalityModifier[OptionalityModifier["Ignore"] = 0] = "Ignore";
        /**
         * Write a 'null' keyword, for example 'myProperty: string | null;';
         */
        OptionalityModifier[OptionalityModifier["NullKeyword"] = 1] = "NullKeyword";
        /**
         * Write a question token, for example 'myProperty?: string;';
         */
        OptionalityModifier[OptionalityModifier["QuestionToken"] = 2] = "QuestionToken";
    })(exports.OptionalityModifier || (exports.OptionalityModifier = {}));
    (function (EnumFeatures) {
        EnumFeatures[EnumFeatures["None"] = 0] = "None";
        EnumFeatures[EnumFeatures["JsDocDescription"] = 1] = "JsDocDescription";
        EnumFeatures[EnumFeatures["Initializers"] = 2] = "Initializers";
        EnumFeatures[EnumFeatures["All"] = 3] = "All";
    })(exports.EnumFeatures || (exports.EnumFeatures = {}));
    (function (ClassFeatures) {
        ClassFeatures[ClassFeatures["None"] = 0] = "None";
        ClassFeatures[ClassFeatures["JsDocDescription"] = 1] = "JsDocDescription";
        ClassFeatures[ClassFeatures["Generalizations"] = 2] = "Generalizations";
        ClassFeatures[ClassFeatures["InterfaceRealizations"] = 4] = "InterfaceRealizations";
        ClassFeatures[ClassFeatures["All"] = 7] = "All";
    })(exports.ClassFeatures || (exports.ClassFeatures = {}));
    (function (InterfaceFeatures) {
        InterfaceFeatures[InterfaceFeatures["None"] = 0] = "None";
        InterfaceFeatures[InterfaceFeatures["JsDocDescription"] = 1] = "JsDocDescription";
        InterfaceFeatures[InterfaceFeatures["Generalizations"] = 2] = "Generalizations";
        InterfaceFeatures[InterfaceFeatures["All"] = 3] = "All";
    })(exports.InterfaceFeatures || (exports.InterfaceFeatures = {}));
    (function (PropertyFeatures) {
        PropertyFeatures[PropertyFeatures["None"] = 0] = "None";
        PropertyFeatures[PropertyFeatures["JsDocDescription"] = 1] = "JsDocDescription";
        PropertyFeatures[PropertyFeatures["AccessModifier"] = 2] = "AccessModifier";
        PropertyFeatures[PropertyFeatures["ReadonlyModifier"] = 4] = "ReadonlyModifier";
        PropertyFeatures[PropertyFeatures["OptionalModifier"] = 8] = "OptionalModifier";
        PropertyFeatures[PropertyFeatures["Initializer"] = 16] = "Initializer";
        /**
         * Writes the so-called 'definite assignment assertion modifier' for the property if the property is required.
         * There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library),
         * in which case you can use the definite assignment assertion modifiers for your properties.
         */
        PropertyFeatures[PropertyFeatures["DefiniteAssignmentAssertionModifier"] = 32] = "DefiniteAssignmentAssertionModifier";
        PropertyFeatures[PropertyFeatures["All"] = 63] = "All";
        /**
         * Include all features, except the ones that are not usable on interface properties.
         */
        PropertyFeatures[PropertyFeatures["AllInterfaceProperty"] = 13] = "AllInterfaceProperty";
    })(exports.PropertyFeatures || (exports.PropertyFeatures = {}));
    (function (FunctionFeatures) {
        FunctionFeatures[FunctionFeatures["None"] = 0] = "None";
        FunctionFeatures[FunctionFeatures["JsDocDescription"] = 1] = "JsDocDescription";
        FunctionFeatures[FunctionFeatures["AccessModifier"] = 2] = "AccessModifier";
        FunctionFeatures[FunctionFeatures["OptionalModifier"] = 4] = "OptionalModifier";
        FunctionFeatures[FunctionFeatures["All"] = 7] = "All";
    })(exports.FunctionFeatures || (exports.FunctionFeatures = {}));
    (function (ParameterFeatures) {
        ParameterFeatures[ParameterFeatures["None"] = 0] = "None";
        ParameterFeatures[ParameterFeatures["JsDocDescription"] = 1] = "JsDocDescription";
        ParameterFeatures[ParameterFeatures["OptionalModifier"] = 2] = "OptionalModifier";
        ParameterFeatures[ParameterFeatures["All"] = 3] = "All";
    })(exports.ParameterFeatures || (exports.ParameterFeatures = {}));

    class TypeScriptTypeNameProvider extends elements.DefaultTypeNameProvider {
        getTypeNameForType(type, isDataType) {
            if (!type)
                return null;
            if (isDataType) {
                if (elements.isPrimitiveBoolean(type))
                    return "boolean";
                if (elements.isPrimitiveInteger(type) || elements.isPrimitiveReal(type))
                    return "number";
                if (elements.isPrimitiveString(type))
                    return "string";
                if (elements.isPrimitiveObject(type))
                    return "any";
            }
            return super.getTypeNameForType(type, isDataType);
        }
    }

    const TYPE_BOOLEAN = 'boolean';
    const TYPE_STRING = 'string';
    const TYPE_NUMBER = 'number';
    class TypeUtility {
        static isPrimitiveType(typeName) {
            if (!typeName)
                return false;
            switch (typeName.trim()) {
                case TYPE_BOOLEAN:
                case TYPE_STRING:
                case TYPE_NUMBER:
                    return true;
                default: return false;
            }
        }
        static getPrimitiveTypeDefault(typeName) {
            if (!typeName)
                return undefined;
            switch (typeName.trim()) {
                case TYPE_BOOLEAN:
                    return 'false';
                case TYPE_STRING:
                    return `''`; // empty string
                case TYPE_NUMBER:
                    return '0';
                default: return undefined;
            }
        }
    }

    class DefinitionBuilder {
        constructor(typeNameProvider) {
            this.typeNameProvider = typeNameProvider;
        }
        buildClassDefinition(type, options) {
            if (!options)
                options = {};
            const definition = { name: type.name };
            const features = (options.features === undefined) ? exports.ClassFeatures.All : options.features;
            // Handle deprecated stuff
            if (options.prefix) {
                console.warn(`The 'prefix' option is deprecated. Use the 'export' or 'declare' option instead.`);
                if (options.prefix === 'export') {
                    options.export = true;
                }
                else if (options.prefix === 'declare') {
                    options.declare = true;
                }
            }
            // Description
            if ((features & exports.ClassFeatures.JsDocDescription) && type.ownedComments) {
                definition.description = DefinitionBuilder.buildDescription(type);
            }
            // Generalizations
            if (elements.isClassifier(type)) {
                if (features & exports.ClassFeatures.Generalizations) {
                    definition.extends = DefinitionBuilder.buildExtends(type, options.inherits);
                }
            }
            if (elements.isClass(type)) {
                // Abstract
                definition.isAbstract = type.isAbstract;
                // InterfaceRealizations
                if (features & exports.ClassFeatures.InterfaceRealizations) {
                    definition.implements = DefinitionBuilder.buildImplements(type, options.implements);
                }
            }
            // Declare
            definition.declare = options.declare;
            // Export
            if (options.export == undefined) {
                definition.export = type.visibility === elements.VisibilityKind.public || type.visibility === elements.VisibilityKind.package;
            }
            else
                definition.export = options.export;
            return definition;
        }
        buildInterfaceDefinition(type, options) {
            if (!options)
                options = {};
            const definition = { name: type.name };
            const features = (options.features === undefined) ? exports.InterfaceFeatures.All : options.features;
            // Handle deprecated stuff
            if (options.prefix) {
                console.warn(`The 'prefix' option is deprecated. Use the 'export' or 'declare' option instead.`);
                if (options.prefix === 'export') {
                    options.export = true;
                }
                else if (options.prefix === 'declare') {
                    options.declare = true;
                }
            }
            // Description
            if ((features & exports.InterfaceFeatures.JsDocDescription) && type.ownedComments) {
                definition.description = DefinitionBuilder.buildDescription(type);
            }
            // Generalizations
            if (elements.isClassifier(type)) {
                if (features & exports.InterfaceFeatures.Generalizations) {
                    definition.extends = DefinitionBuilder.buildExtends(type, options.inherits);
                }
            }
            // Declare
            definition.declare = options.declare;
            // Export
            if (options.export == undefined) {
                definition.export = type.visibility === elements.VisibilityKind.public || type.visibility === elements.VisibilityKind.package;
            }
            else
                definition.export = options.export;
            return definition;
        }
        buildEnumDefinition(type, options) {
            if (!options)
                options = {};
            const definition = { name: type.name };
            const features = (options.features === undefined) ? exports.EnumFeatures.All : options.features;
            // Handle deprecated stuff
            if (options.prefix) {
                console.warn(`The 'prefix' option is deprecated. Use the 'export' or 'declare' option instead.`);
                if (options.prefix === 'export') {
                    options.export = true;
                }
                else if (options.prefix === 'declare') {
                    options.declare = true;
                }
            }
            // Description
            if ((features & exports.EnumFeatures.JsDocDescription) && type.ownedComments) {
                definition.description = DefinitionBuilder.buildDescription(type);
            }
            // Declare
            definition.declare = options.declare;
            // Export
            if (options.export == undefined) {
                definition.export = type.visibility === elements.VisibilityKind.public || type.visibility === elements.VisibilityKind.package;
            }
            else
                definition.export = options.export;
            // Literals
            if (elements.isEnumeration(type) && type.ownedLiterals && type.ownedLiterals.length) {
                const members = [];
                const buildInitializers = !!(features & exports.EnumFeatures.Initializers);
                type.ownedLiterals.forEach(literal => {
                    const member = { name: literal.name };
                    if (features & exports.EnumFeatures.JsDocDescription) {
                        member.description = DefinitionBuilder.buildDescription(literal);
                    }
                    if (buildInitializers && literal.specification) {
                        const specification = literal.specification;
                        member.value = elements.isLiteralInteger(specification)
                            ? specification.value
                            : specification.getStringValue();
                    }
                    members.push(member);
                });
                definition.members = members;
            }
            return definition;
        }
        buildFunctionDefinition(op, options) {
            if (!options)
                options = {};
            const definition = { name: op.name };
            const features = (options.features === undefined) ? exports.FunctionFeatures.All : options.features;
            const paramFeatures = (options.parameterFeatures === undefined) ? exports.ParameterFeatures.All : options.parameterFeatures;
            const paramOptionality = (options.parameterOptionality === undefined) ? exports.OptionalityModifier.NullKeyword : options.parameterOptionality;
            const isOwnedByInterface = elements.isInterface(op.owner);
            // Description
            if ((features & exports.FunctionFeatures.JsDocDescription) && op.ownedComments) {
                definition.description = DefinitionBuilder.buildDescription(op);
            }
            // Access modifier
            if ((features & exports.PropertyFeatures.AccessModifier) && !isOwnedByInterface) {
                definition.accessModifier = DefinitionBuilder.getAccessModifierString(op.visibility);
            }
            definition.isAbstract = !isOwnedByInterface && op.isAbstract && !op.isConstructor;
            definition.isStatic = op.isStatic;
            // Return type 
            const returnParameter = op.getReturnParameter();
            if (returnParameter) {
                const makeOptional = returnParameter.isOptional() ? !!(features & exports.FunctionFeatures.OptionalModifier) : false;
                definition.returnTypeName = this.getFullTypeName(returnParameter);
                definition.returnsOptional = makeOptional;
            }
            // Input Parameters
            const parameters = [];
            op.ownedParameters.forEach(p => {
                const paramDefinition = this.buildParameterDefinition(p, paramFeatures, paramOptionality);
                paramDefinition.isReturn = p.direction === elements.ParameterDirectionKind.return;
                parameters.push(paramDefinition);
            });
            definition.parameters = parameters;
            return definition;
        }
        buildParameterDefinition(p, features, optionalityModifier) {
            const tsTypeName = this.getFullTypeName(p, 'any');
            const definition = { name: p.name, typeName: tsTypeName };
            const makeOptional = p.isOptional() && !!(features & exports.ParameterFeatures.OptionalModifier);
            // Description
            if ((features & exports.ParameterFeatures.JsDocDescription) && p.ownedComments) {
                definition.description = DefinitionBuilder.buildDescription(p);
            }
            // Type
            definition.typeName = tsTypeName;
            // Optionality
            definition.isOptional = makeOptional;
            definition.useQuestionToken = makeOptional && !!(optionalityModifier & exports.OptionalityModifier.QuestionToken);
            return definition;
        }
        buildPropertyDefinition(property, options) {
            if (!options)
                options = {};
            const tsTypeName = this.getFullTypeName(property, 'any');
            const definition = { name: property.name, typeName: tsTypeName };
            const isOwnedByInterface = elements.isInterface(property.owner);
            const features = (options.features === undefined)
                ? (isOwnedByInterface ? exports.PropertyFeatures.AllInterfaceProperty : exports.PropertyFeatures.All)
                : options.features;
            const isOptional = property.isOptional() && !!(features & exports.PropertyFeatures.OptionalModifier);
            const optionalityModifier = (options.optionality === undefined) ? exports.OptionalityModifier.QuestionToken : options.optionality;
            const defaultValueString = ((features & exports.PropertyFeatures.Initializer) && !isOwnedByInterface) ?
                DefinitionBuilder.getDefaultValueString(property, tsTypeName, property.defaultValue, isOptional, optionalityModifier, options.initializePrimitiveType, options.initializeArray)
                : undefined;
            // Description
            if ((features & exports.PropertyFeatures.JsDocDescription) && property.ownedComments) {
                definition.description = DefinitionBuilder.buildDescription(property);
            }
            // Access modifier
            if ((features & exports.PropertyFeatures.AccessModifier) && !isOwnedByInterface) {
                definition.accessModifier = DefinitionBuilder.getAccessModifierString(property.visibility);
            }
            // Readonly modifier
            if ((features & exports.PropertyFeatures.ReadonlyModifier) && property.isReadOnly || property.isDerived) {
                definition.isReadonly = true;
            }
            // isStatic
            definition.isStatic = property.isStatic;
            // Optionality
            definition.isOptional = isOptional;
            if (isOptional && !!(optionalityModifier & exports.OptionalityModifier.NullKeyword)) {
                definition.hasNullUnionType = true;
            }
            // Use the definite definite assignment assertion modifier if the property is required and is not initialized        
            if (!isOptional && !defaultValueString && !isOwnedByInterface && !!(features & exports.PropertyFeatures.DefiniteAssignmentAssertionModifier)) {
                definition.useDefiniteAssignmentAssertionModifier = true;
            }
            // Default value
            definition.defaultValue = defaultValueString;
            return definition;
        }
        static buildImplements(cls, additional) {
            const allNames = [];
            if (cls.interfaceRealizations) {
                allNames.push(...cls.interfaceRealizations.map(ir => ir.contract.name));
            }
            if (additional) {
                allNames.push(...additional);
            }
            return allNames;
        }
        static buildExtends(type, additional) {
            const allNames = [];
            if (type.generalizations) {
                allNames.push(...type.generalizations.map(g => g.general.name));
            }
            if (additional) {
                allNames.push(...additional);
            }
            return allNames;
        }
        static buildDescription(type) {
            return type.ownedComments.map(c => c.body);
        }
        static getDefaultValueString(element, tsTypeName, defaultValue, isOptional, optionalityModifier, initializePrimitiveType, initializeArray) {
            const isPrimitive = TypeUtility.isPrimitiveType(tsTypeName);
            const valueIfOptional = optionalityModifier == exports.OptionalityModifier.NullKeyword ? 'null' : undefined;
            if (element.isMultivalued()) {
                // The element is an array (of a complex type or a primitive)
                if (initializeArray) {
                    return isOptional ? valueIfOptional : '[]';
                }
                else
                    return undefined;
            }
            else if (isPrimitive) {
                if (defaultValue) {
                    // The type is a primitive having a default value in the model
                    return elements.isLiteralString(defaultValue) ? `'${defaultValue.value}'` : defaultValue.getStringValue();
                }
                else if (initializePrimitiveType) {
                    // The type is a primitive having no default value in the model
                    if (isOptional) {
                        return valueIfOptional;
                    }
                    // A required primitive element without default
                    else
                        return TypeUtility.getPrimitiveTypeDefault(tsTypeName);
                }
            }
            else {
                // The element is not a primitive and no array, so it is a complex type.
                // If optionalityModifier is NullKeyword, use it.
                if (isOptional && optionalityModifier == exports.OptionalityModifier.NullKeyword) {
                    return valueIfOptional;
                }
            }
            return undefined;
        }
        getFullTypeName(typedElement, fallback) {
            const typeName = this.typeNameProvider.getTypeName(typedElement) || fallback;
            if (!typeName)
                return; // no type name and no fallback
            if (elements.isMultiplicityElement(typedElement) && typedElement.isMultivalued()) {
                return `${typeName}[]`;
            }
            else
                return typeName;
        }
        static getAccessModifierString(visibility) {
            switch (visibility) {
                case elements.VisibilityKind.public:
                    return 'public';
                case elements.VisibilityKind.private:
                    return 'private';
                case elements.VisibilityKind.protected:
                    return 'protected';
                default:
                    return undefined;
            }
        }
    }

    /**
     * Provides code writing functionality specific for TypeScript.
     */
    class TypeScriptWriter extends core.CodeWriter {
        constructor(writer, options) {
            super(writer);
            if (!options)
                options = {};
            this.typeNameProvider = options.typeNameProvider || new TypeScriptTypeNameProvider();
            this.definitionBuilder = new DefinitionBuilder(this.typeNameProvider);
            this.maxCommentWidth = options.maxCommentWidth || 100;
        }
        /**
         * Writes a block of code wrapped in a #region block.
         */
        writeRegionBlock(name, contents) {
            this.writeLine(`//#region ${name}`);
            contents(this);
            this.writeLine(`//#endregion ${name}`);
            return this;
        }
        writeImports(moduleName, x) {
            if (!moduleName)
                return this;
            // Ensure forward slashes in the module name
            moduleName = moduleName.replace(/\\/g, "/");
            if (x instanceof Array) {
                if (x.length === 0)
                    return this;
                this.writeLine(`import { ${x.join(', ')} } from '${moduleName}';`);
                return this;
            }
            // x is the alias
            if (!x) {
                x = TypeScriptWriter.makeSafeModuleName(moduleName);
            }
            this.writeLine(`import * as ${x} from '${moduleName}';`);
            return this;
        }
        /**
        * Writes an indented block of decorator code, wrapped in opening and closing brackets.
        * @param contents A callback function that writes the contents.
        */
        writeDecoratorCodeBlock(decoratorName, contents) {
            this.writeLine(`@${decoratorName}({`);
            this.increaseIndent();
            if (contents)
                contents(this);
            this.decreaseIndent();
            this.writeLine('})');
            return this;
        }
        /**
        * Writes an indented block of code, wrapped in opening and closing brackets.
        * @param contents A callback function that writes the contents.
        */
        writeCodeBlock(contents) {
            this.writeLine('{');
            this.increaseIndent();
            if (contents)
                contents(this);
            this.decreaseIndent();
            this.writeLine('}');
            return this;
        }
        ;
        writeClassBlock(cls, contents, options) {
            if (!cls)
                return this;
            let definition;
            if (elements.isType(cls)) {
                definition = this.definitionBuilder.buildClassDefinition(cls, options);
            }
            else
                definition = cls;
            if (definition.description) {
                this.writeJsDocLines(definition.description);
            }
            this.writeIndent();
            if (definition.export) {
                this.write(`export `);
            }
            if (definition.declare) {
                this.write('declare ');
            }
            if (definition.isAbstract) {
                this.write('abstract ');
            }
            this.write(`class ${definition.name}`);
            if (definition.extends) {
                this.writeExtends(definition.extends);
            }
            if (definition.implements) {
                this.writeImplements(definition.implements);
            }
            // Write the contents
            this.writeEndOfLine(' {');
            this.increaseIndent();
            if (contents)
                contents(this);
            this.decreaseIndent();
            this.writeLine('}');
            return this;
        }
        writeInterfaceBlock(iface, contents, options) {
            if (!iface)
                return this;
            let definition;
            if (elements.isType(iface)) {
                definition = this.definitionBuilder.buildInterfaceDefinition(iface, options);
            }
            else
                definition = iface;
            if (definition.description) {
                this.writeJsDocLines(definition.description);
            }
            this.writeIndent();
            if (definition.export) {
                this.write(`export `);
            }
            if (definition.declare) {
                this.write('declare ');
            }
            this.write(`interface ${definition.name}`);
            if (definition.extends) {
                this.writeExtends(definition.extends);
            }
            // Write the contents
            this.writeEndOfLine(' {');
            this.increaseIndent();
            if (contents)
                contents(this);
            this.decreaseIndent();
            this.writeLine('}');
            return this;
        }
        writeProperty(property, options) {
            if (!property)
                return this;
            let definition;
            if (elements.isProperty(property)) {
                definition = this.definitionBuilder.buildPropertyDefinition(property, options);
            }
            else
                definition = property;
            const hasDefaultValue = definition.defaultValue != null; // '!= null' to allow for empty strings
            // Description
            if (definition.description) {
                this.writeJsDocLines(definition.description);
            }
            // Start a new, indented line        
            this.writeIndent();
            // Access modifier 
            if (definition.accessModifier) {
                this.write(`${definition.accessModifier} `);
            }
            // Static modifier        
            if (definition.isStatic) {
                this.write('static ');
            }
            // Readonly modifier
            if (definition.isReadonly) {
                this.write('readonly ');
            }
            // Name
            this.write(property.name);
            if (definition.isOptional && !definition.hasNullUnionType) {
                this.write('?');
            }
            if (!hasDefaultValue && !definition.isOptional && definition.useDefiniteAssignmentAssertionModifier) {
                this.write('!');
            }
            // Type
            this.write(`: ${definition.typeName}`);
            if (definition.isOptional && definition.hasNullUnionType) {
                this.write(' | null');
            }
            // Initializer
            if (hasDefaultValue) {
                this.write(` = ${definition.defaultValue}`);
            }
            this.writeEndOfLine(';');
            return this;
        }
        writeEnumeration(enumeration, options) {
            if (!enumeration)
                return this;
            let definition;
            if (elements.isType(enumeration)) {
                definition = this.definitionBuilder.buildEnumDefinition(enumeration, options);
            }
            else
                definition = enumeration;
            if (definition.description) {
                this.writeJsDocLines(definition.description);
            }
            this.writeIndent();
            if (definition.export) {
                this.write(`export `);
            }
            if (definition.declare) {
                this.write('declare ');
            }
            this.write(`enum ${enumeration.name}`);
            this.writeEndOfLine(' {');
            this.increaseIndent();
            if (!definition.members)
                return this;
            for (let i = 0, len = definition.members.length; i < len; i++) {
                const member = definition.members[i];
                if (member.description) {
                    this.writeJsDocLines(member.description);
                }
                this.writeIndent();
                this.write(member.name);
                if (member.value || member.value === 0) {
                    const initialValue = (typeof member.value === "number") ?
                        member.value.toString() : `'${member.value}'`; // a string enum: wrap in quotes
                    this.write(` = ${initialValue}`);
                }
                if (i < len - 1) {
                    this.write(',');
                }
                this.writeEndOfLine();
            }
            this.decreaseIndent();
            this.writeLine('}');
            return this;
        }
        /**
         * Writes a string literal type from a specified enumeration. Example: 'type Easing = 'ease-in' | 'ease-out' | 'ease-in-out';'
         * @param enumeration The enumeration.
         * @param prefix An optional prefix, such as 'export'.
         */
        writeStringLiteralType(enumeration, options) {
            if (!enumeration)
                return this;
            if (!options)
                options = {};
            this.writeJsDocDescription(enumeration.ownedComments);
            this.writeIndent();
            if (options.export) {
                this.write(`export `);
            }
            if (options.declare) {
                this.write('declare ');
            }
            this.write(`type ${enumeration.name} = `);
            this.joinWrite(enumeration.ownedLiterals, ' | ', lit => `'${lit.name}'`);
            this.writeEndOfLine(';');
            return this;
        }
        writeFunctionDeclaration(func, options) {
            if (!func)
                return this;
            let definition;
            if (elements.isOperation(func)) {
                definition = this.definitionBuilder.buildFunctionDefinition(func, options);
            }
            else
                definition = func;
            this.writeFunctionStart(definition);
            this.writeEndOfLine(';');
            return this;
        }
        writeFunctionBlock(func, contents, options) {
            if (!func)
                return this;
            let definition;
            if (elements.isOperation(func)) {
                definition = this.definitionBuilder.buildFunctionDefinition(func, options);
            }
            else
                definition = func;
            this.writeFunctionStart(definition);
            if (definition.isAbstract) {
                this.writeEndOfLine(';');
                return this;
            }
            this.writeEndOfLine();
            this.writeCodeBlock((writer) => { contents(writer, func); });
            return this;
        }
        getTypeName(element) {
            if (!element)
                return null;
            if (elements.isTypedElement(element)) {
                return this.typeNameProvider ? this.typeNameProvider.getTypeName(element) : element.getTypeName();
            }
            else if (elements.isType(element)) {
                return this.typeNameProvider ? this.typeNameProvider.getTypeName(element) : element.name;
            }
            return null;
        }
        writeFunctionStart(definition) {
            // jsDoc tags 
            var jsDocLines = [];
            if (definition.description) {
                jsDocLines.push(...definition.description);
            }
            if (definition.parameters) {
                this.pushJsDocLinesForParameters(definition.parameters, jsDocLines);
            }
            this.writeJsDocLines(jsDocLines);
            // TODO: export, declare?!
            // if (definition.export) {
            //     this.write(`export `);
            // }
            // if (definition.declare) {
            //     this.write('declare ');
            // }
            // Start a new, indented line
            this.writeIndent();
            // Access modifier 
            if (definition.accessModifier) {
                this.write(`${definition.accessModifier} `);
            }
            // Static modifier                
            if (definition.isStatic) {
                this.write('static ');
            }
            else if (definition.isAbstract) {
                this.write('abstract ');
            }
            this.write(definition.name);
            // If needed, make the function optional using the '?'         
            // if (definition.isOptional) {
            //     this.write('?');
            // }
            this.write('(');
            if (definition.parameters) {
                this.writeInOutParameters(definition.parameters);
            }
            this.write('): ');
            // Write the return type                
            this.write(definition.returnTypeName || 'void');
            if (definition.returnsOptional) {
                this.write(' | null');
            }
        }
        writeInOutParameters(parameters) {
            let i = 0;
            parameters.forEach((p) => {
                if (p.isReturn)
                    return;
                if (i > 0) {
                    this.write(', ');
                }
                this.write(p.name);
                if (p.isOptional && (p.useQuestionToken)) {
                    this.write('?');
                }
                this.write(`: ${p.typeName}`);
                if (p.isOptional && !p.useQuestionToken) {
                    this.write(' | null');
                }
                i++;
            });
        }
        writeExtends(ext) {
            if (ext.length === 0)
                return;
            this.write(' extends ');
            this.joinWrite(ext, ', ', name => name);
        }
        writeImplements(impl) {
            if (impl.length === 0)
                return;
            this.write(' implements ');
            this.joinWrite(impl, ', ', name => name);
        }
        pushJsDocLinesFromComments(comments, lines) {
            if (!comments)
                return;
            let i = 0;
            comments.forEach((p) => {
                if (!p.body) {
                    return;
                }
                if (i > 0) {
                    lines.push(''); // add a blank line
                }
                lines.push(p.body);
                i++;
            });
        }
        pushJsDocLinesForParameters(parameters, lines) {
            if (!parameters)
                return;
            parameters.forEach((p) => {
                lines.push(this.getJsDocLineForParameter(p));
            });
        }
        getJsDocLineForParameter(parameter) {
            const tag = parameter.isReturn ? 'returns' : 'param';
            let line = `@${tag} {${parameter.typeName}}`;
            if (!parameter.isReturn) {
                line = `${line} ${parameter.name}`;
            }
            if (parameter.description && parameter.description.length > 0) {
                line = `${line} ${parameter.description.join(' ')}`;
            }
            return line;
        }
        writeJsDocDescription(data) {
            const lines = [];
            if (typeof data == 'string') {
                lines.push(data);
            }
            else {
                this.pushJsDocLinesFromComments(data, lines);
            }
            this.writeJsDocLines(lines);
            return this;
        }
        writeJsDocParagraph(text) {
            this.writeJsDocLines([text]);
            return this;
        }
        writeJsDocLines(lines) {
            if (lines.length === 0)
                return this;
            this.writeLine('/**');
            // Split here
            lines.forEach(line => {
                const lineLength = line ? line.length : 0;
                if (this.maxCommentWidth > 0 && lineLength > this.maxCommentWidth) {
                    // See if we can split the line
                    var split = core.CodeWriterUtility.wordWrap(line, this.maxCommentWidth);
                    split.forEach(s => {
                        this.writeLine(`* ${s}`);
                    });
                }
                else
                    this.writeLine(`* ${line}`);
            });
            this.writeLine('*/');
            return this;
        }
        joinWrite(collection, separator, getStringFunc) {
            let isFirst = true;
            collection.forEach(c => {
                const value = getStringFunc(c);
                if (!value)
                    return;
                if (isFirst) {
                    isFirst = false;
                }
                else
                    this.write(separator);
                this.write(value);
            });
        }
        /**
         * Makes a TypeScript safe alias for a ES6 module name.
         */
        static makeSafeModuleName(moduleName) {
            if (moduleName.startsWith('@')) {
                moduleName = moduleName.substring(1);
            }
            const parts = moduleName.split('/');
            if (parts.length > 1) {
                // Make the module name lowerCamelCase, e.g. rename myScope/myModule to myScopeMyModule
                moduleName = core.NameUtility.upperToLowerCamelCase(parts[0]);
                parts.forEach((p, i) => {
                    if (i > 0) {
                        moduleName += core.NameUtility.lowerToUpperCamelCase(p);
                    }
                });
            }
            return moduleName;
        }
    }

    exports.TypeScriptTypeNameProvider = TypeScriptTypeNameProvider;
    exports.TypeScriptWriter = TypeScriptWriter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
