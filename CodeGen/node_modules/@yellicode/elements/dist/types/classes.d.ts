/**
* This code was generated by a tool.
*
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from './interfaces';
import { ModelDelegate } from './model-delegate-interface';
export declare abstract class Element implements elements.Element {
    protected modelDelegate: ModelDelegate;
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    abstract readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    id: string;
    ownedComments: elements.Comment[];
    readonly owner: elements.Element | null;
    taggedValues: elements.TaggedValueSpecification[];
    /**
    * Gets the text contents of the first comment in the element's owned comments, or an empty string if
    * the element has no comments.
    * @returns {string} The body string of the first comment. If the element has no comments, an empty
    * string is returned.
    */
    getFirstCommentBody(): string;
}
export declare class TaggedValueSpecification implements elements.TaggedValueSpecification {
    definition: elements.Property;
    specification: elements.ValueSpecification;
}
export declare class StereotypeExtension implements elements.StereotypeExtension {
    isRequired: boolean;
    metaClass: elements.ElementType;
}
export declare class Class extends Element implements elements.Class {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    generalizations: elements.Generalization[];
    interfaceRealizations: elements.InterfaceRealization[];
    isAbstract: boolean;
    isActive: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    name: string;
    ownedAttributes: elements.Property[];
    ownedOperations: elements.Operation[];
    readonly package: elements.Package;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes(): elements.Property[];
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations(): elements.Operation[];
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
    /**
    * Gets the superclasses of a Class, derived from its Generalizations.
    * @returns {elements.Class[]}
    */
    getSuperClasses(): elements.Class[];
}
export declare class Stereotype extends Element implements elements.Stereotype {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    extends: elements.StereotypeExtension[];
    generalizations: elements.Generalization[];
    interfaceRealizations: elements.InterfaceRealization[];
    isAbstract: boolean;
    isActive: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    name: string;
    ownedAttributes: elements.Property[];
    ownedOperations: elements.Operation[];
    readonly package: elements.Package;
    safeName: string;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes(): elements.Property[];
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations(): elements.Operation[];
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
    /**
    * Gets the superclasses of a Class, derived from its Generalizations.
    * @returns {elements.Class[]}
    */
    getSuperClasses(): elements.Class[];
}
export declare class Property extends Element implements elements.Property {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    aggregation: elements.AggregationKind;
    appliedStereotypes: elements.Stereotype[];
    readonly association: elements.Association | null;
    defaultValue: elements.ValueSpecification | null;
    isDerived: boolean;
    isDerivedUnion: boolean;
    isID: boolean;
    isLeaf: boolean;
    isNavigable: boolean;
    isOrdered: boolean;
    isReadOnly: boolean;
    isStatic: boolean;
    isUnique: boolean;
    readonly lower: number | null;
    lowerValue: elements.ValueSpecification | null;
    name: string;
    order: number;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    readonly upper: elements.UnlimitedNatural | null;
    upperValue: elements.ValueSpecification | null;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the value of the DefaultValue property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    getDefault(): any | null;
    /**
    * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise.
    * @returns {number}
    */
    getLowerBound(): number;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
    * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * @returns {elements.UnlimitedNatural}
    */
    getUpperBound(): elements.UnlimitedNatural;
    /**
    * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
    * @returns {boolean}
    */
    isMultivalued(): boolean;
    /**
    * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    isOptional(): boolean;
    /**
    * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
    * upper bound of 1 (0..1).
    * @returns {boolean}
    */
    isOptionalAndSinglevalued(): boolean;
    /**
    * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
    * upper bound of 1 (1..1).
    * @returns {boolean}
    */
    isRequiredAndSinglevalued(): boolean;
}
export declare class Package extends Element implements elements.Package {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedProfiles: elements.Profile[];
    appliedStereotypes: elements.Stereotype[];
    isNamespaceRoot: boolean;
    name: string;
    readonly package: elements.Package;
    packagedElements: elements.PackageableElement[];
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    getAllClasses(): elements.Class[];
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    getAllDataTypes(): elements.DataType[];
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    getAllEnumerations(): elements.Enumeration[];
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    getAllInterfaces(): elements.Interface[];
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getAllTypes(): elements.Classifier[];
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    getClasses(): elements.Class[];
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    getDataTypes(): elements.DataType[];
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    getEnumerations(): elements.Enumeration[];
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    getInterfaces(): elements.Interface[];
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    getNestedPackages(): elements.Package[];
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getTypes(): elements.Classifier[];
}
export declare class Profile extends Element implements elements.Profile {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedProfiles: elements.Profile[];
    appliedStereotypes: elements.Stereotype[];
    isNamespaceRoot: boolean;
    name: string;
    readonly package: elements.Package;
    packagedElements: elements.PackageableElement[];
    safeName: string;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    getAllClasses(): elements.Class[];
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    getAllDataTypes(): elements.DataType[];
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    getAllEnumerations(): elements.Enumeration[];
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    getAllInterfaces(): elements.Interface[];
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getAllTypes(): elements.Classifier[];
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    getClasses(): elements.Class[];
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    getDataTypes(): elements.DataType[];
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    getEnumerations(): elements.Enumeration[];
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    getInterfaces(): elements.Interface[];
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    getNestedPackages(): elements.Package[];
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getTypes(): elements.Classifier[];
}
export declare class DataType extends Element implements elements.DataType {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    generalizations: elements.Generalization[];
    isAbstract: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    name: string;
    ownedAttributes: elements.Property[];
    ownedOperations: elements.Operation[];
    readonly package: elements.Package;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes(): elements.Property[];
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations(): elements.Operation[];
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
}
export declare class PrimitiveType extends Element implements elements.PrimitiveType {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    generalizations: elements.Generalization[];
    isAbstract: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    name: string;
    ownedAttributes: elements.Property[];
    ownedOperations: elements.Operation[];
    readonly package: elements.Package;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes(): elements.Property[];
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations(): elements.Operation[];
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
}
export declare class Parameter extends Element implements elements.Parameter {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    defaultValue: elements.ValueSpecification | null;
    direction: elements.ParameterDirectionKind;
    isException: boolean;
    isOrdered: boolean;
    isStream: boolean;
    isUnique: boolean;
    readonly lower: number | null;
    lowerValue: elements.ValueSpecification | null;
    name: string;
    order: number;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    readonly upper: elements.UnlimitedNatural | null;
    upperValue: elements.ValueSpecification | null;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the value of the DefaultValue property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    getDefault(): any | null;
    /**
    * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise.
    * @returns {number}
    */
    getLowerBound(): number;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
    * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * @returns {elements.UnlimitedNatural}
    */
    getUpperBound(): elements.UnlimitedNatural;
    /**
    * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
    * @returns {boolean}
    */
    isMultivalued(): boolean;
    /**
    * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    isOptional(): boolean;
    /**
    * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
    * upper bound of 1 (0..1).
    * @returns {boolean}
    */
    isOptionalAndSinglevalued(): boolean;
    /**
    * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
    * upper bound of 1 (1..1).
    * @returns {boolean}
    */
    isRequiredAndSinglevalued(): boolean;
}
export declare class Operation extends Element implements elements.Operation {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    isAbstract: boolean;
    isConstructor: boolean;
    isLeaf: boolean;
    isQuery: boolean;
    isStatic: boolean;
    readonly lower: number | null;
    name: string;
    order: number;
    ownedParameters: elements.Parameter[];
    taggedValues: elements.TaggedValueSpecification[];
    readonly upper: elements.UnlimitedNatural | null;
    visibility: elements.VisibilityKind | null;
    /**
    * Returns the ownedParameters with direction in and inout.
    * @returns {elements.Parameter[]}
    */
    getInputParameters(): elements.Parameter[];
    /**
    * The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
    * return result for this Operation.
    * @returns {number}
    */
    getLowerBound(): number;
    /**
    * Returns the ownedParameters with direction out, inout, or return.
    * @returns {elements.Parameter[]}
    */
    getOutputParameters(): elements.Parameter[];
    /**
    * Gets the operation's return parameter, if it has one.
    * @returns {elements.Parameter}
    */
    getReturnParameter(): elements.Parameter | null;
    /**
    * Gets the type of the operation's return parameter, if it has any.
    * @returns {elements.Type}
    */
    getReturnType(): elements.Type | null;
    /**
    * The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
    * an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * This information is derived from the return result for this Operation.
    * @returns {elements.UnlimitedNatural}
    */
    getUpperBound(): elements.UnlimitedNatural;
    /**
    * The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
    * @returns {boolean}
    */
    isMultivalued(): boolean;
    /**
    * The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    isOptional(): boolean;
    /**
    * The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
    * 1 (0..1).
    * @returns {boolean}
    */
    isOptionalAndSinglevalued(): boolean;
}
export declare class Model extends Element implements elements.Model {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedProfiles: elements.Profile[];
    appliedStereotypes: elements.Stereotype[];
    isNamespaceRoot: boolean;
    name: string;
    readonly package: elements.Package;
    packagedElements: elements.PackageableElement[];
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    getAllClasses(): elements.Class[];
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    getAllDataTypes(): elements.DataType[];
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    getAllEnumerations(): elements.Enumeration[];
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    getAllInterfaces(): elements.Interface[];
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getAllTypes(): elements.Classifier[];
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    getClasses(): elements.Class[];
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    getDataTypes(): elements.DataType[];
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    getEnumerations(): elements.Enumeration[];
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    getInterfaces(): elements.Interface[];
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    getNestedPackages(): elements.Package[];
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getTypes(): elements.Classifier[];
}
export declare class LiteralUnlimitedNatural extends Element implements elements.LiteralUnlimitedNatural {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    name: string;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    value: elements.UnlimitedNatural;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue(): string;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue(): any | null;
}
export declare class LiteralString extends Element implements elements.LiteralString {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    name: string;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    value: string;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue(): string;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue(): any | null;
}
export declare class LiteralReal extends Element implements elements.LiteralReal {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    name: string;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    value: number;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue(): string;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue(): any | null;
}
export declare class LiteralNull extends Element implements elements.LiteralNull {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    name: string;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue(): string;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue(): any | null;
}
export declare class LiteralInteger extends Element implements elements.LiteralInteger {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    name: string;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    value: number;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue(): string;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue(): any | null;
}
export declare class LiteralBoolean extends Element implements elements.LiteralBoolean {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    name: string;
    taggedValues: elements.TaggedValueSpecification[];
    type: elements.Type | null;
    value: boolean;
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue(): string;
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName(): string;
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue(): any | null;
}
export declare class InterfaceRealization extends Element implements elements.InterfaceRealization {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    contract: elements.Interface;
    taggedValues: elements.TaggedValueSpecification[];
}
export declare class Interface extends Element implements elements.Interface {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    generalizations: elements.Generalization[];
    isAbstract: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    name: string;
    ownedAttributes: elements.Property[];
    ownedOperations: elements.Operation[];
    readonly package: elements.Package;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes(): elements.Property[];
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations(): elements.Operation[];
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
}
export declare class Generalization extends Element implements elements.Generalization {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    general: elements.Classifier;
    isSubstitutable: boolean;
    readonly specific: elements.Classifier;
    taggedValues: elements.TaggedValueSpecification[];
}
export declare class EnumerationLiteral extends Element implements elements.EnumerationLiteral {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    readonly enumeration: elements.Enumeration;
    name: string;
    order: number;
    specification: elements.ValueSpecification;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Gets the value of the Specification property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    getSpecificationValue(): any | null;
}
export declare class Enumeration extends Element implements elements.Enumeration {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    baseType: elements.Type | null;
    generalizations: elements.Generalization[];
    isAbstract: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    name: string;
    ownedAttributes: elements.Property[];
    ownedLiterals: elements.EnumerationLiteral[];
    ownedOperations: elements.Operation[];
    readonly package: elements.Package;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes(): elements.Property[];
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations(): elements.Operation[];
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
}
export declare class DocumentReference implements elements.DocumentReference {
    location: elements.DocumentLocationKind;
    name: string;
    path: string;
}
export declare class Comment extends Element implements elements.Comment {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    body: string;
    taggedValues: elements.TaggedValueSpecification[];
}
export declare class Association extends Element implements elements.Association {
    constructor(modelDelegate: ModelDelegate, owner: elements.Element | null);
    readonly elementType: elements.ElementType;
    appliedStereotypes: elements.Stereotype[];
    generalizations: elements.Generalization[];
    isAbstract: boolean;
    isFinalSpecialization: boolean;
    isInferred: boolean;
    isLeaf: boolean;
    memberEnds: elements.Property[];
    name: string;
    ownedEnds: elements.Property[];
    readonly package: elements.Package;
    taggedValues: elements.TaggedValueSpecification[];
    visibility: elements.VisibilityKind | null;
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents(): elements.Classifier[];
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations(): elements.Classifier[];
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization(): elements.Generalization | null;
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent(): elements.Classifier | null;
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator?: string): string;
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages(): elements.Package[];
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents(): elements.Classifier[];
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator?: string): string;
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations(): elements.Classifier[];
}
