/*
* Copyright (c) 2019 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* This code was generated by a tool.
*
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from './interfaces';
var Element = /** @class */ (function () {
    function Element(modelDelegate, owner) {
        this.modelDelegate = modelDelegate;
        this.appliedStereotypes = [];
        this.id = '';
        this.ownedComments = [];
        this.owner = null;
        this.taggedValues = [];
        this.owner = owner;
    }
    /**
    * Gets the text contents of the first comment in the element's owned comments, or an empty string if
    * the element has no comments.
    * @returns {string} The body string of the first comment. If the element has no comments, an empty
    * string is returned.
    */
    Element.prototype.getFirstCommentBody = function () {
        return this.modelDelegate.getFirstCommentBody(this);
    };
    return Element;
}());
export { Element };
var TaggedValueSpecification = /** @class */ (function () {
    function TaggedValueSpecification() {
    }
    return TaggedValueSpecification;
}());
export { TaggedValueSpecification };
var StereotypeExtension = /** @class */ (function () {
    function StereotypeExtension() {
        this.isRequired = false;
    }
    return StereotypeExtension;
}());
export { StereotypeExtension };
var Class = /** @class */ (function (_super) {
    __extends(Class, _super);
    function Class(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.class;
        _this.appliedStereotypes = [];
        _this.generalizations = [];
        _this.interfaceRealizations = [];
        _this.isAbstract = false;
        _this.isActive = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.name = '';
        _this.ownedAttributes = [];
        _this.ownedOperations = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Class.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    Class.prototype.getAllAttributes = function () {
        return this.modelDelegate.getAllAttributes(this);
    };
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    Class.prototype.getAllOperations = function () {
        return this.modelDelegate.getAllOperations(this);
    };
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    Class.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    Class.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    Class.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    Class.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Class.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Class.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    Class.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Class.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    Class.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    /**
    * Gets the superclasses of a Class, derived from its Generalizations.
    * @returns {elements.Class[]}
    */
    Class.prototype.getSuperClasses = function () {
        return this.modelDelegate.getSuperClasses(this);
    };
    return Class;
}(Element));
export { Class };
var Stereotype = /** @class */ (function (_super) {
    __extends(Stereotype, _super);
    function Stereotype(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.stereotype;
        _this.appliedStereotypes = [];
        _this.extends = [];
        _this.generalizations = [];
        _this.interfaceRealizations = [];
        _this.isAbstract = false;
        _this.isActive = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.name = '';
        _this.ownedAttributes = [];
        _this.ownedOperations = [];
        _this.safeName = '';
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Stereotype.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    Stereotype.prototype.getAllAttributes = function () {
        return this.modelDelegate.getAllAttributes(this);
    };
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    Stereotype.prototype.getAllOperations = function () {
        return this.modelDelegate.getAllOperations(this);
    };
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    Stereotype.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    Stereotype.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    Stereotype.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    Stereotype.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Stereotype.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Stereotype.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    Stereotype.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Stereotype.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    Stereotype.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    /**
    * Gets the superclasses of a Class, derived from its Generalizations.
    * @returns {elements.Class[]}
    */
    Stereotype.prototype.getSuperClasses = function () {
        return this.modelDelegate.getSuperClasses(this);
    };
    return Stereotype;
}(Element));
export { Stereotype };
var Property = /** @class */ (function (_super) {
    __extends(Property, _super);
    function Property(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.property;
        _this.aggregation = elements.AggregationKind.none;
        _this.appliedStereotypes = [];
        _this.defaultValue = null;
        _this.isDerived = false;
        _this.isDerivedUnion = false;
        _this.isID = false;
        _this.isLeaf = false;
        _this.isNavigable = false;
        _this.isOrdered = false;
        _this.isReadOnly = false;
        _this.isStatic = false;
        _this.isUnique = false;
        _this.lowerValue = null;
        _this.name = '';
        _this.order = 0;
        _this.taggedValues = [];
        _this.type = null;
        _this.upperValue = null;
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Property.prototype, "association", {
        get: function () {
            return this.modelDelegate.getAssociation(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "lower", {
        get: function () {
            return this.modelDelegate.getLower(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "upper", {
        get: function () {
            return this.modelDelegate.getUpper(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Gets the value of the DefaultValue property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    Property.prototype.getDefault = function () {
        return this.modelDelegate.getDefault(this);
    };
    /**
    * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise.
    * @returns {number}
    */
    Property.prototype.getLowerBound = function () {
        return this.modelDelegate.getLowerBound(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    Property.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
    * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * @returns {elements.UnlimitedNatural}
    */
    Property.prototype.getUpperBound = function () {
        return this.modelDelegate.getUpperBound(this);
    };
    /**
    * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
    * @returns {boolean}
    */
    Property.prototype.isMultivalued = function () {
        return this.modelDelegate.isMultivalued(this);
    };
    /**
    * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    Property.prototype.isOptional = function () {
        return this.modelDelegate.isOptional(this);
    };
    /**
    * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
    * upper bound of 1 (0..1).
    * @returns {boolean}
    */
    Property.prototype.isOptionalAndSinglevalued = function () {
        return this.modelDelegate.isOptionalAndSinglevalued(this);
    };
    /**
    * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
    * upper bound of 1 (1..1).
    * @returns {boolean}
    */
    Property.prototype.isRequiredAndSinglevalued = function () {
        return this.modelDelegate.isRequiredAndSinglevalued(this);
    };
    return Property;
}(Element));
export { Property };
var Package = /** @class */ (function (_super) {
    __extends(Package, _super);
    function Package(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.package;
        _this.appliedProfiles = [];
        _this.appliedStereotypes = [];
        _this.isNamespaceRoot = false;
        _this.name = '';
        _this.packagedElements = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Package.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    Package.prototype.getAllClasses = function () {
        return this.modelDelegate.getAllClasses(this);
    };
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    Package.prototype.getAllDataTypes = function () {
        return this.modelDelegate.getAllDataTypes(this);
    };
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    Package.prototype.getAllEnumerations = function () {
        return this.modelDelegate.getAllEnumerations(this);
    };
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    Package.prototype.getAllInterfaces = function () {
        return this.modelDelegate.getAllInterfaces(this);
    };
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    Package.prototype.getAllTypes = function () {
        return this.modelDelegate.getAllTypes(this);
    };
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    Package.prototype.getClasses = function () {
        return this.modelDelegate.getClasses(this);
    };
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    Package.prototype.getDataTypes = function () {
        return this.modelDelegate.getDataTypes(this);
    };
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    Package.prototype.getEnumerations = function () {
        return this.modelDelegate.getEnumerations(this);
    };
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    Package.prototype.getInterfaces = function () {
        return this.modelDelegate.getInterfaces(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Package.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    Package.prototype.getNestedPackages = function () {
        return this.modelDelegate.getNestedPackages(this);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Package.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Package.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    Package.prototype.getTypes = function () {
        return this.modelDelegate.getTypes(this);
    };
    return Package;
}(Element));
export { Package };
var Profile = /** @class */ (function (_super) {
    __extends(Profile, _super);
    function Profile(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.profile;
        _this.appliedProfiles = [];
        _this.appliedStereotypes = [];
        _this.isNamespaceRoot = false;
        _this.name = '';
        _this.packagedElements = [];
        _this.safeName = '';
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Profile.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    Profile.prototype.getAllClasses = function () {
        return this.modelDelegate.getAllClasses(this);
    };
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    Profile.prototype.getAllDataTypes = function () {
        return this.modelDelegate.getAllDataTypes(this);
    };
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    Profile.prototype.getAllEnumerations = function () {
        return this.modelDelegate.getAllEnumerations(this);
    };
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    Profile.prototype.getAllInterfaces = function () {
        return this.modelDelegate.getAllInterfaces(this);
    };
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    Profile.prototype.getAllTypes = function () {
        return this.modelDelegate.getAllTypes(this);
    };
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    Profile.prototype.getClasses = function () {
        return this.modelDelegate.getClasses(this);
    };
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    Profile.prototype.getDataTypes = function () {
        return this.modelDelegate.getDataTypes(this);
    };
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    Profile.prototype.getEnumerations = function () {
        return this.modelDelegate.getEnumerations(this);
    };
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    Profile.prototype.getInterfaces = function () {
        return this.modelDelegate.getInterfaces(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Profile.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    Profile.prototype.getNestedPackages = function () {
        return this.modelDelegate.getNestedPackages(this);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Profile.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Profile.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    Profile.prototype.getTypes = function () {
        return this.modelDelegate.getTypes(this);
    };
    return Profile;
}(Element));
export { Profile };
var DataType = /** @class */ (function (_super) {
    __extends(DataType, _super);
    function DataType(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.dataType;
        _this.appliedStereotypes = [];
        _this.generalizations = [];
        _this.isAbstract = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.name = '';
        _this.ownedAttributes = [];
        _this.ownedOperations = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(DataType.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    DataType.prototype.getAllAttributes = function () {
        return this.modelDelegate.getAllAttributes(this);
    };
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    DataType.prototype.getAllOperations = function () {
        return this.modelDelegate.getAllOperations(this);
    };
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    DataType.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    DataType.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    DataType.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    DataType.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    DataType.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    DataType.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    DataType.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    DataType.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    DataType.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    return DataType;
}(Element));
export { DataType };
var PrimitiveType = /** @class */ (function (_super) {
    __extends(PrimitiveType, _super);
    function PrimitiveType(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.primitiveType;
        _this.appliedStereotypes = [];
        _this.generalizations = [];
        _this.isAbstract = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.name = '';
        _this.ownedAttributes = [];
        _this.ownedOperations = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(PrimitiveType.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    PrimitiveType.prototype.getAllAttributes = function () {
        return this.modelDelegate.getAllAttributes(this);
    };
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    PrimitiveType.prototype.getAllOperations = function () {
        return this.modelDelegate.getAllOperations(this);
    };
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    PrimitiveType.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    PrimitiveType.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    PrimitiveType.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    PrimitiveType.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    PrimitiveType.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    PrimitiveType.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    PrimitiveType.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    PrimitiveType.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    PrimitiveType.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    return PrimitiveType;
}(Element));
export { PrimitiveType };
var Parameter = /** @class */ (function (_super) {
    __extends(Parameter, _super);
    function Parameter(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.parameter;
        _this.appliedStereotypes = [];
        _this.defaultValue = null;
        _this.direction = elements.ParameterDirectionKind.in;
        _this.isException = false;
        _this.isOrdered = false;
        _this.isStream = false;
        _this.isUnique = false;
        _this.lowerValue = null;
        _this.name = '';
        _this.order = 0;
        _this.taggedValues = [];
        _this.type = null;
        _this.upperValue = null;
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Parameter.prototype, "lower", {
        get: function () {
            return this.modelDelegate.getLower(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Parameter.prototype, "upper", {
        get: function () {
            return this.modelDelegate.getUpper(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Gets the value of the DefaultValue property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    Parameter.prototype.getDefault = function () {
        return this.modelDelegate.getDefault(this);
    };
    /**
    * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise.
    * @returns {number}
    */
    Parameter.prototype.getLowerBound = function () {
        return this.modelDelegate.getLowerBound(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    Parameter.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
    * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * @returns {elements.UnlimitedNatural}
    */
    Parameter.prototype.getUpperBound = function () {
        return this.modelDelegate.getUpperBound(this);
    };
    /**
    * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
    * @returns {boolean}
    */
    Parameter.prototype.isMultivalued = function () {
        return this.modelDelegate.isMultivalued(this);
    };
    /**
    * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    Parameter.prototype.isOptional = function () {
        return this.modelDelegate.isOptional(this);
    };
    /**
    * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
    * upper bound of 1 (0..1).
    * @returns {boolean}
    */
    Parameter.prototype.isOptionalAndSinglevalued = function () {
        return this.modelDelegate.isOptionalAndSinglevalued(this);
    };
    /**
    * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
    * upper bound of 1 (1..1).
    * @returns {boolean}
    */
    Parameter.prototype.isRequiredAndSinglevalued = function () {
        return this.modelDelegate.isRequiredAndSinglevalued(this);
    };
    return Parameter;
}(Element));
export { Parameter };
var Operation = /** @class */ (function (_super) {
    __extends(Operation, _super);
    function Operation(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.operation;
        _this.appliedStereotypes = [];
        _this.isAbstract = false;
        _this.isConstructor = false;
        _this.isLeaf = false;
        _this.isQuery = false;
        _this.isStatic = false;
        _this.name = '';
        _this.order = 0;
        _this.ownedParameters = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Operation.prototype, "lower", {
        get: function () {
            return this.modelDelegate.getLower(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Operation.prototype, "upper", {
        get: function () {
            return this.modelDelegate.getUpper(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns the ownedParameters with direction in and inout.
    * @returns {elements.Parameter[]}
    */
    Operation.prototype.getInputParameters = function () {
        return this.modelDelegate.getInputParameters(this);
    };
    /**
    * The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
    * return result for this Operation.
    * @returns {number}
    */
    Operation.prototype.getLowerBound = function () {
        return this.modelDelegate.getLowerBound(this);
    };
    /**
    * Returns the ownedParameters with direction out, inout, or return.
    * @returns {elements.Parameter[]}
    */
    Operation.prototype.getOutputParameters = function () {
        return this.modelDelegate.getOutputParameters(this);
    };
    /**
    * Gets the operation's return parameter, if it has one.
    * @returns {elements.Parameter}
    */
    Operation.prototype.getReturnParameter = function () {
        return this.modelDelegate.getReturnParameter(this);
    };
    /**
    * Gets the type of the operation's return parameter, if it has any.
    * @returns {elements.Type}
    */
    Operation.prototype.getReturnType = function () {
        return this.modelDelegate.getReturnType(this);
    };
    /**
    * The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
    * an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * This information is derived from the return result for this Operation.
    * @returns {elements.UnlimitedNatural}
    */
    Operation.prototype.getUpperBound = function () {
        return this.modelDelegate.getUpperBound(this);
    };
    /**
    * The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
    * @returns {boolean}
    */
    Operation.prototype.isMultivalued = function () {
        return this.modelDelegate.isMultivalued(this);
    };
    /**
    * The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    Operation.prototype.isOptional = function () {
        return this.modelDelegate.isOptional(this);
    };
    /**
    * The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
    * 1 (0..1).
    * @returns {boolean}
    */
    Operation.prototype.isOptionalAndSinglevalued = function () {
        return this.modelDelegate.isOptionalAndSinglevalued(this);
    };
    return Operation;
}(Element));
export { Operation };
var Model = /** @class */ (function (_super) {
    __extends(Model, _super);
    function Model(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.model;
        _this.appliedProfiles = [];
        _this.appliedStereotypes = [];
        _this.isNamespaceRoot = false;
        _this.name = '';
        _this.packagedElements = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Model.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    Model.prototype.getAllClasses = function () {
        return this.modelDelegate.getAllClasses(this);
    };
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    Model.prototype.getAllDataTypes = function () {
        return this.modelDelegate.getAllDataTypes(this);
    };
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    Model.prototype.getAllEnumerations = function () {
        return this.modelDelegate.getAllEnumerations(this);
    };
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    Model.prototype.getAllInterfaces = function () {
        return this.modelDelegate.getAllInterfaces(this);
    };
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    Model.prototype.getAllTypes = function () {
        return this.modelDelegate.getAllTypes(this);
    };
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    Model.prototype.getClasses = function () {
        return this.modelDelegate.getClasses(this);
    };
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    Model.prototype.getDataTypes = function () {
        return this.modelDelegate.getDataTypes(this);
    };
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    Model.prototype.getEnumerations = function () {
        return this.modelDelegate.getEnumerations(this);
    };
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    Model.prototype.getInterfaces = function () {
        return this.modelDelegate.getInterfaces(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Model.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    Model.prototype.getNestedPackages = function () {
        return this.modelDelegate.getNestedPackages(this);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Model.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Model.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    Model.prototype.getTypes = function () {
        return this.modelDelegate.getTypes(this);
    };
    return Model;
}(Element));
export { Model };
var LiteralUnlimitedNatural = /** @class */ (function (_super) {
    __extends(LiteralUnlimitedNatural, _super);
    function LiteralUnlimitedNatural(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.literalUnlimitedNatural;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.taggedValues = [];
        _this.type = null;
        _this.visibility = null;
        return _this;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    LiteralUnlimitedNatural.prototype.getStringValue = function () {
        return this.modelDelegate.getStringValue(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    LiteralUnlimitedNatural.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    LiteralUnlimitedNatural.prototype.getValue = function () {
        return this.modelDelegate.getValue(this);
    };
    return LiteralUnlimitedNatural;
}(Element));
export { LiteralUnlimitedNatural };
var LiteralString = /** @class */ (function (_super) {
    __extends(LiteralString, _super);
    function LiteralString(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.literalString;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.taggedValues = [];
        _this.type = null;
        _this.value = '';
        _this.visibility = null;
        return _this;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    LiteralString.prototype.getStringValue = function () {
        return this.modelDelegate.getStringValue(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    LiteralString.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    LiteralString.prototype.getValue = function () {
        return this.modelDelegate.getValue(this);
    };
    return LiteralString;
}(Element));
export { LiteralString };
var LiteralReal = /** @class */ (function (_super) {
    __extends(LiteralReal, _super);
    function LiteralReal(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.literalReal;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.taggedValues = [];
        _this.type = null;
        _this.value = 0;
        _this.visibility = null;
        return _this;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    LiteralReal.prototype.getStringValue = function () {
        return this.modelDelegate.getStringValue(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    LiteralReal.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    LiteralReal.prototype.getValue = function () {
        return this.modelDelegate.getValue(this);
    };
    return LiteralReal;
}(Element));
export { LiteralReal };
var LiteralNull = /** @class */ (function (_super) {
    __extends(LiteralNull, _super);
    function LiteralNull(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.literalNull;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.taggedValues = [];
        _this.type = null;
        _this.visibility = null;
        return _this;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    LiteralNull.prototype.getStringValue = function () {
        return this.modelDelegate.getStringValue(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    LiteralNull.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    LiteralNull.prototype.getValue = function () {
        return this.modelDelegate.getValue(this);
    };
    return LiteralNull;
}(Element));
export { LiteralNull };
var LiteralInteger = /** @class */ (function (_super) {
    __extends(LiteralInteger, _super);
    function LiteralInteger(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.literalInteger;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.taggedValues = [];
        _this.type = null;
        _this.value = 0;
        _this.visibility = null;
        return _this;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    LiteralInteger.prototype.getStringValue = function () {
        return this.modelDelegate.getStringValue(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    LiteralInteger.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    LiteralInteger.prototype.getValue = function () {
        return this.modelDelegate.getValue(this);
    };
    return LiteralInteger;
}(Element));
export { LiteralInteger };
var LiteralBoolean = /** @class */ (function (_super) {
    __extends(LiteralBoolean, _super);
    function LiteralBoolean(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.literalBoolean;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.taggedValues = [];
        _this.type = null;
        _this.value = false;
        _this.visibility = null;
        return _this;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    LiteralBoolean.prototype.getStringValue = function () {
        return this.modelDelegate.getStringValue(this);
    };
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    LiteralBoolean.prototype.getTypeName = function () {
        return this.modelDelegate.getTypeName(this);
    };
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    LiteralBoolean.prototype.getValue = function () {
        return this.modelDelegate.getValue(this);
    };
    return LiteralBoolean;
}(Element));
export { LiteralBoolean };
var InterfaceRealization = /** @class */ (function (_super) {
    __extends(InterfaceRealization, _super);
    function InterfaceRealization(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.interfaceRealization;
        _this.appliedStereotypes = [];
        _this.taggedValues = [];
        return _this;
    }
    return InterfaceRealization;
}(Element));
export { InterfaceRealization };
var Interface = /** @class */ (function (_super) {
    __extends(Interface, _super);
    function Interface(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.interface;
        _this.appliedStereotypes = [];
        _this.generalizations = [];
        _this.isAbstract = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.name = '';
        _this.ownedAttributes = [];
        _this.ownedOperations = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Interface.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    Interface.prototype.getAllAttributes = function () {
        return this.modelDelegate.getAllAttributes(this);
    };
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    Interface.prototype.getAllOperations = function () {
        return this.modelDelegate.getAllOperations(this);
    };
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    Interface.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    Interface.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    Interface.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    Interface.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Interface.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Interface.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    Interface.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Interface.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    Interface.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    return Interface;
}(Element));
export { Interface };
var Generalization = /** @class */ (function (_super) {
    __extends(Generalization, _super);
    function Generalization(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.generalization;
        _this.appliedStereotypes = [];
        _this.isSubstitutable = false;
        _this.taggedValues = [];
        return _this;
    }
    Object.defineProperty(Generalization.prototype, "specific", {
        get: function () {
            return this.modelDelegate.getSpecific(this);
        },
        enumerable: true,
        configurable: true
    });
    return Generalization;
}(Element));
export { Generalization };
var EnumerationLiteral = /** @class */ (function (_super) {
    __extends(EnumerationLiteral, _super);
    function EnumerationLiteral(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.enumerationLiteral;
        _this.appliedStereotypes = [];
        _this.name = '';
        _this.order = 0;
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(EnumerationLiteral.prototype, "enumeration", {
        get: function () {
            return this.modelDelegate.getEnumeration(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Gets the value of the Specification property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    EnumerationLiteral.prototype.getSpecificationValue = function () {
        return this.modelDelegate.getSpecificationValue(this);
    };
    return EnumerationLiteral;
}(Element));
export { EnumerationLiteral };
var Enumeration = /** @class */ (function (_super) {
    __extends(Enumeration, _super);
    function Enumeration(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.enumeration;
        _this.appliedStereotypes = [];
        _this.baseType = null;
        _this.generalizations = [];
        _this.isAbstract = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.name = '';
        _this.ownedAttributes = [];
        _this.ownedLiterals = [];
        _this.ownedOperations = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Enumeration.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    Enumeration.prototype.getAllAttributes = function () {
        return this.modelDelegate.getAllAttributes(this);
    };
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    Enumeration.prototype.getAllOperations = function () {
        return this.modelDelegate.getAllOperations(this);
    };
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    Enumeration.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    Enumeration.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    Enumeration.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    Enumeration.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Enumeration.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Enumeration.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    Enumeration.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Enumeration.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    Enumeration.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    return Enumeration;
}(Element));
export { Enumeration };
var DocumentReference = /** @class */ (function () {
    function DocumentReference() {
        this.name = '';
        this.path = '';
    }
    return DocumentReference;
}());
export { DocumentReference };
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.comment;
        _this.appliedStereotypes = [];
        _this.body = '';
        _this.taggedValues = [];
        return _this;
    }
    return Comment;
}(Element));
export { Comment };
var Association = /** @class */ (function (_super) {
    __extends(Association, _super);
    function Association(modelDelegate, owner) {
        var _this = _super.call(this, modelDelegate, owner) || this;
        _this.elementType = elements.ElementType.association;
        _this.appliedStereotypes = [];
        _this.generalizations = [];
        _this.isAbstract = false;
        _this.isFinalSpecialization = false;
        _this.isInferred = false;
        _this.isLeaf = false;
        _this.memberEnds = [];
        _this.name = '';
        _this.ownedEnds = [];
        _this.taggedValues = [];
        _this.visibility = null;
        return _this;
    }
    Object.defineProperty(Association.prototype, "package", {
        get: function () {
            return this.modelDelegate.getPackage(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    Association.prototype.getAllParents = function () {
        return this.modelDelegate.getAllParents(this);
    };
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    Association.prototype.getAllSpecializations = function () {
        return this.modelDelegate.getAllSpecializations(this);
    };
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    Association.prototype.getFirstGeneralization = function () {
        return this.modelDelegate.getFirstGeneralization(this);
    };
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    Association.prototype.getFirstParent = function () {
        return this.modelDelegate.getFirstParent(this);
    };
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Association.prototype.getNamespaceName = function (separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    };
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    Association.prototype.getNestingPackages = function () {
        return this.modelDelegate.getNestingPackages(this);
    };
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    Association.prototype.getParents = function () {
        return this.modelDelegate.getParents(this);
    };
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    Association.prototype.getQualifiedName = function (separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    };
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    Association.prototype.getSpecializations = function () {
        return this.modelDelegate.getSpecializations(this);
    };
    return Association;
}(Element));
export { Association };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3Nlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGFzc2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7RUFNRTs7Ozs7Ozs7Ozs7QUFFRjs7OztFQUlFO0FBQ0YsT0FBTyxLQUFLLFFBQVEsTUFBTSxjQUFjLENBQUM7QUFHekM7SUFDQyxpQkFBc0IsYUFBMkIsRUFBRSxLQUE4QjtRQUEzRCxrQkFBYSxHQUFiLGFBQWEsQ0FBYztRQU8xQyx1QkFBa0IsR0FBMEIsRUFBRSxDQUFDO1FBRS9DLE9BQUUsR0FBVyxFQUFFLENBQUM7UUFFaEIsa0JBQWEsR0FBdUIsRUFBRSxDQUFDO1FBRTlCLFVBQUssR0FBNEIsSUFBSSxDQUFDO1FBRS9DLGlCQUFZLEdBQXdDLEVBQUUsQ0FBQztRQWI3RCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBY0Q7Ozs7O01BS0U7SUFDSyxxQ0FBbUIsR0FBMUI7UUFFQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUNGLGNBQUM7QUFBRCxDQUFDLEFBNUJELElBNEJDOztBQUVEO0lBQUE7SUFLQSxDQUFDO0lBQUQsK0JBQUM7QUFBRCxDQUFDLEFBTEQsSUFLQzs7QUFFRDtJQUFBO1FBRVEsZUFBVSxHQUFZLEtBQUssQ0FBQztJQUdwQyxDQUFDO0lBQUQsMEJBQUM7QUFBRCxDQUFDLEFBTEQsSUFLQzs7QUFFRDtJQUEyQix5QkFBTztJQUNqQyxlQUFZLGFBQTJCLEVBQUUsS0FBOEI7UUFBdkUsWUFBMEUsa0JBQU0sYUFBYSxFQUFFLEtBQUssQ0FBQyxTQUFFO1FBRXZGLGlCQUFXLEdBQXdCLFFBQVEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBRXZFLHdCQUFrQixHQUEwQixFQUFFLENBQUM7UUFFL0MscUJBQWUsR0FBOEIsRUFBRSxDQUFDO1FBRWhELDJCQUFxQixHQUFv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