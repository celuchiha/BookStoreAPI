/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
import { StringUtility } from '@yellicode/core';
import { ElementTypeUtility } from './utils';
import * as Interfaces from "./interfaces";
import * as Classes from "./classes";
import { ProfileUtility } from './profile-utility';
var ProfileExtender = /** @class */ (function () {
    function ProfileExtender() {
    }
    ProfileExtender.applyProfiles = function (profiles) {
        return; // disabled in favor of modeler-generated profile API code
        // profiles.forEach(p => {
        //     ProfileExtender.applyProfile(p as Interfaces.Profile);
        // })        
    };
    ProfileExtender.applyProfile = function (profile) {
        return; // disabled in favor of modeler-generated profile API code
        // const stereotypes = ProfileUtility.getStereotypes(profile);
        // if (stereotypes.length === 0) 
        //     return;
        // ProfileExtender.addHasProfileGetters(profile);
        // ProfileExtender.addHasStereotypeGetters(stereotypes);
    };
    /**
     * Extends all Package class types with getters for checking if the profile is applied to the Package.
     */
    ProfileExtender.addHasProfileGetters = function (profile) {
        var classTypes = ProfileExtender.getClassTypesByElementType(Interfaces.ElementType.package);
        ProfileExtender.extendTypesWithGetter(classTypes, "hasProfile_" + (profile.safeName || profile.name), function () {
            return ProfileUtility.hasProfileId(this, profile.id);
        });
    };
    /**
     * Extends all extendable class types with getters for checking if a stereotype is applied.
     */
    ProfileExtender.addHasStereotypeGetters = function (stereoTypes) {
        stereoTypes.forEach(function (st) {
            var metaClasses = ProfileUtility.getMetaClassesExtendedBy(st);
            metaClasses.forEach(function (metaClass) {
                var classTypes = ProfileExtender.getClassTypesByElementType(metaClass);
                ProfileExtender.extendTypesWithGetter(classTypes, "is_" + (st.safeName || st.name), function () {
                    // console.log(`Checking stereotype ${st.name}`);                   
                    return ProfileUtility.hasStereotypeId(this, st.id);
                });
                ProfileExtender.extendTypesWithGetter(classTypes, "as_" + (st.safeName || st.name), function () {
                    // console.log(`Checking stereotype ${st.name}`);                   
                    return this; // just return the current instance, this getter is just syntactic sugar for the TS compiler
                });
            });
        });
    };
    ProfileExtender.addSubElementAccessors = function (stereoTypes, elementType, elementSubTypes) {
        var classTypes = ProfileExtender.getClassTypesByElementType(elementType);
        ProfileExtender.addSubSelementAccessorsForElementTypes(classTypes, stereoTypes, elementSubTypes);
    };
    /**
     * Adds accessor functions for stereotypes to the package (and model) level, e.g. getMyStereotypeClasses(),
     * getMyStereotypeInterfaces(), etc
     */
    ProfileExtender.addPackageStereotypeAccessors = function (profile, stereoTypes) {
        // We apply the accessors to package types
        var packageTypes = ProfileExtender.getClassTypesByElementType(Interfaces.ElementType.package);
        stereoTypes.forEach(function (st) {
            // Does the stereotype extend a packageable element? If not, don't add an accessor on the package level.            
            var subPackagedElementTypes = st.extends.filter(function (ext) { return ElementTypeUtility.isPackageableElement(ext.metaClass); }).map(function (ext) { return ext.metaClass; });
            if (subPackagedElementTypes.length === 0)
                return;
            // Add an accessor for each packageable element that the profile extends
            ProfileExtender.addSubSelementAccessorsForElementTypes(packageTypes, stereoTypes, subPackagedElementTypes);
            // Create a generic accessor for all packaged elements having the stereotype applied            
            ProfileExtender.extendTypesWithFunction(packageTypes, "getPackagedElementsOf" + (st.safeName || st.name), function () {
                return ProfileUtility.filterByStereotypeId(this.packagedElements, st.id);
            });
        });
        // Create a accessor for access to packages having this profile applied (e.g. getPackagesOfMyProfile)        
        ProfileExtender.extendTypesWithFunction(packageTypes, "getPackagesOf" + (profile.safeName || profile.name), function () {
            return ProfileUtility.filterByProfileId(this.packagedElements, profile.id);
        });
    };
    /**
     * Extends all classifier types with accessors to profile-specific stereotypes for Operations, Properties etc.
     */
    ProfileExtender.addClassifierAccessors = function (stereoTypes) {
        //  All these types are a MemberedClassifier, so can have Properties (OwnedAttributes) and OwnedOperations    
        var classifierSubTypes = [Interfaces.ElementType.property, Interfaces.ElementType.operation];
        stereoTypes.forEach(function (st) {
            var memberedClassifiersExtendedByStereotype = st.extends.filter(function (ext) { return ElementTypeUtility.isMemberedClassifier(ext.metaClass); });
            memberedClassifiersExtendedByStereotype.forEach(function (extension) {
                //  console.info(`Stereotype ${st.name} extends classifier ${StringUtil.capitalize(Interfaces.ElementType[extendedElementType])}`);
                var classTypes = ProfileExtender.getClassTypesByElementType(extension.metaClass);
                ProfileExtender.addSubSelementAccessorsForElementTypes(classTypes, stereoTypes, classifierSubTypes);
            });
        });
    };
    ProfileExtender.addSubSelementAccessorsForElementTypes = function (classTypes, stereoTypes, elementTypes) {
        var classTypesDebugString = classTypes.map(function (t) { return t.name; }).join(', ');
        elementTypes.forEach(function (subElementType) {
            var stereoTypesExtendingSubType = stereoTypes.filter(function (s) { return s.extends.findIndex(function (t) { return t.metaClass === subElementType; }) > -1; });
            if (stereoTypesExtendingSubType.length > 0) {
                // console.info(`ProfileExtender: Adding ${StringUtil.capitalize(Interfaces.ElementType[subElementType])} stereotype accessors to ${classTypesDebugString}.`);
            }
            else {
                // There are no Stereotypes that extend the subType, so there is no need to add an accessor
                // console.info(`ProfileExtender: Not adding ${StringUtil.capitalize(Interfaces.ElementType[subElementType])} stereotype accessors to ${classTypesDebugString}. There is no stereotype extending this element type.`);
                return;
            }
            // If this an "Owned" sub element (e.g. OwnedOperations, OwnedAttributes), add a prefix.
            var prefix = ElementTypeUtility.isPackageableElement(subElementType) ? '' : 'Owned';
            stereoTypesExtendingSubType.forEach(function (st) {
                var pluralElementTypeName = ProfileExtender.getGetPluralElementTypeName(subElementType);
                var functionName = "get" + prefix + pluralElementTypeName + "Of" + (st.safeName || st.name); // E.g "getClassesOfMyStereotype"                        
                var accessorFunction = ProfileExtender.getAccessorFunctionForSubElementType(subElementType, st);
                if (accessorFunction) {
                    ProfileExtender.extendTypesWithFunction(classTypes, functionName, accessorFunction);
                }
                else {
                    // console.warn(`Failed adding accessor function '${functionName}' to ${classTypesDebugString}. Sub element type ${Interfaces.ElementType[subElementType]} is not supported.`);                
                }
            });
        });
    };
    ProfileExtender.getAccessorFunctionForSubElementType = function (subElementType, stereoType) {
        if (ElementTypeUtility.isPackageableElement(subElementType)) {
            // E.g. getMyStereotypeClasses
            return function () {
                return ProfileUtility.filterByStereotypeId(this.packagedElements, stereoType.id, subElementType);
            };
        }
        switch (subElementType) {
            case Interfaces.ElementType.property:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedAttributes, stereoType.id);
                };
            case Interfaces.ElementType.operation:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedOperations, stereoType.id);
                };
            case Interfaces.ElementType.parameter:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedParameters, stereoType.id);
                };
            case Interfaces.ElementType.enumerationLiteral:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedLiterals, stereoType.id);
                };
            default:
                return null;
        }
    };
    ProfileExtender.extendTypesWithFunction = function (classTypes, funcName, func) {
        classTypes.forEach(function (t) {
            // console.info(`ProfileExtender: Extending type ${t.name} with function '${funcName}'.`);           
            t.prototype[funcName] = func;
        });
    };
    ProfileExtender.extendTypesWithGetter = function (classTypes, propertyName, getter) {
        classTypes.forEach(function (t) {
            // console.info(`ProfileExtender: Extending type ${t.name} with getter '${propertyName}'.`);
            Object.defineProperty(t.prototype, propertyName, {
                get: getter,
                enumerable: true,
                configurable: true,
            });
        });
    };
    /**
     * Gets the actual Javascript implementation types that match the specified element type.
     */
    ProfileExtender.getClassTypesByElementType = function (elementType) {
        switch (elementType) {
            case Interfaces.ElementType.package:
                return [Classes.Model, Classes.Package];
            case Interfaces.ElementType.class:
                return [Classes.Class];
            case Interfaces.ElementType.dataType:
                return [Classes.DataType, Classes.PrimitiveType];
            case Interfaces.ElementType.interface:
                return [Classes.Interface];
            case Interfaces.ElementType.enumeration:
                return [Classes.Enumeration];
            case Interfaces.ElementType.enumerationLiteral:
                return [Classes.EnumerationLiteral];
            case Interfaces.ElementType.property:
                return [Classes.Property];
            case Interfaces.ElementType.operation:
                return [Classes.Operation];
            case Interfaces.ElementType.parameter:
                return [Classes.Parameter];
            default:
                console.warn("Failed getting class type(s) for element type '" + Interfaces.ElementType[elementType] + "'. The element type is not supported.");
                return [];
        }
    };
    ProfileExtender.getGetPluralElementTypeName = function (elementType) {
        switch (elementType) {
            case Interfaces.ElementType.property:
                return 'Attributes';
            case Interfaces.ElementType.class:
                return 'Classes';
            case Interfaces.ElementType.enumerationLiteral:
                return 'Literals';
            default:
                // By default, add ..s
                var singular = StringUtility.capitalize(Interfaces.ElementType[elementType]);
                return singular + "s";
        }
    };
    return ProfileExtender;
}());
export { ProfileExtender };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZmlsZS1leHRlbmRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9maWxlLWV4dGVuZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFN0MsT0FBTyxLQUFLLFVBQVUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxLQUFLLE9BQU8sTUFBTSxXQUFXLENBQUM7QUFDckMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRW5EO0lBQUE7SUE0TkEsQ0FBQztJQTNOaUIsNkJBQWEsR0FBM0IsVUFBNEIsUUFBOEI7UUFDdEQsT0FBTyxDQUFDLDBEQUEwRDtRQUVsRSwwQkFBMEI7UUFDMUIsNkRBQTZEO1FBQzdELGFBQWE7SUFDakIsQ0FBQztJQUVjLDRCQUFZLEdBQTNCLFVBQTRCLE9BQTJCO1FBQ25ELE9BQU8sQ0FBQywwREFBMEQ7UUFFbEUsOERBQThEO1FBQzlELGlDQUFpQztRQUNqQyxjQUFjO1FBRWQsaURBQWlEO1FBQ2pELHdEQUF3RDtJQUM1RCxDQUFDO0lBRUQ7O09BRUc7SUFDWSxvQ0FBb0IsR0FBbkMsVUFBb0MsT0FBMkI7UUFDM0QsSUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLDBCQUEwQixDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUYsZUFBZSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxpQkFBYyxPQUFPLENBQUMsUUFBUSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUUsRUFBRTtZQUNoRyxPQUFPLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7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