/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
import { ElementType } from '../interfaces';
import { isClass, isEnumeration, isStereotype, isMemberedClassifier, ElementTypeUtility, isBehavioredClassifier, isClassifier } from '../utils';
import { PackagedElementTransform } from './packaged-element-transform';
/**
 * Transforms packageable element elements of one element type to another element type. For example, this transform lets
 * you transform all classes in a model or package to interfaces.
 */
export class ElementTypeTransform extends PackagedElementTransform {
    constructor(sourceElementType, targetElementType) {
        super();
        if (!sourceElementType)
            throw 'TypeTransform sourceType cannot be null.';
        if (!targetElementType)
            throw 'TypeTransform targetType cannot be null.';
        if (sourceElementType === targetElementType) {
            // Warn but don't crash
            console.warn(`Invalid TypeTransform arguments: the source and target type are both of type '${ElementType[sourceElementType]}'.`);
        }
        this.sourceElementType = sourceElementType;
        this.targetElementType = targetElementType;
        this.sourceElementSelector = ElementTypeTransform.createTypeSelector(sourceElementType);
    }
    transformElement(element) {
        if (!this.sourceElementSelector(element) || this.sourceElementType === this.targetElementType)
            return;
        // Note that we don't check compatibility of existing relationships here. For example, we don't check the types of Generalizations when
        // a Class that has generalizations is transformed to an Interface (that has the same generalizations). 
        // The caller is responsible for transforming these generalizations as well.
        // Remove features that the type doesn't have         
        // ElementTypeTransform.removeOldSourceFeatures(element, this.targetElementType); // todo: disabled as long as this does not seem to add any value. 
        // Force the new elementType, even though it is readonly
        element.elementType = this.targetElementType;
        // Now add features that the type needs
        ElementTypeTransform.addNewTargetFeatures(element, this.sourceElementType);
    }
    static addNewTargetFeatures(transformedElement, sourceElementType) {
        // Get access to the internal model ModelDelegate
        const modelDelegate = transformedElement.modelDelegate;
        // Implement MemberedClassifier members
        if (isMemberedClassifier(transformedElement) && !ElementTypeUtility.isMemberedClassifier(sourceElementType)) {
            transformedElement.ownedAttributes = [];
            transformedElement.ownedOperations = [];
            transformedElement.getAllAttributes = () => { return modelDelegate.getAllAttributes(transformedElement); };
            transformedElement.getAllOperations = () => { return modelDelegate.getAllOperations(transformedElement); };
        }
        // Implement BehavioredClassifier members
        if (isBehavioredClassifier(transformedElement) && !ElementTypeUtility.isBehavioredClassifier(sourceElementType)) {
            transformedElement.interfaceRealizations = [];
        }
        // Implement Classifier members
        if (isClassifier(transformedElement) && !ElementTypeUtility.isClassifier(sourceElementType)) {
            transformedElement.generalizations = [];
            transformedElement.isAbstract = false;
            transformedElement.isFinalSpecialization = false;
            transformedElement.getAllParents = () => { return modelDelegate.getAllParents(transformedElement); };
            transformedElement.getAllSpecializations = () => { return modelDelegate.getAllSpecializations(transformedElement); };
            transformedElement.getFirstGeneralization = () => { return modelDelegate.getFirstGeneralization(transformedElement); };
            transformedElement.getFirstParent = () => { return modelDelegate.getFirstParent(transformedElement); };
            transformedElement.getParents = () => { return modelDelegate.getParents(transformedElement); };
            transformedElement.getSpecializations = () => { return modelDelegate.getSpecializations(transformedElement); };
        }
        // Implement Enumeration members
        if (isEnumeration(transformedElement) && !ElementTypeUtility.isEnumeration(sourceElementType)) {
            transformedElement.baseType = null;
            transformedElement.ownedLiterals = [];
        }
        // Implement Class members
        if (isClass(transformedElement) && !ElementTypeUtility.isClass(sourceElementType)) {
            transformedElement.isActive = true;
            transformedElement.getSuperClasses = () => { return modelDelegate.getSuperClasses(transformedElement); };
        }
        // Implement Stereotype members
        if (isStereotype(transformedElement) && !ElementTypeUtility.isStereotype(sourceElementType)) {
            transformedElement.extends = [];
            transformedElement.safeName = transformedElement.name; // sorry, it's not perfect
        }
    }
    static removeOldSourceFeatures(unTransformedElement, targetElementType) {
        // Remove MemberedClassifier members
        if (isMemberedClassifier(unTransformedElement) && !ElementTypeUtility.isMemberedClassifier(targetElementType)) {
            delete unTransformedElement.ownedAttributes;
            delete unTransformedElement.ownedOperations;
            delete unTransformedElement.getAllAttributes;
            delete unTransformedElement.getAllOperations;
        }
        // Remove BehavioredClassifier members
        if (isBehavioredClassifier(unTransformedElement) && !ElementTypeUtility.isBehavioredClassifier(targetElementType)) {
            delete unTransformedElement.interfaceRealizations;
        }
        // Remove Classifier members
        if (isClassifier(unTransformedElement) && !ElementTypeUtility.isClassifier(targetElementType)) {
            delete unTransformedElement.generalizations;
            delete unTransformedElement.isAbstract;
            delete unTransformedElement.isFinalSpecialization;
            delete unTransformedElement.getAllParents;
            delete unTransformedElement.getAllSpecializations;
            delete unTransformedElement.getFirstGeneralization;
            delete unTransformedElement.getFirstParent;
            delete unTransformedElement.getParents;
            delete unTransformedElement.getSpecializations;
        }
        // Remove Enumeration members
        if (isEnumeration(unTransformedElement) && !ElementTypeUtility.isEnumeration(targetElementType)) {
            delete unTransformedElement.baseType;
            delete unTransformedElement.ownedLiterals;
        }
        // Remove Class members
        if (isClass(unTransformedElement) && !ElementTypeUtility.isClass(targetElementType)) {
            delete unTransformedElement.isActive;
            delete unTransformedElement.getSuperClasses;
        }
        // Remove Stereotype members
        if (isStereotype(unTransformedElement) && !ElementTypeUtility.isStereotype(targetElementType)) {
            delete unTransformedElement.extends;
            delete unTransformedElement.safeName;
        }
    }
    static createTypeSelector(elementType) {
        // Do a strict elementType comparison here
        return (t) => { return t.elementType === elementType; };
        // Alternatively, we could use the 'is...' functions to also include descendent types of elementType, 
        // but this might be confusing.
        // switch (elementType) {
        //     case ElementType.class:                
        //         return isClass;                
        //     case ElementType.dataType:
        //         return isDataType;
        //     case ElementType.enumeration:
        //         return isEnumeration;
        //     case ElementType.interface:
        //         return isInterface;
        //     case ElementType.primitiveType:
        //         return isPrimitiveType;
        //     case ElementType.stereotype:
        //         return isStereotype;
        //     default:
        //         throw `Unsupported element type ${ElementType[elementType]}.`;
        // }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxlbWVudC10eXBlLXRyYW5zZm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90cmFuc2Zvcm1zL2VsZW1lbnQtdHlwZS10cmFuc2Zvcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUE0QixXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEUsT0FBTyxFQUFFLE9BQU8sRUFBYyxhQUFhLEVBQWdDLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxrQkFBa0IsRUFBRSxzQkFBc0IsRUFBRSxZQUFZLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDMUwsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFHeEU7OztHQUdHO0FBQ0gsTUFBTSwyQkFBNEIsU0FBUSx3QkFBd0I7SUFLOUQsWUFDSSxpQkFBb0ssRUFDcEssaUJBQW9LO1FBRXBLLEtBQUssRUFBRSxDQUFDO1FBRVIsSUFBSSxDQUFDLGlCQUFpQjtZQUNsQixNQUFNLDBDQUEwQyxDQUFDO1FBRXJELElBQUksQ0FBQyxpQkFBaUI7WUFDbEIsTUFBTSwwQ0FBMEMsQ0FBQztRQUVyRCxJQUFJLGlCQUFpQixLQUFLLGlCQUFpQixFQUFFO1lBQ3pDLHVCQUF1QjtZQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLGlGQUFpRixXQUFXLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckk7UUFFRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUM7UUFDM0MsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDO1FBQzNDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxvQkFBb0IsQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQzVGLENBQUM7SUFFeUIsZ0JBQWdCLENBQUMsT0FBMkI7UUFDbEUsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMs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