/*
* Copyright (c) 2019 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
import * as toposort from 'toposort';
import { isPackage, isClassifier, isBehavioredClassifier, isMemberedClassifier, isType } from '../utils';
/**
 * A bitwise enumeration used to specify what types of dependency to include
 * during a DependencySortTransform.
 */
export var DependencyKind;
(function (DependencyKind) {
    DependencyKind[DependencyKind["none"] = 0] = "none";
    DependencyKind[DependencyKind["generalizations"] = 1] = "generalizations";
    DependencyKind[DependencyKind["interfaceRealizations"] = 2] = "interfaceRealizations";
    DependencyKind[DependencyKind["attributes"] = 4] = "attributes";
    DependencyKind[DependencyKind["operationParameters"] = 8] = "operationParameters";
    DependencyKind[DependencyKind["all"] = 15] = "all";
})(DependencyKind || (DependencyKind = {}));
/**
 * Sorts the types within a package (and within each nested package) based on their dependencies, in such a way
 * that dependencies appear before dependents. Dependencies are determined based on generalizations, interface
 * realizations, attributes and operation parameters.
 */
export class DependencySortTransform {
    /**
     * Constructor. Creates a new DependencySortTransform instance.
     * @param dependencyKind An optional DependencyKind value (or a bitwise combination of values)
     * that indicates what types of dependency must be taken into account. The default is DependencyKind.All.
     */
    constructor(dependencyKind) {
        this._options = dependencyKind == null ? DependencyKind.all : dependencyKind;
    }
    transform(pack) {
        if (!pack)
            return pack;
        this.transformPackageRecursive(pack);
        return pack;
    }
    transformPackageRecursive(pack) {
        if (!pack.packagedElements)
            return;
        // Get all siblings that are relevant for building a depencency graph.        
        const allTypes = pack.packagedElements.filter(pe => isType(pe));
        // Build a dependency graph of each element, see https://www.npmjs.com/package/toposort for the docs
        var graph = [];
        allTypes.forEach((t) => {
            let elementDependencies = DependencySortTransform.getTypeDependencies(t, this._options, allTypes);
            if (elementDependencies.length > 0) {
                elementDependencies.forEach((dependency) => {
                    graph.push([t, dependency]);
                });
            }
        });
        if (graph.length > 0) {
            // Sort, and reverse because we need a dependency graph
            pack.packagedElements = toposort.array(pack.packagedElements, graph).reverse();
        }
        // Transform nested packages, recursively        
        pack.packagedElements.forEach((element) => {
            if (isPackage(element)) {
                this.transformPackageRecursive(element);
            }
        });
    }
    static getTypeDependencies(element, options, allTypes) {
        var result = [];
        // Dependencies based on generalizations
        if (options & DependencyKind.generalizations && isClassifier(element)) {
            DependencySortTransform.pushGeneralizationDependencies(element, allTypes, result);
        }
        // Dependencies based on interface realization
        if (options & DependencyKind.interfaceRealizations && isBehavioredClassifier(element)) {
            DependencySortTransform.pushInterfaceRealizationDependencies(element, allTypes, result);
        }
        // Dependencies based on members
        if (isMemberedClassifier(element)) {
            if (options & DependencyKind.attributes) {
                DependencySortTransform.pushOwnedAttributeDependencies(element, allTypes, result);
            }
            if (options & DependencyKind.operationParameters) {
                DependencySortTransform.pushOwnedOperationDependencies(element, allTypes, result);
            }
        }
        return result;
    }
    static pushGeneralizationDependencies(element, allTypes, dependencies) {
        if (!element.generalizations || !element.generalizations.length)
            return;
        element.generalizations.forEach(g => {
            if (g.general === element)
                return;
            if (allTypes.indexOf(g.general) > -1 && dependencies.indexOf(g.general) === -1) {
                dependencies.push(g.general);
            }
        });
    }
    static pushInterfaceRealizationDependencies(element, allTypes, dependencies) {
        if (!element.interfaceRealizations || !element.interfaceRealizations.length)
            return;
        element.interfaceRealizations.forEach(ir => {
            if (allTypes.indexOf(ir.contract) > -1 && dependencies.indexOf(ir.contract) === -1) {
                dependencies.push(ir.contract);
            }
        });
    }
    static pushOwnedOperationDependencies(element, allTypes, dependencies) {
        if (!element.ownedOperations || !element.ownedOperations.length)
            return;
        element.ownedOperations.forEach(op => {
            if (!op.ownedParameters || !op.ownedParameters.length)
                return;
            op.ownedParameters.forEach(p => {
                if (!p.type)
                    return;
                if (allTypes.indexOf(p.type) > -1 && dependencies.indexOf(p.type) === -1) {
                    dependencies.push(p.type);
                }
            });
        });
    }
    static pushOwnedAttributeDependencies(element, allTypes, dependencies) {
        if (!element.ownedAttributes || !element.ownedAttributes.length)
            return;
        element.ownedAttributes.forEach(att => {
            if (!att.type)
                return;
            if (allTypes.indexOf(att.type) > -1 && dependencies.indexOf(att.type) === -1) {
                dependencies.push(att.type);
            }
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwZW5kZW5jeS1zb3J0LXRyYW5zZm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90cmFuc2Zvcm1zL2RlcGVuZGVuY3ktc29ydC10cmFuc2Zvcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztFQU1FO0FBRUYsT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVLENBQUM7QUFHckMsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXpHOzs7R0FHRztBQUNILE1BQU0sQ0FBTixJQUFZLGNBT1g7QUFQRCxXQUFZLGNBQWM7SUFDdEIsbURBQVEsQ0FBQTtJQUNSLHlFQUF3QixDQUFBO0lBQ3hCLHFGQUE4QixDQUFBO0lBQzlCLCtEQUFtQixDQUFBO0lBQ25CLGlGQUE0QixDQUFBO0lBQzVCLGtEQUFnRixDQUFBO0FBQ3BGLENBQUMsRUFQVyxjQUFjLEtBQWQsY0FBYyxRQU96QjtBQUVEOzs7O0dBSUc7QUFDSCxNQUFNO0lBR0Y7Ozs7T0FJRztJQUNILFlBQVksY0FBK0I7UUFDdkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxjQUFjLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7SUFDakYsQ0FBQztJQUVNLFNBQVMsQ0FBQyxJQUFhO1FBQzFCLElBQUksQ0FBQyxJQUFJO1lBQ0wsT0FBTyxJQUFJLENBQUM7UUFFaEIsSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTyx5QkFBeUIsQ0FBQyxJQUFhO1FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCO1lBQ3RCLE9BQU87UUFFWCw4RUFBOEU7UUFDOUUsTUFBTSxRQUFRLEdBQVcsSUFBSSxDQUFDLGdCQUFnQixD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