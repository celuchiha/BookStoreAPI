/*
* Copyright (c) 2019 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/**
* This code was generated by a tool.
*
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from './interfaces';
export class Element {
    constructor(modelDelegate, owner) {
        this.modelDelegate = modelDelegate;
        this.appliedStereotypes = [];
        this.id = '';
        this.ownedComments = [];
        this.owner = null;
        this.taggedValues = [];
        this.owner = owner;
    }
    /**
    * Gets the text contents of the first comment in the element's owned comments, or an empty string if
    * the element has no comments.
    * @returns {string} The body string of the first comment. If the element has no comments, an empty
    * string is returned.
    */
    getFirstCommentBody() {
        return this.modelDelegate.getFirstCommentBody(this);
    }
}
export class TaggedValueSpecification {
}
export class StereotypeExtension {
    constructor() {
        this.isRequired = false;
    }
}
export class Class extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.class;
        this.appliedStereotypes = [];
        this.generalizations = [];
        this.interfaceRealizations = [];
        this.isAbstract = false;
        this.isActive = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.name = '';
        this.ownedAttributes = [];
        this.ownedOperations = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes() {
        return this.modelDelegate.getAllAttributes(this);
    }
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations() {
        return this.modelDelegate.getAllOperations(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
    /**
    * Gets the superclasses of a Class, derived from its Generalizations.
    * @returns {elements.Class[]}
    */
    getSuperClasses() {
        return this.modelDelegate.getSuperClasses(this);
    }
}
export class Stereotype extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.stereotype;
        this.appliedStereotypes = [];
        this.extends = [];
        this.generalizations = [];
        this.interfaceRealizations = [];
        this.isAbstract = false;
        this.isActive = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.name = '';
        this.ownedAttributes = [];
        this.ownedOperations = [];
        this.safeName = '';
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes() {
        return this.modelDelegate.getAllAttributes(this);
    }
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations() {
        return this.modelDelegate.getAllOperations(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
    /**
    * Gets the superclasses of a Class, derived from its Generalizations.
    * @returns {elements.Class[]}
    */
    getSuperClasses() {
        return this.modelDelegate.getSuperClasses(this);
    }
}
export class Property extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.property;
        this.aggregation = elements.AggregationKind.none;
        this.appliedStereotypes = [];
        this.defaultValue = null;
        this.isDerived = false;
        this.isDerivedUnion = false;
        this.isID = false;
        this.isLeaf = false;
        this.isNavigable = false;
        this.isOrdered = false;
        this.isReadOnly = false;
        this.isStatic = false;
        this.isUnique = false;
        this.lowerValue = null;
        this.name = '';
        this.order = 0;
        this.taggedValues = [];
        this.type = null;
        this.upperValue = null;
        this.visibility = null;
    }
    get association() {
        return this.modelDelegate.getAssociation(this);
    }
    get lower() {
        return this.modelDelegate.getLower(this);
    }
    get upper() {
        return this.modelDelegate.getUpper(this);
    }
    /**
    * Gets the value of the DefaultValue property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    getDefault() {
        return this.modelDelegate.getDefault(this);
    }
    /**
    * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise.
    * @returns {number}
    */
    getLowerBound() {
        return this.modelDelegate.getLowerBound(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
    * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * @returns {elements.UnlimitedNatural}
    */
    getUpperBound() {
        return this.modelDelegate.getUpperBound(this);
    }
    /**
    * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
    * @returns {boolean}
    */
    isMultivalued() {
        return this.modelDelegate.isMultivalued(this);
    }
    /**
    * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    isOptional() {
        return this.modelDelegate.isOptional(this);
    }
    /**
    * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
    * upper bound of 1 (0..1).
    * @returns {boolean}
    */
    isOptionalAndSinglevalued() {
        return this.modelDelegate.isOptionalAndSinglevalued(this);
    }
    /**
    * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
    * upper bound of 1 (1..1).
    * @returns {boolean}
    */
    isRequiredAndSinglevalued() {
        return this.modelDelegate.isRequiredAndSinglevalued(this);
    }
}
export class Package extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.package;
        this.appliedProfiles = [];
        this.appliedStereotypes = [];
        this.isNamespaceRoot = false;
        this.name = '';
        this.packagedElements = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    getAllClasses() {
        return this.modelDelegate.getAllClasses(this);
    }
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    getAllDataTypes() {
        return this.modelDelegate.getAllDataTypes(this);
    }
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    getAllEnumerations() {
        return this.modelDelegate.getAllEnumerations(this);
    }
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    getAllInterfaces() {
        return this.modelDelegate.getAllInterfaces(this);
    }
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getAllTypes() {
        return this.modelDelegate.getAllTypes(this);
    }
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    getClasses() {
        return this.modelDelegate.getClasses(this);
    }
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    getDataTypes() {
        return this.modelDelegate.getDataTypes(this);
    }
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    getEnumerations() {
        return this.modelDelegate.getEnumerations(this);
    }
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    getInterfaces() {
        return this.modelDelegate.getInterfaces(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    getNestedPackages() {
        return this.modelDelegate.getNestedPackages(this);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getTypes() {
        return this.modelDelegate.getTypes(this);
    }
}
export class Profile extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.profile;
        this.appliedProfiles = [];
        this.appliedStereotypes = [];
        this.isNamespaceRoot = false;
        this.name = '';
        this.packagedElements = [];
        this.safeName = '';
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    getAllClasses() {
        return this.modelDelegate.getAllClasses(this);
    }
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    getAllDataTypes() {
        return this.modelDelegate.getAllDataTypes(this);
    }
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    getAllEnumerations() {
        return this.modelDelegate.getAllEnumerations(this);
    }
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    getAllInterfaces() {
        return this.modelDelegate.getAllInterfaces(this);
    }
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getAllTypes() {
        return this.modelDelegate.getAllTypes(this);
    }
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    getClasses() {
        return this.modelDelegate.getClasses(this);
    }
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    getDataTypes() {
        return this.modelDelegate.getDataTypes(this);
    }
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    getEnumerations() {
        return this.modelDelegate.getEnumerations(this);
    }
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    getInterfaces() {
        return this.modelDelegate.getInterfaces(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    getNestedPackages() {
        return this.modelDelegate.getNestedPackages(this);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getTypes() {
        return this.modelDelegate.getTypes(this);
    }
}
export class DataType extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.dataType;
        this.appliedStereotypes = [];
        this.generalizations = [];
        this.isAbstract = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.name = '';
        this.ownedAttributes = [];
        this.ownedOperations = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes() {
        return this.modelDelegate.getAllAttributes(this);
    }
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations() {
        return this.modelDelegate.getAllOperations(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
}
export class PrimitiveType extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.primitiveType;
        this.appliedStereotypes = [];
        this.generalizations = [];
        this.isAbstract = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.name = '';
        this.ownedAttributes = [];
        this.ownedOperations = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes() {
        return this.modelDelegate.getAllAttributes(this);
    }
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations() {
        return this.modelDelegate.getAllOperations(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
}
export class Parameter extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.parameter;
        this.appliedStereotypes = [];
        this.defaultValue = null;
        this.direction = elements.ParameterDirectionKind.in;
        this.isException = false;
        this.isOrdered = false;
        this.isStream = false;
        this.isUnique = false;
        this.lowerValue = null;
        this.name = '';
        this.order = 0;
        this.taggedValues = [];
        this.type = null;
        this.upperValue = null;
        this.visibility = null;
    }
    get lower() {
        return this.modelDelegate.getLower(this);
    }
    get upper() {
        return this.modelDelegate.getUpper(this);
    }
    /**
    * Gets the value of the DefaultValue property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    getDefault() {
        return this.modelDelegate.getDefault(this);
    }
    /**
    * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise.
    * @returns {number}
    */
    getLowerBound() {
        return this.modelDelegate.getLowerBound(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
    * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * @returns {elements.UnlimitedNatural}
    */
    getUpperBound() {
        return this.modelDelegate.getUpperBound(this);
    }
    /**
    * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
    * @returns {boolean}
    */
    isMultivalued() {
        return this.modelDelegate.isMultivalued(this);
    }
    /**
    * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    isOptional() {
        return this.modelDelegate.isOptional(this);
    }
    /**
    * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
    * upper bound of 1 (0..1).
    * @returns {boolean}
    */
    isOptionalAndSinglevalued() {
        return this.modelDelegate.isOptionalAndSinglevalued(this);
    }
    /**
    * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
    * upper bound of 1 (1..1).
    * @returns {boolean}
    */
    isRequiredAndSinglevalued() {
        return this.modelDelegate.isRequiredAndSinglevalued(this);
    }
}
export class Operation extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.operation;
        this.appliedStereotypes = [];
        this.isAbstract = false;
        this.isConstructor = false;
        this.isLeaf = false;
        this.isQuery = false;
        this.isStatic = false;
        this.name = '';
        this.order = 0;
        this.ownedParameters = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get lower() {
        return this.modelDelegate.getLower(this);
    }
    get upper() {
        return this.modelDelegate.getUpper(this);
    }
    /**
    * Returns the ownedParameters with direction in and inout.
    * @returns {elements.Parameter[]}
    */
    getInputParameters() {
        return this.modelDelegate.getInputParameters(this);
    }
    /**
    * The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
    * integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
    * return result for this Operation.
    * @returns {number}
    */
    getLowerBound() {
        return this.modelDelegate.getLowerBound(this);
    }
    /**
    * Returns the ownedParameters with direction out, inout, or return.
    * @returns {elements.Parameter[]}
    */
    getOutputParameters() {
        return this.modelDelegate.getOutputParameters(this);
    }
    /**
    * Gets the operation's return parameter, if it has one.
    * @returns {elements.Parameter}
    */
    getReturnParameter() {
        return this.modelDelegate.getReturnParameter(this);
    }
    /**
    * Gets the type of the operation's return parameter, if it has any.
    * @returns {elements.Type}
    */
    getReturnType() {
        return this.modelDelegate.getReturnType(this);
    }
    /**
    * The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
    * an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
    * This information is derived from the return result for this Operation.
    * @returns {elements.UnlimitedNatural}
    */
    getUpperBound() {
        return this.modelDelegate.getUpperBound(this);
    }
    /**
    * The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
    * @returns {boolean}
    */
    isMultivalued() {
        return this.modelDelegate.isMultivalued(this);
    }
    /**
    * The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
    * @returns {boolean}
    */
    isOptional() {
        return this.modelDelegate.isOptional(this);
    }
    /**
    * The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
    * 1 (0..1).
    * @returns {boolean}
    */
    isOptionalAndSinglevalued() {
        return this.modelDelegate.isOptionalAndSinglevalued(this);
    }
}
export class Model extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.model;
        this.appliedProfiles = [];
        this.appliedStereotypes = [];
        this.isNamespaceRoot = false;
        this.name = '';
        this.packagedElements = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Gets all classes that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Class[]}
    */
    getAllClasses() {
        return this.modelDelegate.getAllClasses(this);
    }
    /**
    * Gets all data types that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.DataType[]}
    */
    getAllDataTypes() {
        return this.modelDelegate.getAllDataTypes(this);
    }
    /**
    * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Enumeration[]}
    */
    getAllEnumerations() {
        return this.modelDelegate.getAllEnumerations(this);
    }
    /**
    * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
    * @returns {elements.Interface[]}
    */
    getAllInterfaces() {
        return this.modelDelegate.getAllInterfaces(this);
    }
    /**
    * Gets all types that are owned by this Package, including the ones owned by nested packages. This
    * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getAllTypes() {
        return this.modelDelegate.getAllTypes(this);
    }
    /**
    * Gets all classes that are owned by this Package.
    * @returns {elements.Class[]} A subset of PackagedElements.
    */
    getClasses() {
        return this.modelDelegate.getClasses(this);
    }
    /**
    * Gets all data types that are owned by this Package.
    * @returns {elements.DataType[]} A subset of PackagedElements.
    */
    getDataTypes() {
        return this.modelDelegate.getDataTypes(this);
    }
    /**
    * Gets all enumerations that are owned by this Package.
    * @returns {elements.Enumeration[]} A subset of PackagedElements.
    */
    getEnumerations() {
        return this.modelDelegate.getEnumerations(this);
    }
    /**
    * Gets all interfaces that are owned by this Package.
    * @returns {elements.Interface[]} A subset of PackagedElements.
    */
    getInterfaces() {
        return this.modelDelegate.getInterfaces(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that are owned by this Package.
    * @returns {elements.Package[]} A subset of PackagedElements.
    */
    getNestedPackages() {
        return this.modelDelegate.getNestedPackages(this);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all types that are owned by this Package. This includes the following types of elements: Class,
    * Interface, DataType, PrimitiveType and Enumeration.
    * @returns {elements.Classifier[]} A subset of PackagedElements.
    */
    getTypes() {
        return this.modelDelegate.getTypes(this);
    }
}
export class LiteralUnlimitedNatural extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.literalUnlimitedNatural;
        this.appliedStereotypes = [];
        this.name = '';
        this.taggedValues = [];
        this.type = null;
        this.visibility = null;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue() {
        return this.modelDelegate.getStringValue(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue() {
        return this.modelDelegate.getValue(this);
    }
}
export class LiteralString extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.literalString;
        this.appliedStereotypes = [];
        this.name = '';
        this.taggedValues = [];
        this.type = null;
        this.value = '';
        this.visibility = null;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue() {
        return this.modelDelegate.getStringValue(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue() {
        return this.modelDelegate.getValue(this);
    }
}
export class LiteralReal extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.literalReal;
        this.appliedStereotypes = [];
        this.name = '';
        this.taggedValues = [];
        this.type = null;
        this.value = 0;
        this.visibility = null;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue() {
        return this.modelDelegate.getStringValue(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue() {
        return this.modelDelegate.getValue(this);
    }
}
export class LiteralNull extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.literalNull;
        this.appliedStereotypes = [];
        this.name = '';
        this.taggedValues = [];
        this.type = null;
        this.visibility = null;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue() {
        return this.modelDelegate.getStringValue(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue() {
        return this.modelDelegate.getValue(this);
    }
}
export class LiteralInteger extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.literalInteger;
        this.appliedStereotypes = [];
        this.name = '';
        this.taggedValues = [];
        this.type = null;
        this.value = 0;
        this.visibility = null;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue() {
        return this.modelDelegate.getStringValue(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue() {
        return this.modelDelegate.getValue(this);
    }
}
export class LiteralBoolean extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.literalBoolean;
        this.appliedStereotypes = [];
        this.name = '';
        this.taggedValues = [];
        this.type = null;
        this.value = false;
        this.visibility = null;
    }
    /**
    * Gets the string representation of the value.
    * @returns {string}
    */
    getStringValue() {
        return this.modelDelegate.getStringValue(this);
    }
    /**
    * Gets the name of the typed element's type.
    * @returns {string} The type name, or an empty string if the element has no type.
    */
    getTypeName() {
        return this.modelDelegate.getTypeName(this);
    }
    /**
    * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
    * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
    * ValueSpecification.
    */
    getValue() {
        return this.modelDelegate.getValue(this);
    }
}
export class InterfaceRealization extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.interfaceRealization;
        this.appliedStereotypes = [];
        this.taggedValues = [];
    }
}
export class Interface extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.interface;
        this.appliedStereotypes = [];
        this.generalizations = [];
        this.isAbstract = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.name = '';
        this.ownedAttributes = [];
        this.ownedOperations = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes() {
        return this.modelDelegate.getAllAttributes(this);
    }
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations() {
        return this.modelDelegate.getAllOperations(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
}
export class Generalization extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.generalization;
        this.appliedStereotypes = [];
        this.isSubstitutable = false;
        this.taggedValues = [];
    }
    get specific() {
        return this.modelDelegate.getSpecific(this);
    }
}
export class EnumerationLiteral extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.enumerationLiteral;
        this.appliedStereotypes = [];
        this.name = '';
        this.order = 0;
        this.taggedValues = [];
        this.visibility = null;
    }
    get enumeration() {
        return this.modelDelegate.getEnumeration(this);
    }
    /**
    * Gets the value of the Specification property.
    * @returns {any} The default value (the type depending on the type of value), or null if no default
    * value can be determined.
    */
    getSpecificationValue() {
        return this.modelDelegate.getSpecificationValue(this);
    }
}
export class Enumeration extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.enumeration;
        this.appliedStereotypes = [];
        this.baseType = null;
        this.generalizations = [];
        this.isAbstract = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.name = '';
        this.ownedAttributes = [];
        this.ownedLiterals = [];
        this.ownedOperations = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns both inherited and owned attributes.
    * @returns {elements.Property[]}
    */
    getAllAttributes() {
        return this.modelDelegate.getAllAttributes(this);
    }
    /**
    * Returns both inherited and owned operations. Any inherited operation that has the same signature
    * (having the same name and parameter type order) in an inheriting type is not included.
    * @returns {elements.Operation[]}
    */
    getAllOperations() {
        return this.modelDelegate.getAllOperations(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
}
export class DocumentReference {
    constructor() {
        this.name = '';
        this.path = '';
    }
}
export class Comment extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.comment;
        this.appliedStereotypes = [];
        this.body = '';
        this.taggedValues = [];
    }
}
export class Association extends Element {
    constructor(modelDelegate, owner) {
        super(modelDelegate, owner);
        this.elementType = elements.ElementType.association;
        this.appliedStereotypes = [];
        this.generalizations = [];
        this.isAbstract = false;
        this.isFinalSpecialization = false;
        this.isInferred = false;
        this.isLeaf = false;
        this.memberEnds = [];
        this.name = '';
        this.ownedEnds = [];
        this.taggedValues = [];
        this.visibility = null;
    }
    get package() {
        return this.modelDelegate.getPackage(this);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
    * specific classifiers will appear before more general classifiers.
    * @returns {elements.Classifier[]}
    */
    getAllParents() {
        return this.modelDelegate.getAllParents(this);
    }
    /**
    * Gets all classifiers of which this element is a direct or indirect general.
    * @returns {elements.Classifier[]}
    */
    getAllSpecializations() {
        return this.modelDelegate.getAllSpecializations(this);
    }
    /**
    * Gets the first direct generalization relationship of the element.
    * @returns {elements.Generalization}
    */
    getFirstGeneralization() {
        return this.modelDelegate.getFirstGeneralization(this);
    }
    /**
    * Gets the first classifier that is an immediate general of the current element.
    * @returns {elements.Classifier}
    */
    getFirstParent() {
        return this.modelDelegate.getFirstParent(this);
    }
    /**
    * Constructs a name from the names of the nesting packages. The name is constructed working inwards
    * from the package that is defined as namespace root up to but not including the PackageableElement
    * itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getNamespaceName(separator) {
        return this.modelDelegate.getNamespaceName(this, separator);
    }
    /**
    * Gets all packages that contain this Package, working inwards from the top Package to the owning
    * package.
    * @returns {elements.Package[]} A collection of Packages.
    */
    getNestingPackages() {
        return this.modelDelegate.getNestingPackages(this);
    }
    /**
    * Gives all of the immediate ancestors of a generalized Classifier.
    * @returns {elements.Classifier[]}
    */
    getParents() {
        return this.modelDelegate.getParents(this);
    }
    /**
    * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
    * constructed working inwards from the package that is defined as namespace root up to and including
    * the PackageableElement itself.
    * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
    * used.
    * @returns {string} A single string with all the names separated.
    */
    getQualifiedName(separator) {
        return this.modelDelegate.getQualifiedName(this, separator);
    }
    /**
    * Gets all classifiers of which this classifier is a direct general.
    * @returns {elements.Classifier[]}
    */
    getSpecializations() {
        return this.modelDelegate.getSpecializations(this);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3Nlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGFzc2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7RUFNRTtBQUVGOzs7O0VBSUU7QUFDRixPQUFPLEtBQUssUUFBUSxNQUFNLGNBQWMsQ0FBQztBQUd6QyxNQUFNO0lBQ0wsWUFBc0IsYUFBMkIsRUFBRSxLQUE4QjtRQUEzRCxrQkFBYSxHQUFiLGFBQWEsQ0FBYztRQU8xQyx1QkFBa0IsR0FBMEIsRUFBRSxDQUFDO1FBRS9DLE9BQUUsR0FBVyxFQUFFLENBQUM7UUFFaEIsa0JBQWEsR0FBdUIsRUFBRSxDQUFDO1FBRTlCLFVBQUssR0FBNEIsSUFBSSxDQUFDO1FBRS9DLGlCQUFZLEdBQXdDLEVBQUUsQ0FBQztRQWI3RCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBY0Q7Ozs7O01BS0U7SUFDSyxtQkFBbUI7UUFFekIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JELENBQUM7Q0FDRDtBQUVELE1BQU07Q0FLTDtBQUVELE1BQU07SUFBTjtRQUVRLGVBQVUsR0FBWSxLQUFLLENBQUM7SUFHcEMsQ0FBQztDQUFBO0FBRUQsTUFBTSxZQUFhLFNBQVEsT0FBTztJQUNqQyxZQUFZLGFBQTJCLEVBQUUsS0FBOEI7UUFBRyxLQUFLLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRXRGLGdCQUFXLEdBQXdCLFFBQVEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBRXZFLHVCQUFrQixHQUEwQixFQUFFLENBQUM7UUFFL0Msb0JBQWUsR0FBOEIsRUFBRSxDQUFDO1FBRWhELDBCQUFxQixHQUFvQyxFQUFFLENBQUM7UUFFNUQsZUFBVSxHQUFZLEtBQUssQ0FBQztRQUU1QixhQUFRLEdBQVksS0FBSyxDQUFDO1FBRTFCLDBCQUFxQixHQUFZLEtBQUssQ0FBQztR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