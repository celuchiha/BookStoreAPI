/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
import * as Interfaces from "./interfaces";
import { ElementTypeUtility } from './utils';
import * as _ from 'lodash';
import { ElementComparerImpl } from "./element-comparer";
import * as utils from './utils';
/**
 * Internal class to which all behaviour of the model classes is delegated.
 */
export class ModelDelegateImpl {
    constructor(elementMap) {
        this.elementMap = elementMap;
        // Note that elementMap is null when not initialized through the DataToModelConverter
    }
    // ************************  Document **************************** //     
    findElementById(id) {
        if (!this.elementMap)
            return null;
        return this.elementMap.getElementById(id);
    }
    // **************************  Element ******************************* //     
    getFirstCommentBody(element) {
        if (!element.ownedComments || element.ownedComments.length == 0)
            return ''; // return an empty string, no null or undefined, they are inconvenient when using template literals.      
        return element.ownedComments[0].body;
    }
    // ************************  TypedElement **************************** //     
    getTypeName(typedElement) {
        if (!typedElement.type)
            return '';
        return typedElement.type.name;
    }
    // *****************************  Package **************************** //     
    static getPackagedElementsWhere(pack, predicate) {
        if (!pack.packagedElements)
            return [];
        return pack.packagedElements.filter(predicate);
    }
    static getAllPackagedElementsWhereRecursive(pack, predicate, result) {
        pack.packagedElements.forEach(e => {
            if (predicate(e)) {
                result.push(e);
            }
            if (ElementTypeUtility.isPackage(e.elementType) && e.packagedElements) {
                ModelDelegateImpl.getAllPackagedElementsWhereRecursive(e, predicate, result);
            }
        });
    }
    static getAllPackagedElementsWhere(pack, predicate) {
        const result = [];
        if (pack.packagedElements) {
            ModelDelegateImpl.getAllPackagedElementsWhereRecursive(pack, predicate, result);
        }
        return result;
    }
    getNestedPackages(element) {
        return ModelDelegateImpl.getPackagedElementsWhere(element, pe => pe.elementType === Interfaces.ElementType.package);
    }
    getTypes(element) {
        return ModelDelegateImpl.getPackagedElementsWhere(element, pe => 
        // Technically, an Association is also a Type, but it does not seem to make much sense here
        ElementTypeUtility.isType(pe.elementType) && !ElementTypeUtility.isAssociation(pe.elementType));
    }
    getAllTypes(element) {
        return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => 
        // Technically, an Association is also a Type, but it does not seem to make much sense here
        ElementTypeUtility.isType(pe.elementType) && !ElementTypeUtility.isAssociation(pe.elementType));
    }
    getClasses(element) {
        return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isClass(pe.elementType));
    }
    getAllClasses(element) {
        return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isClass(pe.elementType));
    }
    getInterfaces(element) {
        return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isInterface(pe.elementType));
    }
    getAllInterfaces(element) {
        return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isInterface(pe.elementType));
    }
    getDataTypes(element) {
        return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isDataType(pe.elementType));
    }
    getAllDataTypes(element) {
        return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isDataType(pe.elementType));
    }
    getEnumerations(element) {
        return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isEnumeration(pe.elementType));
    }
    getAllEnumerations(element) {
        return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isEnumeration(pe.elementType));
    }
    // ************************  PackageableElement **************************** //     
    getPackage(packagedElement) {
        return packagedElement.owner;
    }
    /**
    * Gets all packages that own this Package, working inwards from the top Package to the owning package.
    * @returns {Interfaces.Package[]} A collection of Packages.
    */
    getNestingPackages(packagedElement, stopAtNamespaceRoot) {
        // Work outwards, then reverse..
        const result = [];
        let owner = packagedElement.owner;
        while (owner && utils.isPackage(owner)) {
            result.push(owner);
            if (owner.isNamespaceRoot && stopAtNamespaceRoot === true) {
                break;
            }
            owner = owner.owner;
        }
        result.reverse();
        return result;
    }
    getNamespaceName(packagedElement, separator = '.') {
        return this.getNestingPackages(packagedElement, true).map(p => p.name).join(separator);
    }
    getQualifiedName(packagedElement, separator = '.') {
        const namespaceName = this.getNamespaceName(packagedElement, separator);
        return namespaceName ? `${namespaceName}${separator}${packagedElement.name}` : packagedElement.name;
    }
    // ************************  Generalization **************************** //     
    getSpecific(generalization) {
        return generalization.owner;
    }
    // **************************  Classifier ******************************* //     
    getFirstGeneralization(classifier) {
        if (classifier.generalizations.length === 0)
            return null;
        return classifier.generalizations[0];
    }
    getFirstParent(classifier) {
        const firstGeneralization = this.getFirstGeneralization(classifier);
        return (firstGeneralization) ? firstGeneralization.general : null;
    }
    getParents(classifier) {
        return classifier.generalizations.map(g => g.general);
    }
    /**
    * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more specific classifiers will
    * appear before more general classifiers.
    */
    getAllParents(classifier) {
        const allParents = [];
        this.getAllParentsRecursive(classifier, allParents);
        return allParents;
    }
    getAllParentsRecursive(classifier, allParents) {
        const ownParents = this.getParents(classifier);
        if (ownParents != null) {
            // More specific parents first.
            ownParents.forEach(p => {
                const ix = allParents.indexOf(p);
                // If the parent is already there, remove it and add it again at the end of the list.
                if (ix > -1) {
                    allParents.splice(ix, 1);
                }
                allParents.push(p);
            });
            // add the parents of each parent
            ownParents.forEach(p => {
                this.getAllParentsRecursive(p, allParents);
            });
        }
    }
    getSpecializations(classifier) {
        if (!this.elementMap)
            return [];
        return this.elementMap.getSpecializationsOf(classifier.id);
    }
    getAllSpecializations(classifier) {
        if (!this.elementMap)
            return [];
        return this.elementMap.getAllSpecializationsOf(classifier.id);
    }
    // /**
    //  * Returns true if one classifier has the other as direct general.     
    //  */
    // private static hasGeneral(x: Interfaces.Classifier, y: Interfaces.Classifier): boolean {
    //     // TODO: recursive?
    //     const firstMatch = x.generalizations.find(g => g.general.id === y.id);
    //     return firstMatch ? true: false;    
    // }
    // ********************  MemberedClassifier **************************** //     
    getAllAttributes(memberedClassifier) {
        const distinctClassifierIds = []; // keep this list to check against recursion
        const result = [];
        this.getAllAttributesRecursive(memberedClassifier, distinctClassifierIds, result);
        return result;
    }
    getAllAttributesRecursive(memberedClassifier, distinctClassifierIds, result) {
        distinctClassifierIds.push(memberedClassifier.id);
        // First add the general members, then the owned
        memberedClassifier.generalizations.forEach(g => {
            const general = g.general;
            if (distinctClassifierIds.indexOf(general.id) === -1) {
                this.getAllAttributesRecursive(general, distinctClassifierIds, result);
            }
        });
        // Now add the owned members
        result.push(...memberedClassifier.ownedAttributes);
    }
    getAllOperations(memberedClassifier) {
        const distinctClassifierIds = []; // keep this list to check against recursion
        const result = [];
        this.getAllOperationsRecursive(memberedClassifier, distinctClassifierIds, result);
        return result;
    }
    getAllOperationsRecursive(memberedClassifier, distinctClassifierIds, result) {
        distinctClassifierIds.push(memberedClassifier.id); // keep this list to check against recursion
        // First add the general members, then the owned
        memberedClassifier.generalizations.forEach(g => {
            const general = g.general;
            if (distinctClassifierIds.indexOf(general.id) === -1) {
                this.getAllOperationsRecursive(general, distinctClassifierIds, result);
            }
        });
        // Now add the owned members. Replace any inherited members with the same signature
        memberedClassifier.ownedOperations.forEach(op => {
            // Is there an operation in the result that has the same signature? Then replace it.
            // TODO: can we set a "redefines" reference (referring to the base operation)?             
            _.remove(result, (baseOperation) => ElementComparerImpl.haveEqualSignatures(baseOperation, op));
            result.push(op);
        });
    }
    // ************************  Class  **************************** //         
    getSuperClasses(cls) {
        const result = [];
        if (!cls.generalizations)
            return result;
        cls.generalizations.forEach(g => {
            if (ElementTypeUtility.isClass(g.general.elementType)) {
                result.push(g.general);
            }
        });
        return result;
    }
    // ************************  MultiplicityElement **************************** //         
    getLower(element) {
        // If element is an operation, return the lower of the return parameter
        const multiplicityElement = element.elementType === Interfaces.ElementType.operation ?
            element.getReturnParameter() :
            element;
        if (!multiplicityElement)
            return null; // the operation has no return parameter
        const lowerValue = multiplicityElement.lowerValue;
        if (!lowerValue)
            return null;
        switch (lowerValue.elementType) {
            case Interfaces.ElementType.literalInteger:
                return lowerValue.value;
            case Interfaces.ElementType.literalString:
                const stringValue = lowerValue.getStringValue();
                const parsed = Number.parseInt(stringValue);
                return isNaN(parsed) ? null : parsed;
            default:
                return null;
        }
    }
    getUpper(element) {
        // If element is an operation, return the upper of the return parameter
        const multiplicityElement = element.elementType === Interfaces.ElementType.operation ?
            element.getReturnParameter() :
            element;
        if (!multiplicityElement)
            return null; // the operation has no return parameter
        const upperValue = multiplicityElement.upperValue;
        if (upperValue == null)
            return null;
        switch (upperValue.elementType) {
            case Interfaces.ElementType.literalString:
            case Interfaces.ElementType.literalInteger:
                const stringValue = upperValue.getStringValue();
                return new Interfaces.UnlimitedNatural(stringValue);
            case Interfaces.ElementType.literalUnlimitedNatural:
                return upperValue.value;
            default:
                return null;
        }
    }
    getLowerBound(element) {
        const lower = this.getLower(element);
        // Do an explicit null check, allowing for 0. An unspecified lower means a lower bound of 1.
        return (lower === null) ? 1 : lower;
    }
    getUpperBound(element) {
        const upper = this.getUpper(element);
        // Do an explicit null check, allowing for 0. An unspecified upper means an upper bound of 1.
        return (upper === null) ? new Interfaces.UnlimitedNatural(1) : upper;
    }
    isMultivalued(element) {
        const upper = this.getUpper(element);
        if (!upper)
            return false;
        return upper.IsInfinity || upper.Value > 1;
    }
    isOptional(element) {
        return this.getLowerBound(element) === 0;
    }
    isOptionalAndSinglevalued(element) {
        if (this.getLowerBound(element) !== 0)
            return false; // not optional
        const upper = this.getUpperBound(element);
        return !upper.IsInfinity && upper.Value === 1;
    }
    isRequiredAndSinglevalued(element) {
        if (this.getLowerBound(element) !== 1)
            return false; // not required
        const upper = this.getUpperBound(element);
        return !upper.IsInfinity && upper.Value === 1;
    }
    // ********************  Default values **************************** //     
    getDefault(hasDefaultValue) {
        if (!hasDefaultValue.defaultValue)
            return null;
        return this.getValue(hasDefaultValue.defaultValue);
    }
    // ********************  ValueSpecification **************************** //     
    getValue(valueSpecification) {
        if ("value" in valueSpecification) { // don't use hasOwnProperty here
            // The valueSpecification is a LiteralInteger, LiteralBoolean, etc.
            return valueSpecification["value"];
        }
        else
            return null; // The valueSpecification is a LiteralNull or an unsupported implementation
    }
    getStringValue(valueSpecification) {
        const rawValue = valueSpecification.getValue();
        if (rawValue === null)
            return null;
        if (valueSpecification.elementType === Interfaces.ElementType.literalUnlimitedNatural) {
            return rawValue.stringValue();
        }
        return rawValue.toString();
    }
    // ********************  EnumerationLiteral **************************** //     
    getEnumeration(literal) {
        return literal.owner;
    }
    getSpecificationValue(literal) {
        if (!literal.specification)
            return null;
        return this.getValue(literal.specification);
    }
    // ********************  Property **************************** //     
    getAssociation(property) {
        // The property can be owned by an association (association.ownedEnds) or by a classifier
        // If owned by an association, the path is short.
        if (utils.isAssociation(property.owner)) {
            return property.owner;
        }
        // The property is not owned by an association, but can still be part of one
        // (association.memberEnds)
        if (!this.elementMap)
            return null;
        return this.elementMap.getAssociationHavingMemberEnd(property);
    }
    // ********************  Operation **************************** //     
    getReturnParameter(operation) {
        const val = operation.ownedParameters.find(p => { return p.direction === Interfaces.ParameterDirectionKind.return; });
        return val || null;
    }
    getInputParameters(operation) {
        return operation.ownedParameters.filter(p => {
            return p.direction === Interfaces.ParameterDirectionKind.in
                || p.direction === Interfaces.ParameterDirectionKind.inout;
        });
    }
    getOutputParameters(operation) {
        return operation.ownedParameters.filter(p => {
            return p.direction === Interfaces.ParameterDirectionKind.out
                || p.direction === Interfaces.ParameterDirectionKind.inout
                || p.direction === Interfaces.ParameterDirectionKind.return;
        });
    }
    getReturnType(operation) {
        const returnParameter = this.getReturnParameter(operation);
        return returnParameter ? returnParameter.type : null;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwtZGVsZWdhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbW9kZWwtZGVsZWdhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxLQUFLLFVBQVUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQzdDLE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3pELE9BQU8sS0FBSyxLQUFLLE1BQU0sU0FBUyxDQUFDO0FBSWpDOztHQUVHO0FBQ0gsTUFBTTtJQUNGLFlBQW9CLFVBQTZCO1FBQTdCLGVBQVUsR0FBVixVQUFVLENBQW1CO1FBQzdDLHFGQUFxRjtJQUN6RixDQUFDO0lBRUQsMEVBQTBFO0lBRW5FLGVBQWUsQ0FBQyxFQUFVO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVTtZQUFFLE9BQU8sSUFBSSxDQUFDO1FBRWxDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELDhFQUE4RTtJQUV2RSxtQkFBbUIsQ0FBQyxPQUEyQjtRQUNsRCxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDLE1BQU0sSUFBSSxDQUFDO1lBQzNELE9BQU8sRUFBRSxDQUFDLENBQUUsMEdBQTBHO1FBRTFILE9BQU8sT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDekMsQ0FBQztJQUVELDhFQUE4RTtJQUV2RSxXQUFXLENBQUMsWUFBcUM7UUFDcEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJO1lBQUUsT0FBTyxFQUFFLENBQUM7UUFDbEMsT0FBTyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUks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