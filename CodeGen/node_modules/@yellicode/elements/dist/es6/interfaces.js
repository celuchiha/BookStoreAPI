/*
* Copyright (c) 2019 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/**
* This code was generated by a tool.
*
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
/**
* Enumerates all non-abstract element types in the model. Each model element has an elementType field
* with an ElementType value.
*/
export var ElementType;
(function (ElementType) {
    /**
    * The element is a Association. Associations represent relationships between classes.
    */
    ElementType[ElementType["association"] = 1] = "association";
    /**
    * Alias for ElementType.class in case the reserved 'class' is not allowed.
    */
    ElementType[ElementType["_class"] = 2] = "_class";
    /**
    * The element is a Class. A Class classifies a set of objects and specifies the features that
    * characterize the structure and behavior of those objects. A Class may have an internal structure and
    * Ports.
    */
    ElementType[ElementType["class"] = 2] = "class";
    /**
    * The element is a Comment. A Comment is a textual annotation that can be attached to a set of
    * Elements.
    */
    ElementType[ElementType["comment"] = 3] = "comment";
    /**
    * The element is a DataType. A DataType is similar to a Class; however, instances of data type are
    * identified only by their value. If two data types have the same value, the instances are considered
    * identical.
    */
    ElementType[ElementType["dataType"] = 4] = "dataType";
    /**
    * The element is a Enumeration. An Enumeration is a DataType whose values are enumerated in the model
    * as EnumerationLiterals.
    */
    ElementType[ElementType["enumeration"] = 5] = "enumeration";
    /**
    * The element is a EnumerationLiteral. An EnumerationLiteral is a user-defined data value for an
    * Enumeration.
    */
    ElementType[ElementType["enumerationLiteral"] = 6] = "enumerationLiteral";
    /**
    * The element is a Generalization. A Generalization is a taxonomic relationship between a more general
    * Classifier and a more specific Classifier. Each instance of the specific Classifier is also an
    * instance of the general Classifier.The specific Classifier inherits the features of the more general
    * Classifier. A Generalization is owned by the specific Classifier.
    */
    ElementType[ElementType["generalization"] = 7] = "generalization";
    /**
    * Alias for ElementType.interface in case the reserved 'interface' is not allowed.
    */
    ElementType[ElementType["_interface"] = 8] = "_interface";
    /**
    * The element is a Interface. Interfaces declare coherent services that are implemented by
    * BehavioredClassifiers that implement the Interfaces via InterfaceRealizations.
    */
    ElementType[ElementType["interface"] = 8] = "interface";
    /**
    * The element is a InterfaceRealization. An InterfaceRealization is a specialized realization
    * relationship between a BehavioredClassifier and an Interface. This relationship signifies that the
    * realizing BehavioredClassifier conforms to the contract specified by the Interface.
    */
    ElementType[ElementType["interfaceRealization"] = 9] = "interfaceRealization";
    /**
    * The element is a LiteralBoolean. A LiteralBoolean is a specification of a Boolean value.
    */
    ElementType[ElementType["literalBoolean"] = 10] = "literalBoolean";
    /**
    * The element is a LiteralInteger. A LiteralInteger is a specification of an Integer value.
    */
    ElementType[ElementType["literalInteger"] = 11] = "literalInteger";
    /**
    * The element is a LiteralNull. A LiteralNull specifies the lack of a value.
    */
    ElementType[ElementType["literalNull"] = 12] = "literalNull";
    /**
    * The element is a LiteralReal. A LiteralReal is a specification of a Real value.
    */
    ElementType[ElementType["literalReal"] = 13] = "literalReal";
    /**
    * The element is a LiteralString. A LiteralString is a specification of a String value.
    */
    ElementType[ElementType["literalString"] = 14] = "literalString";
    /**
    * The element is a LiteralUnlimitedNatural. A LiteralUnlimitedNatural is a specification of an
    * UnlimitedNatural number.
    */
    ElementType[ElementType["literalUnlimitedNatural"] = 15] = "literalUnlimitedNatural";
    /**
    * The element is a Model. Represents the top-level package.
    */
    ElementType[ElementType["model"] = 16] = "model";
    /**
    * The element is a Operation. An Operation is a BehavioralFeature of a Classifier that specifies the
    * name, type, parameters, and constraints for invoking an associated Behavior. An Operation may invoke
    * both the execution of method behaviors as well as other behavioral responses.
    */
    ElementType[ElementType["operation"] = 17] = "operation";
    /**
    * The element is a Package. A package is used to group elements, and provides a namespace for the
    * grouped elements.
    * A package can have one or more profile applications to indicate which profiles have been applied.
    * Because a profile is a package, it is possible to apply a profile not only to packages, but also to
    * profiles.
    */
    ElementType[ElementType["package"] = 18] = "package";
    /**
    * The element is a Parameter. A Parameter is a specification of an argument used to pass information
    * into or out of an invocation of a BehavioralFeature. Parameters can be treated as
    * ConnectableElements within Collaborations.
    */
    ElementType[ElementType["parameter"] = 19] = "parameter";
    /**
    * The element is a PrimitiveType. A PrimitiveType defines a predefined DataType, without any
    * substructure. A PrimitiveType may have an algebra and operations defined outside of UML, for
    * example, mathematically.
    */
    ElementType[ElementType["primitiveType"] = 20] = "primitiveType";
    /**
    * The element is a Profile. Metamodel customizations are defined in a profile, which is then applied
    * to a package. A profile can define classes, stereotypes, data types, primitive types, enumerations.
    * Stereotypes are specific metaclasses, tagged values are standard metaattributes, and profiles are
    * specific kinds of packages.
    */
    ElementType[ElementType["profile"] = 21] = "profile";
    /**
    * The element is a Property. A Property is a StructuralFeature. A Property related by ownedAttribute
    * to a Classifier (other than an association) represents an attribute and might also represent an
    * association end. It relates an instance of the Classifier to a value or set of values of the type of
    * the attribute. A Property related by memberEnd to an Association represents an end of the
    * Association. The type of the Property is the type of the end of the Association.
    */
    ElementType[ElementType["property"] = 22] = "property";
    /**
    * The element is a Stereotype. Stereotype is a profile class which defines how an existing metaclass
    * may be extended as part of a profile. It enables the use of a platform or domain specific
    * terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
    */
    ElementType[ElementType["stereotype"] = 23] = "stereotype";
})(ElementType || (ElementType = {}));
/**
 * UnlimitedNatural is a primitive type representing unlimited natural values.
 */
export class UnlimitedNatural {
    constructor(value) {
        /**
         * Contains the known numeric value of this UnlimitedNatural. This is only a valid value if IsInfinity is false.
         */
        this.Value = null;
        if (typeof value == 'string') {
            if (value === "*")
                this.IsInfinity = true;
            else {
                this.IsInfinity = false;
                this.Value = Number.parseInt(value);
            }
        }
        else { // value is a number
            this.IsInfinity = false;
            this.Value = value;
        }
    }
    stringValue() {
        if (this.IsInfinity)
            return "*";
        return this.Value ? this.Value.toString() : null;
    }
    equals(other) {
        return (other != null)
            && (other.IsInfinity == this.IsInfinity)
            && (other.Value === this.Value);
    }
}
/**
* VisibilityKind is an enumeration type that defines literals to determine the visibility of Elements
* in a model.
*/
export var VisibilityKind;
(function (VisibilityKind) {
    /**
    * A Named Element with public visibility is visible to all elements that can access the contents of
    * the Namespace that owns it.
    */
    VisibilityKind[VisibilityKind["public"] = 1] = "public";
    /**
    * A NamedElement with private visibility is only visible inside the Namespace that owns it.
    */
    VisibilityKind[VisibilityKind["private"] = 2] = "private";
    /**
    * A NamedElement with protected visibility is visible to Elements that have a generalization
    * relationship to the Namespace that owns it.
    */
    VisibilityKind[VisibilityKind["protected"] = 3] = "protected";
    /**
    * A NamedElement with package visibility is visible to all Elements within the nearest enclosing
    * Package (given that other owning Elements have proper visibility). Outside the nearest enclosing
    * Package, a NamedElement marked as having package visibility is not visible. Only NamedElements that
    * are not owned by Packages can be marked as having package visibility.
    */
    VisibilityKind[VisibilityKind["package"] = 4] = "package";
})(VisibilityKind || (VisibilityKind = {}));
/**
* ParameterDirectionKind is an Enumeration that defines literals used to specify direction of
* parameters.
*/
export var ParameterDirectionKind;
(function (ParameterDirectionKind) {
    /**
    * Indicates that Parameter values are passed in by the caller.
    */
    ParameterDirectionKind[ParameterDirectionKind["in"] = 1] = "in";
    /**
    * Indicates that Parameter values are passed in by the caller and (possibly different) values passed
    * out to the caller.
    */
    ParameterDirectionKind[ParameterDirectionKind["inout"] = 2] = "inout";
    /**
    * Indicates that Parameter values are passed out to the caller.
    */
    ParameterDirectionKind[ParameterDirectionKind["out"] = 3] = "out";
    /**
    * Indicates that Parameter values are passed as return values back to the caller.
    */
    ParameterDirectionKind[ParameterDirectionKind["return"] = 4] = "return";
})(ParameterDirectionKind || (ParameterDirectionKind = {}));
export var DocumentLocationKind;
(function (DocumentLocationKind) {
    DocumentLocationKind[DocumentLocationKind["local"] = 1] = "local";
    DocumentLocationKind[DocumentLocationKind["npm"] = 2] = "npm";
})(DocumentLocationKind || (DocumentLocationKind = {}));
/**
* AggregationKind is an Enumeration for specifying the kind of aggregation of a Property.
*/
export var AggregationKind;
(function (AggregationKind) {
    /**
    * Indicates that the Property has no aggregation.
    */
    AggregationKind[AggregationKind["none"] = 1] = "none";
    /**
    * Indicates that the Property has shared aggregation.
    */
    AggregationKind[AggregationKind["shared"] = 2] = "shared";
    /**
    * Indicates that the Property is aggregated compositely, i.e., the composite object has responsibility
    * for the existence and storage of the composed objects (parts).
    */
    AggregationKind[AggregationKind["composite"] = 3] = "composite";
})(AggregationKind || (AggregationKind = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJmYWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcmZhY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7RUFNRTtBQUVGOzs7O0VBSUU7QUFFRjs7O0VBR0U7QUFDRixNQUFNLENBQU4sSUFBWSxXQXNJWDtBQXRJRCxXQUFZLFdBQVc7SUFDdEI7O01BRUU7SUFDRiwyREFBZSxDQUFBO0lBQ2Y7O01BRUU7SUFDRixpREFBVSxDQUFBO0lBQ1Y7Ozs7TUFJRTtJQUNGLCtDQUFTLENBQUE7SUFDVDs7O01BR0U7SUFDRixtREFBVyxDQUFBO0lBQ1g7Ozs7TUFJRTtJQUNGLHFEQUFZLENBQUE7SUFDWjs7O01BR0U7SUFDRiwyREFBZSxDQUFBO0lBQ2Y7OztNQUdFO0lBQ0YseUVBQXNCLENBQUE7SUFDdEI7Ozs7O01BS0U7SUFDRixpRUFBa0IsQ0FBQTtJQUNsQjs7TUFFRTtJQUNGLHlEQUFjLENBQUE7SUFDZDs7O01BR0U7SUFDRix1REFBYSxDQUFBO0lBQ2I7Ozs7TUFJRTtJQUNGLDZFQUF3QixDQUFBO0lBQ3hCOztNQUVFO0lBQ0Ysa0VBQW1CLENBQUE7SUFDbkI7O01BRUU7SUFDRixrRUFBbUIsQ0FBQTtJQUNuQjs7TUFFRTtJQUNGLDREQUFnQixDQUFBO0lBQ2hCOztNQUVFO0lBQ0YsNERBQWdCLENBQUE7SUFDaEI7O01BRUU7SUFDRixnRUFBa0IsQ0FBQTtJQUNsQjs7O01BR0U7SUFDRixvRkFBNEIsQ0FBQTtJQUM1Qjs7TUFFRTtJQUNGLGdEQUFVLENBQUE7SUFDVjs7OztNQUlFO0lBQ0Ysd0RBQWMsQ0FBQTtJQUNkOzs7Ozs7TUFNRTtJQUNGLG9EQUFZLENBQUE7SUFDWjs7OztNQUlFO0lBQ0Ysd0RBQWMsQ0FBQTtJQUNkOzs7O01BSUU7SUFDRixnRUFBa0IsQ0FBQTtJQUNsQjs7Ozs7TUFLRTtJQUNGLG9EQUFZLENBQUE7SUFDWjs7Ozs7O01BTUU7SUFDRixzREFBYSxDQUFBO0lBQ2I7Ozs7TUFJRTtJQUNGLDBEQUFlLENBQUE7QUFDaEIsQ0FBQyxFQXRJVyxXQUFXLEtBQVgsV0FBVyxRQXNJdEI7QUFHRDs7R0FFRztBQUNILE1BQU07SUFXRixZQUFZLEtBQXNCO1FBTGxDOztXQUVHO1FBQ0ksVUFBSyxHQUEyQixJQUFJLENBQUM7UUFHeEMsSUFBSSxPQUFPLEtBQUssSUFBSSxRQUFRLEVBQUU7WUFDMUIsSUFBSSxLQUFLLEtBQUssR0FBRztnQkFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztpQkFDckM7Z0JBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN2QztTQUNKO2FBQU0sRUFBRSxvQkFBb0I7WUFDekIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7WUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7U0FDdEI7SUFDTCxDQUFDO0lBRU0sV0FBVztRQUNkLElBQUksSUFBSSxDQUFDLFVBQVU7WUFBRSxPQUFPLEdBQUcsQ0FBQztRQUNoQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNyRCxDQUFDO0lBRU0sTUFBTSxDQUFDLEtBQXVCO1FBQ2pDLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDO2VBQ2YsQ0FBQyxLQUFLLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUM7ZUFDckMsQ0FBQyxLQUFLLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxDQUFDO0NBQ0o7QUFHRDs7O0VBR0U7QUFDRixNQUFNLENBQU4sSUFBWSxjQXVCWDtBQXZCRCxXQUFZLGNBQWM7SUFFekI7OztNQUdFO0lBQ0YsdURBQVUsQ0FBQTtJQUNWOztNQUVFO0lBQ0YseURBQVcsQ0FBQTtJQUNYOzs7TUFHRTtJQUNGLDZEQUFhLENBQUE7SUFDYjs7Ozs7TUFLRTtJQUNGLHlEQUFXLENBQUE7QUFDWixDQUFDLEVBdkJXLGNBQWMsS0FBZCxjQUFjLFFBdUJ6QjtBQThpQkQ7OztFQUdFO0FBQ0YsTUFBTSxDQUFOLElBQVksc0JBbUJYO0FBbkJELFdBQVksc0JBQXNCO0lBRWpDOztNQUVFO0lBQ0YsK0RBQU0sQ0FBQTtJQUNOOzs7TUFHRTtJQUNGLHFFQUFTLENBQUE7SUFDVDs7TUFFRTtJQUNGLGlFQUFPLENBQUE7SUFDUDs7TUFFRTtJQUNGLHVFQUFVLENBQUE7QUFDWCxDQUFDLEVBbkJXLHNCQUFzQixLQUF0QixzQkFBc0IsUUFtQmpDO0FBK1JELE1BQU0sQ0FBTixJQUFZLG9CQUlYO0FBSkQsV0FBWSxvQkFBb0I7SUFFL0IsaUVBQVMsQ0FBQTtJQUNULDZEQUFPLENBQUE7QUFDUixDQUFDLEVBSlcsb0JBQW9CLEtBQXBCLG9CQUFvQixRQUkvQjtBQWtERDs7RUFFRTtBQUNGLE1BQU0sQ0FBTixJQUFZLGVBZVg7QUFmRCxXQUFZLGVBQWU7SUFFMUI7O01BRUU7SUFDRixxREFBUSxDQUFBO0lBQ1I7O01BRUU7SUFDRix5REFBVSxDQUFBO0lBQ1Y7OztNQUdFO0lBQ0YsK0RBQWEsQ0FBQTtBQUNkLENBQUMsRUFmVyxlQUFlLEtBQWYsZUFBZSxRQWUxQiJ9