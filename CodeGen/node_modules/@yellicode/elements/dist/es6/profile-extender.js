/*
 * Copyright (c) 2019 Yellicode
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
import { StringUtility } from '@yellicode/core';
import { ElementTypeUtility } from './utils';
import * as Interfaces from "./interfaces";
import * as Classes from "./classes";
import { ProfileUtility } from './profile-utility';
export class ProfileExtender {
    static applyProfiles(profiles) {
        return; // disabled in favor of modeler-generated profile API code
        // profiles.forEach(p => {
        //     ProfileExtender.applyProfile(p as Interfaces.Profile);
        // })        
    }
    static applyProfile(profile) {
        return; // disabled in favor of modeler-generated profile API code
        // const stereotypes = ProfileUtility.getStereotypes(profile);
        // if (stereotypes.length === 0) 
        //     return;
        // ProfileExtender.addHasProfileGetters(profile);
        // ProfileExtender.addHasStereotypeGetters(stereotypes);
    }
    /**
     * Extends all Package class types with getters for checking if the profile is applied to the Package.
     */
    static addHasProfileGetters(profile) {
        const classTypes = ProfileExtender.getClassTypesByElementType(Interfaces.ElementType.package);
        ProfileExtender.extendTypesWithGetter(classTypes, `hasProfile_${profile.safeName || profile.name}`, function () {
            return ProfileUtility.hasProfileId(this, profile.id);
        });
    }
    /**
     * Extends all extendable class types with getters for checking if a stereotype is applied.
     */
    static addHasStereotypeGetters(stereoTypes) {
        stereoTypes.forEach(st => {
            const metaClasses = ProfileUtility.getMetaClassesExtendedBy(st);
            metaClasses.forEach(metaClass => {
                const classTypes = ProfileExtender.getClassTypesByElementType(metaClass);
                ProfileExtender.extendTypesWithGetter(classTypes, `is_${st.safeName || st.name}`, function () {
                    // console.log(`Checking stereotype ${st.name}`);                   
                    return ProfileUtility.hasStereotypeId(this, st.id);
                });
                ProfileExtender.extendTypesWithGetter(classTypes, `as_${st.safeName || st.name}`, function () {
                    // console.log(`Checking stereotype ${st.name}`);                   
                    return this; // just return the current instance, this getter is just syntactic sugar for the TS compiler
                });
            });
        });
    }
    static addSubElementAccessors(stereoTypes, elementType, elementSubTypes) {
        const classTypes = ProfileExtender.getClassTypesByElementType(elementType);
        ProfileExtender.addSubSelementAccessorsForElementTypes(classTypes, stereoTypes, elementSubTypes);
    }
    /**
     * Adds accessor functions for stereotypes to the package (and model) level, e.g. getMyStereotypeClasses(),
     * getMyStereotypeInterfaces(), etc
     */
    static addPackageStereotypeAccessors(profile, stereoTypes) {
        // We apply the accessors to package types
        const packageTypes = ProfileExtender.getClassTypesByElementType(Interfaces.ElementType.package);
        stereoTypes.forEach(st => {
            // Does the stereotype extend a packageable element? If not, don't add an accessor on the package level.            
            const subPackagedElementTypes = st.extends.filter((ext) => ElementTypeUtility.isPackageableElement(ext.metaClass)).map(ext => ext.metaClass);
            if (subPackagedElementTypes.length === 0)
                return;
            // Add an accessor for each packageable element that the profile extends
            ProfileExtender.addSubSelementAccessorsForElementTypes(packageTypes, stereoTypes, subPackagedElementTypes);
            // Create a generic accessor for all packaged elements having the stereotype applied            
            ProfileExtender.extendTypesWithFunction(packageTypes, `getPackagedElementsOf${st.safeName || st.name}`, function () {
                return ProfileUtility.filterByStereotypeId(this.packagedElements, st.id);
            });
        });
        // Create a accessor for access to packages having this profile applied (e.g. getPackagesOfMyProfile)        
        ProfileExtender.extendTypesWithFunction(packageTypes, `getPackagesOf${profile.safeName || profile.name}`, function () {
            return ProfileUtility.filterByProfileId(this.packagedElements, profile.id);
        });
    }
    /**
     * Extends all classifier types with accessors to profile-specific stereotypes for Operations, Properties etc.
     */
    static addClassifierAccessors(stereoTypes) {
        //  All these types are a MemberedClassifier, so can have Properties (OwnedAttributes) and OwnedOperations    
        const classifierSubTypes = [Interfaces.ElementType.property, Interfaces.ElementType.operation];
        stereoTypes.forEach(st => {
            const memberedClassifiersExtendedByStereotype = st.extends.filter((ext) => ElementTypeUtility.isMemberedClassifier(ext.metaClass));
            memberedClassifiersExtendedByStereotype.forEach((extension) => {
                //  console.info(`Stereotype ${st.name} extends classifier ${StringUtil.capitalize(Interfaces.ElementType[extendedElementType])}`);
                const classTypes = ProfileExtender.getClassTypesByElementType(extension.metaClass);
                ProfileExtender.addSubSelementAccessorsForElementTypes(classTypes, stereoTypes, classifierSubTypes);
            });
        });
    }
    static addSubSelementAccessorsForElementTypes(classTypes, stereoTypes, elementTypes) {
        const classTypesDebugString = classTypes.map(t => t.name).join(', ');
        elementTypes.forEach(subElementType => {
            const stereoTypesExtendingSubType = stereoTypes.filter(s => s.extends.findIndex(t => t.metaClass === subElementType) > -1);
            if (stereoTypesExtendingSubType.length > 0) {
                // console.info(`ProfileExtender: Adding ${StringUtil.capitalize(Interfaces.ElementType[subElementType])} stereotype accessors to ${classTypesDebugString}.`);
            }
            else {
                // There are no Stereotypes that extend the subType, so there is no need to add an accessor
                // console.info(`ProfileExtender: Not adding ${StringUtil.capitalize(Interfaces.ElementType[subElementType])} stereotype accessors to ${classTypesDebugString}. There is no stereotype extending this element type.`);
                return;
            }
            // If this an "Owned" sub element (e.g. OwnedOperations, OwnedAttributes), add a prefix.
            const prefix = ElementTypeUtility.isPackageableElement(subElementType) ? '' : 'Owned';
            stereoTypesExtendingSubType.forEach(st => {
                const pluralElementTypeName = ProfileExtender.getGetPluralElementTypeName(subElementType);
                const functionName = `get${prefix}${pluralElementTypeName}Of${st.safeName || st.name}`; // E.g "getClassesOfMyStereotype"                        
                const accessorFunction = ProfileExtender.getAccessorFunctionForSubElementType(subElementType, st);
                if (accessorFunction) {
                    ProfileExtender.extendTypesWithFunction(classTypes, functionName, accessorFunction);
                }
                else {
                    // console.warn(`Failed adding accessor function '${functionName}' to ${classTypesDebugString}. Sub element type ${Interfaces.ElementType[subElementType]} is not supported.`);                
                }
            });
        });
    }
    static getAccessorFunctionForSubElementType(subElementType, stereoType) {
        if (ElementTypeUtility.isPackageableElement(subElementType)) {
            // E.g. getMyStereotypeClasses
            return function () {
                return ProfileUtility.filterByStereotypeId(this.packagedElements, stereoType.id, subElementType);
            };
        }
        switch (subElementType) {
            case Interfaces.ElementType.property:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedAttributes, stereoType.id);
                };
            case Interfaces.ElementType.operation:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedOperations, stereoType.id);
                };
            case Interfaces.ElementType.parameter:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedParameters, stereoType.id);
                };
            case Interfaces.ElementType.enumerationLiteral:
                return function () {
                    return ProfileUtility.filterByStereotypeId(this.ownedLiterals, stereoType.id);
                };
            default:
                return null;
        }
    }
    static extendTypesWithFunction(classTypes, funcName, func) {
        classTypes.forEach(t => {
            // console.info(`ProfileExtender: Extending type ${t.name} with function '${funcName}'.`);           
            t.prototype[funcName] = func;
        });
    }
    static extendTypesWithGetter(classTypes, propertyName, getter) {
        classTypes.forEach(t => {
            // console.info(`ProfileExtender: Extending type ${t.name} with getter '${propertyName}'.`);
            Object.defineProperty(t.prototype, propertyName, {
                get: getter,
                enumerable: true,
                configurable: true,
            });
        });
    }
    /**
     * Gets the actual Javascript implementation types that match the specified element type.
     */
    static getClassTypesByElementType(elementType) {
        switch (elementType) {
            case Interfaces.ElementType.package:
                return [Classes.Model, Classes.Package];
            case Interfaces.ElementType.class:
                return [Classes.Class];
            case Interfaces.ElementType.dataType:
                return [Classes.DataType, Classes.PrimitiveType];
            case Interfaces.ElementType.interface:
                return [Classes.Interface];
            case Interfaces.ElementType.enumeration:
                return [Classes.Enumeration];
            case Interfaces.ElementType.enumerationLiteral:
                return [Classes.EnumerationLiteral];
            case Interfaces.ElementType.property:
                return [Classes.Property];
            case Interfaces.ElementType.operation:
                return [Classes.Operation];
            case Interfaces.ElementType.parameter:
                return [Classes.Parameter];
            default:
                console.warn(`Failed getting class type(s) for element type '${Interfaces.ElementType[elementType]}'. The element type is not supported.`);
                return [];
        }
    }
    static getGetPluralElementTypeName(elementType) {
        switch (elementType) {
            case Interfaces.ElementType.property:
                return 'Attributes';
            case Interfaces.ElementType.class:
                return 'Classes';
            case Interfaces.ElementType.enumerationLiteral:
                return 'Literals';
            default:
                // By default, add ..s
                var singular = StringUtility.capitalize(Interfaces.ElementType[elementType]);
                return `${singular}s`;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZmlsZS1leHRlbmRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9maWxlLWV4dGVuZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFN0MsT0FBTyxLQUFLLFVBQVUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxLQUFLLE9BQU8sTUFBTSxXQUFXLENBQUM7QUFDckMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRW5ELE1BQU07SUFDSyxNQUFNLENBQUMsYUFBYSxDQUFDLFFBQThCO1FBQ3RELE9BQU8sQ0FBQywwREFBMEQ7UUFFbEUsMEJBQTBCO1FBQzFCLDZEQUE2RDtRQUM3RCxhQUFhO0lBQ2pCLENBQUM7SUFFTyxNQUFNLENBQUMsWUFBWSxDQUFDLE9BQTJCO1FBQ25ELE9BQU8sQ0FBQywwREFBMEQ7UUFFbEUsOERBQThEO1FBQzlELGlDQUFpQztRQUNqQyxjQUFjO1FBRWQsaURBQWlEO1FBQ2pELHdEQUF3RDtJQUM1RCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxNQUFNLENBQUMsb0JBQW9CLENBQUMsT0FBMkI7UUFDM0QsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLDBCQUEwQixDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUYsZUFBZSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxjQUFjLE9BQU8sQ0FBQyxRQUFRLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ2hHLE9BQU8sY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pELENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOztPQUVHO0lB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