(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash'), require('@yellicode/core'), require('toposort')) :
    typeof define === 'function' && define.amd ? define(['exports', 'lodash', '@yellicode/core', 'toposort'], factory) :
    (factory((global['@yellicode/elements'] = {}),global._,global.core,global.toposort));
}(this, (function (exports,_,core,toposort) { 'use strict';

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    const PRIMITIVE_BOOLEAN_ID = "boolean_id";
    const PRIMITIVE_INTEGER_ID = "integer_id";
    const PRIMITIVE_REAL_ID = "real_id";
    const PRIMITIVE_STRING_ID = "string_id";
    const PRIMITIVE_OBJECT_ID = "object_id";
    /**
    * Returns a boolean value indicating if the element is a built in primitive boolean.
    */
    function isPrimitiveBoolean(element) {
        if (!element)
            return false;
        return element.id === PRIMITIVE_BOOLEAN_ID;
    }
    /**
    * Returns a boolean value indicating if the element is a built in primitive integer.
    */
    function isPrimitiveInteger(element) {
        if (!element)
            return false;
        return element.id === PRIMITIVE_INTEGER_ID;
    }
    /**
    * Returns a boolean value indicating if the element is a built in primitive real.
    */
    function isPrimitiveReal(element) {
        if (!element)
            return false;
        return element.id === PRIMITIVE_REAL_ID;
    }
    /**
    * Returns a boolean value indicating if the element is a built in primitive string.
    */
    function isPrimitiveString(element) {
        if (!element)
            return false;
        return element.id === PRIMITIVE_STRING_ID;
    }
    /**
    * Returns a boolean value indicating if the element is a built in primitive object.
    */
    function isPrimitiveObject(element) {
        if (!element)
            return false;
        return element.id === PRIMITIVE_OBJECT_ID;
    }

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    (function (ElementType) {
        /**
        * The element is a Association. Associations represent relationships between classes.
        */
        ElementType[ElementType["association"] = 1] = "association";
        /**
        * Alias for ElementType.class in case the reserved 'class' is not allowed.
        */
        ElementType[ElementType["_class"] = 2] = "_class";
        /**
        * The element is a Class. A Class classifies a set of objects and specifies the features that
        * characterize the structure and behavior of those objects. A Class may have an internal structure and
        * Ports.
        */
        ElementType[ElementType["class"] = 2] = "class";
        /**
        * The element is a Comment. A Comment is a textual annotation that can be attached to a set of
        * Elements.
        */
        ElementType[ElementType["comment"] = 3] = "comment";
        /**
        * The element is a DataType. A DataType is similar to a Class; however, instances of data type are
        * identified only by their value. If two data types have the same value, the instances are considered
        * identical.
        */
        ElementType[ElementType["dataType"] = 4] = "dataType";
        /**
        * The element is a Enumeration. An Enumeration is a DataType whose values are enumerated in the model
        * as EnumerationLiterals.
        */
        ElementType[ElementType["enumeration"] = 5] = "enumeration";
        /**
        * The element is a EnumerationLiteral. An EnumerationLiteral is a user-defined data value for an
        * Enumeration.
        */
        ElementType[ElementType["enumerationLiteral"] = 6] = "enumerationLiteral";
        /**
        * The element is a Generalization. A Generalization is a taxonomic relationship between a more general
        * Classifier and a more specific Classifier. Each instance of the specific Classifier is also an
        * instance of the general Classifier.The specific Classifier inherits the features of the more general
        * Classifier. A Generalization is owned by the specific Classifier.
        */
        ElementType[ElementType["generalization"] = 7] = "generalization";
        /**
        * Alias for ElementType.interface in case the reserved 'interface' is not allowed.
        */
        ElementType[ElementType["_interface"] = 8] = "_interface";
        /**
        * The element is a Interface. Interfaces declare coherent services that are implemented by
        * BehavioredClassifiers that implement the Interfaces via InterfaceRealizations.
        */
        ElementType[ElementType["interface"] = 8] = "interface";
        /**
        * The element is a InterfaceRealization. An InterfaceRealization is a specialized realization
        * relationship between a BehavioredClassifier and an Interface. This relationship signifies that the
        * realizing BehavioredClassifier conforms to the contract specified by the Interface.
        */
        ElementType[ElementType["interfaceRealization"] = 9] = "interfaceRealization";
        /**
        * The element is a LiteralBoolean. A LiteralBoolean is a specification of a Boolean value.
        */
        ElementType[ElementType["literalBoolean"] = 10] = "literalBoolean";
        /**
        * The element is a LiteralInteger. A LiteralInteger is a specification of an Integer value.
        */
        ElementType[ElementType["literalInteger"] = 11] = "literalInteger";
        /**
        * The element is a LiteralNull. A LiteralNull specifies the lack of a value.
        */
        ElementType[ElementType["literalNull"] = 12] = "literalNull";
        /**
        * The element is a LiteralReal. A LiteralReal is a specification of a Real value.
        */
        ElementType[ElementType["literalReal"] = 13] = "literalReal";
        /**
        * The element is a LiteralString. A LiteralString is a specification of a String value.
        */
        ElementType[ElementType["literalString"] = 14] = "literalString";
        /**
        * The element is a LiteralUnlimitedNatural. A LiteralUnlimitedNatural is a specification of an
        * UnlimitedNatural number.
        */
        ElementType[ElementType["literalUnlimitedNatural"] = 15] = "literalUnlimitedNatural";
        /**
        * The element is a Model. Represents the top-level package.
        */
        ElementType[ElementType["model"] = 16] = "model";
        /**
        * The element is a Operation. An Operation is a BehavioralFeature of a Classifier that specifies the
        * name, type, parameters, and constraints for invoking an associated Behavior. An Operation may invoke
        * both the execution of method behaviors as well as other behavioral responses.
        */
        ElementType[ElementType["operation"] = 17] = "operation";
        /**
        * The element is a Package. A package is used to group elements, and provides a namespace for the
        * grouped elements.
        * A package can have one or more profile applications to indicate which profiles have been applied.
        * Because a profile is a package, it is possible to apply a profile not only to packages, but also to
        * profiles.
        */
        ElementType[ElementType["package"] = 18] = "package";
        /**
        * The element is a Parameter. A Parameter is a specification of an argument used to pass information
        * into or out of an invocation of a BehavioralFeature. Parameters can be treated as
        * ConnectableElements within Collaborations.
        */
        ElementType[ElementType["parameter"] = 19] = "parameter";
        /**
        * The element is a PrimitiveType. A PrimitiveType defines a predefined DataType, without any
        * substructure. A PrimitiveType may have an algebra and operations defined outside of UML, for
        * example, mathematically.
        */
        ElementType[ElementType["primitiveType"] = 20] = "primitiveType";
        /**
        * The element is a Profile. Metamodel customizations are defined in a profile, which is then applied
        * to a package. A profile can define classes, stereotypes, data types, primitive types, enumerations.
        * Stereotypes are specific metaclasses, tagged values are standard metaattributes, and profiles are
        * specific kinds of packages.
        */
        ElementType[ElementType["profile"] = 21] = "profile";
        /**
        * The element is a Property. A Property is a StructuralFeature. A Property related by ownedAttribute
        * to a Classifier (other than an association) represents an attribute and might also represent an
        * association end. It relates an instance of the Classifier to a value or set of values of the type of
        * the attribute. A Property related by memberEnd to an Association represents an end of the
        * Association. The type of the Property is the type of the end of the Association.
        */
        ElementType[ElementType["property"] = 22] = "property";
        /**
        * The element is a Stereotype. Stereotype is a profile class which defines how an existing metaclass
        * may be extended as part of a profile. It enables the use of a platform or domain specific
        * terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
        */
        ElementType[ElementType["stereotype"] = 23] = "stereotype";
    })(exports.ElementType || (exports.ElementType = {}));
    /**
     * UnlimitedNatural is a primitive type representing unlimited natural values.
     */
    class UnlimitedNatural {
        constructor(value) {
            /**
             * Contains the known numeric value of this UnlimitedNatural. This is only a valid value if IsInfinity is false.
             */
            this.Value = null;
            if (typeof value == 'string') {
                if (value === "*")
                    this.IsInfinity = true;
                else {
                    this.IsInfinity = false;
                    this.Value = Number.parseInt(value);
                }
            }
            else { // value is a number
                this.IsInfinity = false;
                this.Value = value;
            }
        }
        stringValue() {
            if (this.IsInfinity)
                return "*";
            return this.Value ? this.Value.toString() : null;
        }
        equals(other) {
            return (other != null)
                && (other.IsInfinity == this.IsInfinity)
                && (other.Value === this.Value);
        }
    }
    (function (VisibilityKind) {
        /**
        * A Named Element with public visibility is visible to all elements that can access the contents of
        * the Namespace that owns it.
        */
        VisibilityKind[VisibilityKind["public"] = 1] = "public";
        /**
        * A NamedElement with private visibility is only visible inside the Namespace that owns it.
        */
        VisibilityKind[VisibilityKind["private"] = 2] = "private";
        /**
        * A NamedElement with protected visibility is visible to Elements that have a generalization
        * relationship to the Namespace that owns it.
        */
        VisibilityKind[VisibilityKind["protected"] = 3] = "protected";
        /**
        * A NamedElement with package visibility is visible to all Elements within the nearest enclosing
        * Package (given that other owning Elements have proper visibility). Outside the nearest enclosing
        * Package, a NamedElement marked as having package visibility is not visible. Only NamedElements that
        * are not owned by Packages can be marked as having package visibility.
        */
        VisibilityKind[VisibilityKind["package"] = 4] = "package";
    })(exports.VisibilityKind || (exports.VisibilityKind = {}));
    (function (ParameterDirectionKind) {
        /**
        * Indicates that Parameter values are passed in by the caller.
        */
        ParameterDirectionKind[ParameterDirectionKind["in"] = 1] = "in";
        /**
        * Indicates that Parameter values are passed in by the caller and (possibly different) values passed
        * out to the caller.
        */
        ParameterDirectionKind[ParameterDirectionKind["inout"] = 2] = "inout";
        /**
        * Indicates that Parameter values are passed out to the caller.
        */
        ParameterDirectionKind[ParameterDirectionKind["out"] = 3] = "out";
        /**
        * Indicates that Parameter values are passed as return values back to the caller.
        */
        ParameterDirectionKind[ParameterDirectionKind["return"] = 4] = "return";
    })(exports.ParameterDirectionKind || (exports.ParameterDirectionKind = {}));
    (function (DocumentLocationKind) {
        DocumentLocationKind[DocumentLocationKind["local"] = 1] = "local";
        DocumentLocationKind[DocumentLocationKind["npm"] = 2] = "npm";
    })(exports.DocumentLocationKind || (exports.DocumentLocationKind = {}));
    (function (AggregationKind) {
        /**
        * Indicates that the Property has no aggregation.
        */
        AggregationKind[AggregationKind["none"] = 1] = "none";
        /**
        * Indicates that the Property has shared aggregation.
        */
        AggregationKind[AggregationKind["shared"] = 2] = "shared";
        /**
        * Indicates that the Property is aggregated compositely, i.e., the composite object has responsibility
        * for the existence and storage of the composed objects (parts).
        */
        AggregationKind[AggregationKind["composite"] = 3] = "composite";
    })(exports.AggregationKind || (exports.AggregationKind = {}));

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    class ElementTypeUtility {
        /**
        * Returns true if the elementType is a NamedElement or one of its descendants.
        */
        static isNamedElement(elementType) {
            switch (elementType) {
                case exports.ElementType.association: return true;
                case exports.ElementType.class: return true;
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.enumerationLiteral: return true;
                case exports.ElementType.interface: return true;
                case exports.ElementType.literalBoolean: return true;
                case exports.ElementType.literalInteger: return true;
                case exports.ElementType.literalNull: return true;
                case exports.ElementType.literalReal: return true;
                case exports.ElementType.literalString: return true;
                case exports.ElementType.literalUnlimitedNatural: return true;
                case exports.ElementType.model: return true;
                case exports.ElementType.operation: return true;
                case exports.ElementType.package: return true;
                case exports.ElementType.parameter: return true;
                case exports.ElementType.primitiveType: return true;
                case exports.ElementType.profile: return true;
                case exports.ElementType.property: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a TypedElement or one of its descendants.
        */
        static isTypedElement(elementType) {
            switch (elementType) {
                case exports.ElementType.literalBoolean: return true;
                case exports.ElementType.literalInteger: return true;
                case exports.ElementType.literalNull: return true;
                case exports.ElementType.literalReal: return true;
                case exports.ElementType.literalString: return true;
                case exports.ElementType.literalUnlimitedNatural: return true;
                case exports.ElementType.parameter: return true;
                case exports.ElementType.property: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a ValueSpecification or one of its descendants.
        */
        static isValueSpecification(elementType) {
            switch (elementType) {
                case exports.ElementType.literalBoolean: return true;
                case exports.ElementType.literalInteger: return true;
                case exports.ElementType.literalNull: return true;
                case exports.ElementType.literalReal: return true;
                case exports.ElementType.literalString: return true;
                case exports.ElementType.literalUnlimitedNatural: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a PackageableElement or one of its descendants.
        */
        static isPackageableElement(elementType) {
            switch (elementType) {
                case exports.ElementType.association: return true;
                case exports.ElementType.class: return true;
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.interface: return true;
                case exports.ElementType.model: return true;
                case exports.ElementType.package: return true;
                case exports.ElementType.primitiveType: return true;
                case exports.ElementType.profile: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Type or one of its descendants.
        */
        static isType(elementType) {
            switch (elementType) {
                case exports.ElementType.association: return true;
                case exports.ElementType.class: return true;
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.interface: return true;
                case exports.ElementType.primitiveType: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a RedefinableElement or one of its descendants.
        */
        static isRedefinableElement(elementType) {
            switch (elementType) {
                case exports.ElementType.association: return true;
                case exports.ElementType.class: return true;
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.interface: return true;
                case exports.ElementType.operation: return true;
                case exports.ElementType.primitiveType: return true;
                case exports.ElementType.property: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Classifier or one of its descendants.
        */
        static isClassifier(elementType) {
            switch (elementType) {
                case exports.ElementType.association: return true;
                case exports.ElementType.class: return true;
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.interface: return true;
                case exports.ElementType.primitiveType: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a StructuredClassifier or one of its descendants.
        */
        static isStructuredClassifier(elementType) {
            switch (elementType) {
                case exports.ElementType.class: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a MultiplicityElement or one of its descendants.
        */
        static isMultiplicityElement(elementType) {
            switch (elementType) {
                case exports.ElementType.parameter: return true;
                case exports.ElementType.property: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a OrderedElement or one of its descendants.
        */
        static isOrderedElement(elementType) {
            switch (elementType) {
                case exports.ElementType.enumerationLiteral: return true;
                case exports.ElementType.operation: return true;
                case exports.ElementType.parameter: return true;
                case exports.ElementType.property: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Feature or one of its descendants.
        */
        static isFeature(elementType) {
            switch (elementType) {
                case exports.ElementType.operation: return true;
                case exports.ElementType.property: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a StructuralFeature or one of its descendants.
        */
        static isStructuralFeature(elementType) {
            return elementType === exports.ElementType.property;
        }
        /**
        * Returns true if the elementType is a MemberedClassifier or one of its descendants.
        */
        static isMemberedClassifier(elementType) {
            switch (elementType) {
                case exports.ElementType.class: return true;
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.interface: return true;
                case exports.ElementType.primitiveType: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a BehavioredClassifier or one of its descendants.
        */
        static isBehavioredClassifier(elementType) {
            switch (elementType) {
                case exports.ElementType.class: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Class or one of its descendants.
        */
        static isClass(elementType) {
            switch (elementType) {
                case exports.ElementType.class: return true;
                case exports.ElementType.stereotype: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Stereotype or one of its descendants.
        */
        static isStereotype(elementType) {
            return elementType === exports.ElementType.stereotype;
        }
        /**
        * Returns true if the elementType is a Relationship or one of its descendants.
        */
        static isRelationship(elementType) {
            switch (elementType) {
                case exports.ElementType.association: return true;
                case exports.ElementType.generalization: return true;
                case exports.ElementType.interfaceRealization: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Property or one of its descendants.
        */
        static isProperty(elementType) {
            return elementType === exports.ElementType.property;
        }
        /**
        * Returns true if the elementType is a Package or one of its descendants.
        */
        static isPackage(elementType) {
            switch (elementType) {
                case exports.ElementType.package: return true;
                case exports.ElementType.model: return true;
                case exports.ElementType.profile: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a Profile or one of its descendants.
        */
        static isProfile(elementType) {
            return elementType === exports.ElementType.profile;
        }
        /**
        * Returns true if the elementType is a DataType or one of its descendants.
        */
        static isDataType(elementType) {
            switch (elementType) {
                case exports.ElementType.dataType: return true;
                case exports.ElementType.enumeration: return true;
                case exports.ElementType.primitiveType: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a PrimitiveType or one of its descendants.
        */
        static isPrimitiveType(elementType) {
            return elementType === exports.ElementType.primitiveType;
        }
        /**
        * Returns true if the elementType is a Parameter or one of its descendants.
        */
        static isParameter(elementType) {
            return elementType === exports.ElementType.parameter;
        }
        /**
        * Returns true if the elementType is a BehavioralFeature or one of its descendants.
        */
        static isBehavioralFeature(elementType) {
            return elementType === exports.ElementType.operation;
        }
        /**
        * Returns true if the elementType is a Operation or one of its descendants.
        */
        static isOperation(elementType) {
            return elementType === exports.ElementType.operation;
        }
        /**
        * Returns true if the elementType is a Model or one of its descendants.
        */
        static isModel(elementType) {
            return elementType === exports.ElementType.model;
        }
        /**
        * Returns true if the elementType is a LiteralSpecification or one of its descendants.
        */
        static isLiteralSpecification(elementType) {
            switch (elementType) {
                case exports.ElementType.literalBoolean: return true;
                case exports.ElementType.literalInteger: return true;
                case exports.ElementType.literalNull: return true;
                case exports.ElementType.literalReal: return true;
                case exports.ElementType.literalString: return true;
                case exports.ElementType.literalUnlimitedNatural: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a LiteralUnlimitedNatural or one of its descendants.
        */
        static isLiteralUnlimitedNatural(elementType) {
            return elementType === exports.ElementType.literalUnlimitedNatural;
        }
        /**
        * Returns true if the elementType is a LiteralString or one of its descendants.
        */
        static isLiteralString(elementType) {
            return elementType === exports.ElementType.literalString;
        }
        /**
        * Returns true if the elementType is a LiteralReal or one of its descendants.
        */
        static isLiteralReal(elementType) {
            return elementType === exports.ElementType.literalReal;
        }
        /**
        * Returns true if the elementType is a LiteralNull or one of its descendants.
        */
        static isLiteralNull(elementType) {
            return elementType === exports.ElementType.literalNull;
        }
        /**
        * Returns true if the elementType is a LiteralInteger or one of its descendants.
        */
        static isLiteralInteger(elementType) {
            return elementType === exports.ElementType.literalInteger;
        }
        /**
        * Returns true if the elementType is a LiteralBoolean or one of its descendants.
        */
        static isLiteralBoolean(elementType) {
            return elementType === exports.ElementType.literalBoolean;
        }
        /**
        * Returns true if the elementType is a DirectedRelationship or one of its descendants.
        */
        static isDirectedRelationship(elementType) {
            switch (elementType) {
                case exports.ElementType.generalization: return true;
                case exports.ElementType.interfaceRealization: return true;
                default: return false;
            }
        }
        /**
        * Returns true if the elementType is a InterfaceRealization or one of its descendants.
        */
        static isInterfaceRealization(elementType) {
            return elementType === exports.ElementType.interfaceRealization;
        }
        /**
        * Returns true if the elementType is a Interface or one of its descendants.
        */
        static isInterface(elementType) {
            return elementType === exports.ElementType.interface;
        }
        /**
        * Returns true if the elementType is a Generalization or one of its descendants.
        */
        static isGeneralization(elementType) {
            return elementType === exports.ElementType.generalization;
        }
        /**
        * Returns true if the elementType is a EnumerationLiteral or one of its descendants.
        */
        static isEnumerationLiteral(elementType) {
            return elementType === exports.ElementType.enumerationLiteral;
        }
        /**
        * Returns true if the elementType is a Enumeration or one of its descendants.
        */
        static isEnumeration(elementType) {
            return elementType === exports.ElementType.enumeration;
        }
        /**
        * Returns true if the elementType is a Comment or one of its descendants.
        */
        static isComment(elementType) {
            return elementType === exports.ElementType.comment;
        }
        /**
        * Returns true if the elementType is a Association or one of its descendants.
        */
        static isAssociation(elementType) {
            return elementType === exports.ElementType.association;
        }
    }
    /**
    * Asserts that the element is a NamedElement or one of its descendants.
    */
    function isNamedElement(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isNamedElement(element.elementType);
    }
    /**
    * Asserts that the element is a TypedElement or one of its descendants.
    */
    function isTypedElement(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isTypedElement(element.elementType);
    }
    /**
    * Asserts that the element is a ValueSpecification or one of its descendants.
    */
    function isValueSpecification(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isValueSpecification(element.elementType);
    }
    /**
    * Asserts that the element is a PackageableElement or one of its descendants.
    */
    function isPackageableElement(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isPackageableElement(element.elementType);
    }
    /**
    * Asserts that the element is a Type or one of its descendants.
    */
    function isType(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isType(element.elementType);
    }
    /**
    * Asserts that the element is a RedefinableElement or one of its descendants.
    */
    function isRedefinableElement(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isRedefinableElement(element.elementType);
    }
    /**
    * Asserts that the element is a Classifier or one of its descendants.
    */
    function isClassifier(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isClassifier(element.elementType);
    }
    /**
    * Asserts that the element is a StructuredClassifier or one of its descendants.
    */
    function isStructuredClassifier(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isStructuredClassifier(element.elementType);
    }
    /**
    * Asserts that the element is a MultiplicityElement or one of its descendants.
    */
    function isMultiplicityElement(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isMultiplicityElement(element.elementType);
    }
    /**
    * Asserts that the element is a OrderedElement or one of its descendants.
    */
    function isOrderedElement(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isOrderedElement(element.elementType);
    }
    /**
    * Asserts that the element is a Feature or one of its descendants.
    */
    function isFeature(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isFeature(element.elementType);
    }
    /**
    * Asserts that the element is a StructuralFeature or one of its descendants.
    */
    function isStructuralFeature(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isStructuralFeature(element.elementType);
    }
    /**
    * Asserts that the element is a MemberedClassifier or one of its descendants.
    */
    function isMemberedClassifier(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isMemberedClassifier(element.elementType);
    }
    /**
    * Asserts that the element is a BehavioredClassifier or one of its descendants.
    */
    function isBehavioredClassifier(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isBehavioredClassifier(element.elementType);
    }
    /**
    * Asserts that the element is a Class or one of its descendants.
    */
    function isClass(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isClass(element.elementType);
    }
    /**
    * Asserts that the element is a Stereotype or one of its descendants.
    */
    function isStereotype(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isStereotype(element.elementType);
    }
    /**
    * Asserts that the element is a Relationship or one of its descendants.
    */
    function isRelationship(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isRelationship(element.elementType);
    }
    /**
    * Asserts that the element is a Property or one of its descendants.
    */
    function isProperty(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isProperty(element.elementType);
    }
    /**
    * Asserts that the element is a Package or one of its descendants.
    */
    function isPackage(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isPackage(element.elementType);
    }
    /**
    * Asserts that the element is a Profile or one of its descendants.
    */
    function isProfile(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isProfile(element.elementType);
    }
    /**
    * Asserts that the element is a DataType or one of its descendants.
    */
    function isDataType(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isDataType(element.elementType);
    }
    /**
    * Asserts that the element is a PrimitiveType or one of its descendants.
    */
    function isPrimitiveType(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isPrimitiveType(element.elementType);
    }
    /**
    * Asserts that the element is a Parameter or one of its descendants.
    */
    function isParameter(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isParameter(element.elementType);
    }
    /**
    * Asserts that the element is a BehavioralFeature or one of its descendants.
    */
    function isBehavioralFeature(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isBehavioralFeature(element.elementType);
    }
    /**
    * Asserts that the element is a Operation or one of its descendants.
    */
    function isOperation(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isOperation(element.elementType);
    }
    /**
    * Asserts that the element is a Model or one of its descendants.
    */
    function isModel(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isModel(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralSpecification or one of its descendants.
    */
    function isLiteralSpecification(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralSpecification(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralUnlimitedNatural or one of its descendants.
    */
    function isLiteralUnlimitedNatural(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralUnlimitedNatural(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralString or one of its descendants.
    */
    function isLiteralString(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralString(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralReal or one of its descendants.
    */
    function isLiteralReal(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralReal(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralNull or one of its descendants.
    */
    function isLiteralNull(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralNull(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralInteger or one of its descendants.
    */
    function isLiteralInteger(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralInteger(element.elementType);
    }
    /**
    * Asserts that the element is a LiteralBoolean or one of its descendants.
    */
    function isLiteralBoolean(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isLiteralBoolean(element.elementType);
    }
    /**
    * Asserts that the element is a DirectedRelationship or one of its descendants.
    */
    function isDirectedRelationship(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isDirectedRelationship(element.elementType);
    }
    /**
    * Asserts that the element is a InterfaceRealization or one of its descendants.
    */
    function isInterfaceRealization(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isInterfaceRealization(element.elementType);
    }
    /**
    * Asserts that the element is a Interface or one of its descendants.
    */
    function isInterface(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isInterface(element.elementType);
    }
    /**
    * Asserts that the element is a Generalization or one of its descendants.
    */
    function isGeneralization(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isGeneralization(element.elementType);
    }
    /**
    * Asserts that the element is a EnumerationLiteral or one of its descendants.
    */
    function isEnumerationLiteral(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isEnumerationLiteral(element.elementType);
    }
    /**
    * Asserts that the element is a Enumeration or one of its descendants.
    */
    function isEnumeration(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isEnumeration(element.elementType);
    }
    /**
    * Asserts that the element is a Comment or one of its descendants.
    */
    function isComment(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isComment(element.elementType);
    }
    /**
    * Asserts that the element is a Association or one of its descendants.
    */
    function isAssociation(element) {
        if (!element)
            return false;
        return ElementTypeUtility.isAssociation(element.elementType);
    }

    /*
     * Copyright (c) 2019 Yellicode
     *
     * This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     */
    class ProfileUtility {
        static getStereotypes(profile) {
            if (!profile.packagedElements)
                return [];
            return profile.packagedElements.filter((e) => e.elementType === exports.ElementType.stereotype);
        }
        static hasStereotypeId(element, stereotypeId) {
            if (!element || !element.appliedStereotypes)
                return false;
            return ProfileUtility.hasStereotypeIdRecursive(element.appliedStereotypes, stereotypeId);
        }
        static hasStereotypeIdRecursive(stereotypes, stereotypeId) {
            for (var index = 0; index < stereotypes.length; index++) {
                var stereotype = stereotypes[index];
                if (stereotype.id === stereotypeId)
                    return true;
                // If the stereotype has parents, check these too                        
                const stereotypeGenerals = stereotype.getParents();
                if (stereotypeGenerals.length > 0 && ProfileUtility.hasStereotypeIdRecursive(stereotypeGenerals, stereotypeId)) {
                    return true;
                }
            }
            return false;
        }
        static getMetaClassesExtendedBy(stereotype) {
            // First add the stereotype's own meta classes
            return stereotype.extends.map(ext => ext.metaClass);
        }
        static getAllMetaClassesExtendedBy(stereotype) {
            // First add the stereotype's own meta classes
            const metaClasses = ProfileUtility.getMetaClassesExtendedBy(stereotype);
            // Then add meta classes of the specializing stereotypes
            stereotype.getSpecializations().forEach((derivedStereotype) => {
                derivedStereotype.extends.forEach(extension => {
                    if (metaClasses.indexOf(extension.metaClass) === -1) {
                        metaClasses.push(extension.metaClass);
                    }
                });
            });
            return metaClasses;
        }
        static hasProfileId(pack, profileId) {
            if (!pack || !pack.appliedProfiles)
                return false;
            return pack.appliedProfiles.some((s) => s.id === profileId);
        }
        /**
         * Filters the array of elements by only including the elements that have a particular stereotype applied.
         */
        static filterByStereotypeId(elements, stereotypeId, elementType) {
            if (!elements)
                return [];
            if (elementType) {
                return elements.filter(e => {
                    return e.elementType === elementType && ProfileUtility.hasStereotypeId(e, stereotypeId);
                });
            }
            return elements.filter(e => { return ProfileUtility.hasStereotypeId(e, stereotypeId); });
        }
        /**
         * Filters the array of packageable element by only including the packages that have a particular profile applied.
         */
        static filterByProfileId(elements, profileId) {
            if (!elements)
                return [];
            return elements.filter((e) => e.elementType === exports.ElementType.package &&
                ProfileUtility.hasProfileId(e, profileId));
        }
    }

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    class Element {
        constructor(modelDelegate, owner) {
            this.modelDelegate = modelDelegate;
            this.appliedStereotypes = [];
            this.id = '';
            this.ownedComments = [];
            this.owner = null;
            this.taggedValues = [];
            this.owner = owner;
        }
        /**
        * Gets the text contents of the first comment in the element's owned comments, or an empty string if
        * the element has no comments.
        * @returns {string} The body string of the first comment. If the element has no comments, an empty
        * string is returned.
        */
        getFirstCommentBody() {
            return this.modelDelegate.getFirstCommentBody(this);
        }
    }
    class TaggedValueSpecification {
    }
    class StereotypeExtension {
        constructor() {
            this.isRequired = false;
        }
    }
    class Class extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.class;
            this.appliedStereotypes = [];
            this.generalizations = [];
            this.interfaceRealizations = [];
            this.isAbstract = false;
            this.isActive = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.name = '';
            this.ownedAttributes = [];
            this.ownedOperations = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns both inherited and owned attributes.
        * @returns {elements.Property[]}
        */
        getAllAttributes() {
            return this.modelDelegate.getAllAttributes(this);
        }
        /**
        * Returns both inherited and owned operations. Any inherited operation that has the same signature
        * (having the same name and parameter type order) in an inheriting type is not included.
        * @returns {elements.Operation[]}
        */
        getAllOperations() {
            return this.modelDelegate.getAllOperations(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
        /**
        * Gets the superclasses of a Class, derived from its Generalizations.
        * @returns {elements.Class[]}
        */
        getSuperClasses() {
            return this.modelDelegate.getSuperClasses(this);
        }
    }
    class Stereotype extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.stereotype;
            this.appliedStereotypes = [];
            this.extends = [];
            this.generalizations = [];
            this.interfaceRealizations = [];
            this.isAbstract = false;
            this.isActive = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.name = '';
            this.ownedAttributes = [];
            this.ownedOperations = [];
            this.safeName = '';
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns both inherited and owned attributes.
        * @returns {elements.Property[]}
        */
        getAllAttributes() {
            return this.modelDelegate.getAllAttributes(this);
        }
        /**
        * Returns both inherited and owned operations. Any inherited operation that has the same signature
        * (having the same name and parameter type order) in an inheriting type is not included.
        * @returns {elements.Operation[]}
        */
        getAllOperations() {
            return this.modelDelegate.getAllOperations(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
        /**
        * Gets the superclasses of a Class, derived from its Generalizations.
        * @returns {elements.Class[]}
        */
        getSuperClasses() {
            return this.modelDelegate.getSuperClasses(this);
        }
    }
    class Property extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.property;
            this.aggregation = exports.AggregationKind.none;
            this.appliedStereotypes = [];
            this.defaultValue = null;
            this.isDerived = false;
            this.isDerivedUnion = false;
            this.isID = false;
            this.isLeaf = false;
            this.isNavigable = false;
            this.isOrdered = false;
            this.isReadOnly = false;
            this.isStatic = false;
            this.isUnique = false;
            this.lowerValue = null;
            this.name = '';
            this.order = 0;
            this.taggedValues = [];
            this.type = null;
            this.upperValue = null;
            this.visibility = null;
        }
        get association() {
            return this.modelDelegate.getAssociation(this);
        }
        get lower() {
            return this.modelDelegate.getLower(this);
        }
        get upper() {
            return this.modelDelegate.getUpper(this);
        }
        /**
        * Gets the value of the DefaultValue property.
        * @returns {any} The default value (the type depending on the type of value), or null if no default
        * value can be determined.
        */
        getDefault() {
            return this.modelDelegate.getDefault(this);
        }
        /**
        * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
        * integerValue of lowerValue, if this is given, and 1 otherwise.
        * @returns {number}
        */
        getLowerBound() {
            return this.modelDelegate.getLowerBound(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
        * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
        * @returns {elements.UnlimitedNatural}
        */
        getUpperBound() {
            return this.modelDelegate.getUpperBound(this);
        }
        /**
        * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
        * @returns {boolean}
        */
        isMultivalued() {
            return this.modelDelegate.isMultivalued(this);
        }
        /**
        * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
        * @returns {boolean}
        */
        isOptional() {
            return this.modelDelegate.isOptional(this);
        }
        /**
        * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
        * upper bound of 1 (0..1).
        * @returns {boolean}
        */
        isOptionalAndSinglevalued() {
            return this.modelDelegate.isOptionalAndSinglevalued(this);
        }
        /**
        * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
        * upper bound of 1 (1..1).
        * @returns {boolean}
        */
        isRequiredAndSinglevalued() {
            return this.modelDelegate.isRequiredAndSinglevalued(this);
        }
    }
    class Package extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.package;
            this.appliedProfiles = [];
            this.appliedStereotypes = [];
            this.isNamespaceRoot = false;
            this.name = '';
            this.packagedElements = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Gets all classes that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Class[]}
        */
        getAllClasses() {
            return this.modelDelegate.getAllClasses(this);
        }
        /**
        * Gets all data types that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.DataType[]}
        */
        getAllDataTypes() {
            return this.modelDelegate.getAllDataTypes(this);
        }
        /**
        * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Enumeration[]}
        */
        getAllEnumerations() {
            return this.modelDelegate.getAllEnumerations(this);
        }
        /**
        * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Interface[]}
        */
        getAllInterfaces() {
            return this.modelDelegate.getAllInterfaces(this);
        }
        /**
        * Gets all types that are owned by this Package, including the ones owned by nested packages. This
        * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
        * @returns {elements.Classifier[]} A subset of PackagedElements.
        */
        getAllTypes() {
            return this.modelDelegate.getAllTypes(this);
        }
        /**
        * Gets all classes that are owned by this Package.
        * @returns {elements.Class[]} A subset of PackagedElements.
        */
        getClasses() {
            return this.modelDelegate.getClasses(this);
        }
        /**
        * Gets all data types that are owned by this Package.
        * @returns {elements.DataType[]} A subset of PackagedElements.
        */
        getDataTypes() {
            return this.modelDelegate.getDataTypes(this);
        }
        /**
        * Gets all enumerations that are owned by this Package.
        * @returns {elements.Enumeration[]} A subset of PackagedElements.
        */
        getEnumerations() {
            return this.modelDelegate.getEnumerations(this);
        }
        /**
        * Gets all interfaces that are owned by this Package.
        * @returns {elements.Interface[]} A subset of PackagedElements.
        */
        getInterfaces() {
            return this.modelDelegate.getInterfaces(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that are owned by this Package.
        * @returns {elements.Package[]} A subset of PackagedElements.
        */
        getNestedPackages() {
            return this.modelDelegate.getNestedPackages(this);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all types that are owned by this Package. This includes the following types of elements: Class,
        * Interface, DataType, PrimitiveType and Enumeration.
        * @returns {elements.Classifier[]} A subset of PackagedElements.
        */
        getTypes() {
            return this.modelDelegate.getTypes(this);
        }
    }
    class Profile extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.profile;
            this.appliedProfiles = [];
            this.appliedStereotypes = [];
            this.isNamespaceRoot = false;
            this.name = '';
            this.packagedElements = [];
            this.safeName = '';
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Gets all classes that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Class[]}
        */
        getAllClasses() {
            return this.modelDelegate.getAllClasses(this);
        }
        /**
        * Gets all data types that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.DataType[]}
        */
        getAllDataTypes() {
            return this.modelDelegate.getAllDataTypes(this);
        }
        /**
        * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Enumeration[]}
        */
        getAllEnumerations() {
            return this.modelDelegate.getAllEnumerations(this);
        }
        /**
        * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Interface[]}
        */
        getAllInterfaces() {
            return this.modelDelegate.getAllInterfaces(this);
        }
        /**
        * Gets all types that are owned by this Package, including the ones owned by nested packages. This
        * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
        * @returns {elements.Classifier[]} A subset of PackagedElements.
        */
        getAllTypes() {
            return this.modelDelegate.getAllTypes(this);
        }
        /**
        * Gets all classes that are owned by this Package.
        * @returns {elements.Class[]} A subset of PackagedElements.
        */
        getClasses() {
            return this.modelDelegate.getClasses(this);
        }
        /**
        * Gets all data types that are owned by this Package.
        * @returns {elements.DataType[]} A subset of PackagedElements.
        */
        getDataTypes() {
            return this.modelDelegate.getDataTypes(this);
        }
        /**
        * Gets all enumerations that are owned by this Package.
        * @returns {elements.Enumeration[]} A subset of PackagedElements.
        */
        getEnumerations() {
            return this.modelDelegate.getEnumerations(this);
        }
        /**
        * Gets all interfaces that are owned by this Package.
        * @returns {elements.Interface[]} A subset of PackagedElements.
        */
        getInterfaces() {
            return this.modelDelegate.getInterfaces(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that are owned by this Package.
        * @returns {elements.Package[]} A subset of PackagedElements.
        */
        getNestedPackages() {
            return this.modelDelegate.getNestedPackages(this);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all types that are owned by this Package. This includes the following types of elements: Class,
        * Interface, DataType, PrimitiveType and Enumeration.
        * @returns {elements.Classifier[]} A subset of PackagedElements.
        */
        getTypes() {
            return this.modelDelegate.getTypes(this);
        }
    }
    class DataType extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.dataType;
            this.appliedStereotypes = [];
            this.generalizations = [];
            this.isAbstract = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.name = '';
            this.ownedAttributes = [];
            this.ownedOperations = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns both inherited and owned attributes.
        * @returns {elements.Property[]}
        */
        getAllAttributes() {
            return this.modelDelegate.getAllAttributes(this);
        }
        /**
        * Returns both inherited and owned operations. Any inherited operation that has the same signature
        * (having the same name and parameter type order) in an inheriting type is not included.
        * @returns {elements.Operation[]}
        */
        getAllOperations() {
            return this.modelDelegate.getAllOperations(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
    }
    class PrimitiveType extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.primitiveType;
            this.appliedStereotypes = [];
            this.generalizations = [];
            this.isAbstract = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.name = '';
            this.ownedAttributes = [];
            this.ownedOperations = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns both inherited and owned attributes.
        * @returns {elements.Property[]}
        */
        getAllAttributes() {
            return this.modelDelegate.getAllAttributes(this);
        }
        /**
        * Returns both inherited and owned operations. Any inherited operation that has the same signature
        * (having the same name and parameter type order) in an inheriting type is not included.
        * @returns {elements.Operation[]}
        */
        getAllOperations() {
            return this.modelDelegate.getAllOperations(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
    }
    class Parameter extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.parameter;
            this.appliedStereotypes = [];
            this.defaultValue = null;
            this.direction = exports.ParameterDirectionKind.in;
            this.isException = false;
            this.isOrdered = false;
            this.isStream = false;
            this.isUnique = false;
            this.lowerValue = null;
            this.name = '';
            this.order = 0;
            this.taggedValues = [];
            this.type = null;
            this.upperValue = null;
            this.visibility = null;
        }
        get lower() {
            return this.modelDelegate.getLower(this);
        }
        get upper() {
            return this.modelDelegate.getUpper(this);
        }
        /**
        * Gets the value of the DefaultValue property.
        * @returns {any} The default value (the type depending on the type of value), or null if no default
        * value can be determined.
        */
        getDefault() {
            return this.modelDelegate.getDefault(this);
        }
        /**
        * The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
        * integerValue of lowerValue, if this is given, and 1 otherwise.
        * @returns {number}
        */
        getLowerBound() {
            return this.modelDelegate.getLowerBound(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
        * unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
        * @returns {elements.UnlimitedNatural}
        */
        getUpperBound() {
            return this.modelDelegate.getUpperBound(this);
        }
        /**
        * The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
        * @returns {boolean}
        */
        isMultivalued() {
            return this.modelDelegate.isMultivalued(this);
        }
        /**
        * The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
        * @returns {boolean}
        */
        isOptional() {
            return this.modelDelegate.isOptional(this);
        }
        /**
        * The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
        * upper bound of 1 (0..1).
        * @returns {boolean}
        */
        isOptionalAndSinglevalued() {
            return this.modelDelegate.isOptionalAndSinglevalued(this);
        }
        /**
        * The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
        * upper bound of 1 (1..1).
        * @returns {boolean}
        */
        isRequiredAndSinglevalued() {
            return this.modelDelegate.isRequiredAndSinglevalued(this);
        }
    }
    class Operation extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.operation;
            this.appliedStereotypes = [];
            this.isAbstract = false;
            this.isConstructor = false;
            this.isLeaf = false;
            this.isQuery = false;
            this.isStatic = false;
            this.name = '';
            this.order = 0;
            this.ownedParameters = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get lower() {
            return this.modelDelegate.getLower(this);
        }
        get upper() {
            return this.modelDelegate.getUpper(this);
        }
        /**
        * Returns the ownedParameters with direction in and inout.
        * @returns {elements.Parameter[]}
        */
        getInputParameters() {
            return this.modelDelegate.getInputParameters(this);
        }
        /**
        * The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
        * integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
        * return result for this Operation.
        * @returns {number}
        */
        getLowerBound() {
            return this.modelDelegate.getLowerBound(this);
        }
        /**
        * Returns the ownedParameters with direction out, inout, or return.
        * @returns {elements.Parameter[]}
        */
        getOutputParameters() {
            return this.modelDelegate.getOutputParameters(this);
        }
        /**
        * Gets the operation's return parameter, if it has one.
        * @returns {elements.Parameter}
        */
        getReturnParameter() {
            return this.modelDelegate.getReturnParameter(this);
        }
        /**
        * Gets the type of the operation's return parameter, if it has any.
        * @returns {elements.Type}
        */
        getReturnType() {
            return this.modelDelegate.getReturnType(this);
        }
        /**
        * The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
        * an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
        * This information is derived from the return result for this Operation.
        * @returns {elements.UnlimitedNatural}
        */
        getUpperBound() {
            return this.modelDelegate.getUpperBound(this);
        }
        /**
        * The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
        * @returns {boolean}
        */
        isMultivalued() {
            return this.modelDelegate.isMultivalued(this);
        }
        /**
        * The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
        * @returns {boolean}
        */
        isOptional() {
            return this.modelDelegate.isOptional(this);
        }
        /**
        * The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
        * 1 (0..1).
        * @returns {boolean}
        */
        isOptionalAndSinglevalued() {
            return this.modelDelegate.isOptionalAndSinglevalued(this);
        }
    }
    class Model extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.model;
            this.appliedProfiles = [];
            this.appliedStereotypes = [];
            this.isNamespaceRoot = false;
            this.name = '';
            this.packagedElements = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Gets all classes that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Class[]}
        */
        getAllClasses() {
            return this.modelDelegate.getAllClasses(this);
        }
        /**
        * Gets all data types that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.DataType[]}
        */
        getAllDataTypes() {
            return this.modelDelegate.getAllDataTypes(this);
        }
        /**
        * Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Enumeration[]}
        */
        getAllEnumerations() {
            return this.modelDelegate.getAllEnumerations(this);
        }
        /**
        * Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
        * @returns {elements.Interface[]}
        */
        getAllInterfaces() {
            return this.modelDelegate.getAllInterfaces(this);
        }
        /**
        * Gets all types that are owned by this Package, including the ones owned by nested packages. This
        * includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
        * @returns {elements.Classifier[]} A subset of PackagedElements.
        */
        getAllTypes() {
            return this.modelDelegate.getAllTypes(this);
        }
        /**
        * Gets all classes that are owned by this Package.
        * @returns {elements.Class[]} A subset of PackagedElements.
        */
        getClasses() {
            return this.modelDelegate.getClasses(this);
        }
        /**
        * Gets all data types that are owned by this Package.
        * @returns {elements.DataType[]} A subset of PackagedElements.
        */
        getDataTypes() {
            return this.modelDelegate.getDataTypes(this);
        }
        /**
        * Gets all enumerations that are owned by this Package.
        * @returns {elements.Enumeration[]} A subset of PackagedElements.
        */
        getEnumerations() {
            return this.modelDelegate.getEnumerations(this);
        }
        /**
        * Gets all interfaces that are owned by this Package.
        * @returns {elements.Interface[]} A subset of PackagedElements.
        */
        getInterfaces() {
            return this.modelDelegate.getInterfaces(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that are owned by this Package.
        * @returns {elements.Package[]} A subset of PackagedElements.
        */
        getNestedPackages() {
            return this.modelDelegate.getNestedPackages(this);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all types that are owned by this Package. This includes the following types of elements: Class,
        * Interface, DataType, PrimitiveType and Enumeration.
        * @returns {elements.Classifier[]} A subset of PackagedElements.
        */
        getTypes() {
            return this.modelDelegate.getTypes(this);
        }
    }
    class LiteralUnlimitedNatural extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.literalUnlimitedNatural;
            this.appliedStereotypes = [];
            this.name = '';
            this.taggedValues = [];
            this.type = null;
            this.visibility = null;
        }
        /**
        * Gets the string representation of the value.
        * @returns {string}
        */
        getStringValue() {
            return this.modelDelegate.getStringValue(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
        * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
        * ValueSpecification.
        */
        getValue() {
            return this.modelDelegate.getValue(this);
        }
    }
    class LiteralString extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.literalString;
            this.appliedStereotypes = [];
            this.name = '';
            this.taggedValues = [];
            this.type = null;
            this.value = '';
            this.visibility = null;
        }
        /**
        * Gets the string representation of the value.
        * @returns {string}
        */
        getStringValue() {
            return this.modelDelegate.getStringValue(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
        * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
        * ValueSpecification.
        */
        getValue() {
            return this.modelDelegate.getValue(this);
        }
    }
    class LiteralReal extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.literalReal;
            this.appliedStereotypes = [];
            this.name = '';
            this.taggedValues = [];
            this.type = null;
            this.value = 0;
            this.visibility = null;
        }
        /**
        * Gets the string representation of the value.
        * @returns {string}
        */
        getStringValue() {
            return this.modelDelegate.getStringValue(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
        * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
        * ValueSpecification.
        */
        getValue() {
            return this.modelDelegate.getValue(this);
        }
    }
    class LiteralNull extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.literalNull;
            this.appliedStereotypes = [];
            this.name = '';
            this.taggedValues = [];
            this.type = null;
            this.visibility = null;
        }
        /**
        * Gets the string representation of the value.
        * @returns {string}
        */
        getStringValue() {
            return this.modelDelegate.getStringValue(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
        * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
        * ValueSpecification.
        */
        getValue() {
            return this.modelDelegate.getValue(this);
        }
    }
    class LiteralInteger extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.literalInteger;
            this.appliedStereotypes = [];
            this.name = '';
            this.taggedValues = [];
            this.type = null;
            this.value = 0;
            this.visibility = null;
        }
        /**
        * Gets the string representation of the value.
        * @returns {string}
        */
        getStringValue() {
            return this.modelDelegate.getStringValue(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
        * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
        * ValueSpecification.
        */
        getValue() {
            return this.modelDelegate.getValue(this);
        }
    }
    class LiteralBoolean extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.literalBoolean;
            this.appliedStereotypes = [];
            this.name = '';
            this.taggedValues = [];
            this.type = null;
            this.value = false;
            this.visibility = null;
        }
        /**
        * Gets the string representation of the value.
        * @returns {string}
        */
        getStringValue() {
            return this.modelDelegate.getStringValue(this);
        }
        /**
        * Gets the name of the typed element's type.
        * @returns {string} The type name, or an empty string if the element has no type.
        */
        getTypeName() {
            return this.modelDelegate.getTypeName(this);
        }
        /**
        * Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
        * @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
        * ValueSpecification.
        */
        getValue() {
            return this.modelDelegate.getValue(this);
        }
    }
    class InterfaceRealization extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.interfaceRealization;
            this.appliedStereotypes = [];
            this.taggedValues = [];
        }
    }
    class Interface extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.interface;
            this.appliedStereotypes = [];
            this.generalizations = [];
            this.isAbstract = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.name = '';
            this.ownedAttributes = [];
            this.ownedOperations = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns both inherited and owned attributes.
        * @returns {elements.Property[]}
        */
        getAllAttributes() {
            return this.modelDelegate.getAllAttributes(this);
        }
        /**
        * Returns both inherited and owned operations. Any inherited operation that has the same signature
        * (having the same name and parameter type order) in an inheriting type is not included.
        * @returns {elements.Operation[]}
        */
        getAllOperations() {
            return this.modelDelegate.getAllOperations(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
    }
    class Generalization extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.generalization;
            this.appliedStereotypes = [];
            this.isSubstitutable = false;
            this.taggedValues = [];
        }
        get specific() {
            return this.modelDelegate.getSpecific(this);
        }
    }
    class EnumerationLiteral extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.enumerationLiteral;
            this.appliedStereotypes = [];
            this.name = '';
            this.order = 0;
            this.taggedValues = [];
            this.visibility = null;
        }
        get enumeration() {
            return this.modelDelegate.getEnumeration(this);
        }
        /**
        * Gets the value of the Specification property.
        * @returns {any} The default value (the type depending on the type of value), or null if no default
        * value can be determined.
        */
        getSpecificationValue() {
            return this.modelDelegate.getSpecificationValue(this);
        }
    }
    class Enumeration extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.enumeration;
            this.appliedStereotypes = [];
            this.baseType = null;
            this.generalizations = [];
            this.isAbstract = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.name = '';
            this.ownedAttributes = [];
            this.ownedLiterals = [];
            this.ownedOperations = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns both inherited and owned attributes.
        * @returns {elements.Property[]}
        */
        getAllAttributes() {
            return this.modelDelegate.getAllAttributes(this);
        }
        /**
        * Returns both inherited and owned operations. Any inherited operation that has the same signature
        * (having the same name and parameter type order) in an inheriting type is not included.
        * @returns {elements.Operation[]}
        */
        getAllOperations() {
            return this.modelDelegate.getAllOperations(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
    }
    class DocumentReference {
        constructor() {
            this.name = '';
            this.path = '';
        }
    }
    class Comment extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.comment;
            this.appliedStereotypes = [];
            this.body = '';
            this.taggedValues = [];
        }
    }
    class Association extends Element {
        constructor(modelDelegate, owner) {
            super(modelDelegate, owner);
            this.elementType = exports.ElementType.association;
            this.appliedStereotypes = [];
            this.generalizations = [];
            this.isAbstract = false;
            this.isFinalSpecialization = false;
            this.isInferred = false;
            this.isLeaf = false;
            this.memberEnds = [];
            this.name = '';
            this.ownedEnds = [];
            this.taggedValues = [];
            this.visibility = null;
        }
        get package() {
            return this.modelDelegate.getPackage(this);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
        * specific classifiers will appear before more general classifiers.
        * @returns {elements.Classifier[]}
        */
        getAllParents() {
            return this.modelDelegate.getAllParents(this);
        }
        /**
        * Gets all classifiers of which this element is a direct or indirect general.
        * @returns {elements.Classifier[]}
        */
        getAllSpecializations() {
            return this.modelDelegate.getAllSpecializations(this);
        }
        /**
        * Gets the first direct generalization relationship of the element.
        * @returns {elements.Generalization}
        */
        getFirstGeneralization() {
            return this.modelDelegate.getFirstGeneralization(this);
        }
        /**
        * Gets the first classifier that is an immediate general of the current element.
        * @returns {elements.Classifier}
        */
        getFirstParent() {
            return this.modelDelegate.getFirstParent(this);
        }
        /**
        * Constructs a name from the names of the nesting packages. The name is constructed working inwards
        * from the package that is defined as namespace root up to but not including the PackageableElement
        * itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getNamespaceName(separator) {
            return this.modelDelegate.getNamespaceName(this, separator);
        }
        /**
        * Gets all packages that contain this Package, working inwards from the top Package to the owning
        * package.
        * @returns {elements.Package[]} A collection of Packages.
        */
        getNestingPackages() {
            return this.modelDelegate.getNestingPackages(this);
        }
        /**
        * Gives all of the immediate ancestors of a generalized Classifier.
        * @returns {elements.Classifier[]}
        */
        getParents() {
            return this.modelDelegate.getParents(this);
        }
        /**
        * Constructs a name from the PackageableElement and the names of the nesting packages. The name is
        * constructed working inwards from the package that is defined as namespace root up to and including
        * the PackageableElement itself.
        * @param {string} separator The string to use to separate names. If not specified, a dot "." will be
        * used.
        * @returns {string} A single string with all the names separated.
        */
        getQualifiedName(separator) {
            return this.modelDelegate.getQualifiedName(this, separator);
        }
        /**
        * Gets all classifiers of which this classifier is a direct general.
        * @returns {elements.Classifier[]}
        */
        getSpecializations() {
            return this.modelDelegate.getSpecializations(this);
        }
    }

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    const PRIMITIVE_BOOLEAN_ID$1 = "boolean_id";
    const PRIMITIVE_INTEGER_ID$1 = "integer_id";
    const PRIMITIVE_REAL_ID$1 = "real_id";
    const PRIMITIVE_STRING_ID$1 = "string_id";
    const PRIMITIVE_OBJECT_ID$1 = "object_id";
    const PRIMITIVE_UNLIMITEDNATURAL_ID = "unlimitednatural_id";
    class DataToModelConverter {
        constructor(elementMap, modelDelegate, elementComparer) {
            this.elementMap = elementMap;
            this.modelDelegate = modelDelegate;
            this.elementComparer = elementComparer;
            this.referencesToResolve = [];
            const primitiveTypes = this.createPrimitiveTypes();
            primitiveTypes.forEach(t => {
                this.elementMap.addElement(t, null);
            });
        }
        createPrimitiveTypes() {
            const result = [];
            const booleanType = new PrimitiveType(this.modelDelegate, null);
            booleanType.id = PRIMITIVE_BOOLEAN_ID$1;
            booleanType.name = 'boolean';
            result.push(booleanType);
            const integerType = new PrimitiveType(this.modelDelegate, null);
            integerType.id = PRIMITIVE_INTEGER_ID$1;
            integerType.name = 'integer';
            result.push(integerType);
            const realType = new PrimitiveType(this.modelDelegate, null);
            realType.id = PRIMITIVE_REAL_ID$1;
            realType.name = 'real';
            result.push(realType);
            const stringType = new PrimitiveType(this.modelDelegate, null);
            stringType.id = PRIMITIVE_STRING_ID$1;
            stringType.name = 'string';
            result.push(stringType);
            const objectType = new PrimitiveType(this.modelDelegate, null);
            objectType.id = PRIMITIVE_OBJECT_ID$1;
            objectType.name = 'object';
            result.push(objectType);
            const unlimitedNaturalType = new PrimitiveType(this.modelDelegate, null);
            unlimitedNaturalType.id = PRIMITIVE_UNLIMITEDNATURAL_ID;
            unlimitedNaturalType.name = 'UnlimitedNatural';
            result.push(unlimitedNaturalType);
            return result;
        }
        createElementType(elementData) {
            switch (elementData) // serialized as string
             {
                case 'class': return exports.ElementType.class;
                case 'stereotype': return exports.ElementType.stereotype;
                case 'property': return exports.ElementType.property;
                case 'package': return exports.ElementType.package;
                case 'profile': return exports.ElementType.profile;
                case 'dataType': return exports.ElementType.dataType;
                case 'primitiveType': return exports.ElementType.primitiveType;
                case 'parameter': return exports.ElementType.parameter;
                case 'operation': return exports.ElementType.operation;
                case 'model': return exports.ElementType.model;
                case 'literalUnlimitedNatural': return exports.ElementType.literalUnlimitedNatural;
                case 'literalString': return exports.ElementType.literalString;
                case 'literalReal': return exports.ElementType.literalReal;
                case 'literalNull': return exports.ElementType.literalNull;
                case 'literalInteger': return exports.ElementType.literalInteger;
                case 'literalBoolean': return exports.ElementType.literalBoolean;
                case 'interfaceRealization': return exports.ElementType.interfaceRealization;
                case 'interface': return exports.ElementType.interface;
                case 'generalization': return exports.ElementType.generalization;
                case 'enumerationLiteral': return exports.ElementType.enumerationLiteral;
                case 'enumeration': return exports.ElementType.enumeration;
                case 'comment': return exports.ElementType.comment;
                case 'association': return exports.ElementType.association;
                default: throw `Error reading model. Could not map ElementType value '${elementData}'.`;
            }
        }
        /**
         * NOTE: this function must be edited in the partial template file.
         */
        createElementId(elementId) {
            return elementId; //  
            // Obsolete: ids must be prefixed if we are loading a referenced document, because references to it 
            // are prefixed with the document id    
            //return this.elementIdPrefix ? this.elementIdPrefix + '.' + elementId : elementId;
        }
        /**
         * NOTE: this function must be edited in the partial template file.
         */
        convert(elementData, profiles) {
            // this.elementIdPrefix = elementIdPrefix;
            // Deprecated: Extend prototypes with profile specific accessors
            // if (profiles) {
            //     ProfileExtender.applyProfiles(profiles);
            // }
            // Load the object tree recursively. This will fill elementMap and referencesToResolve.
            const model = this.createModel(elementData);
            // Now the object tree is loaded, set references between objects
            this.referencesToResolve.forEach((item) => {
                item.resolvefn.call(this, item.target, item.data);
            });
            this.referencesToResolve = []; // Release this list
            return model;
        }
        /**
         * NOTE: this function must be edited in the partial template file.
         */
        addElementById(elementData, element) {
            if ((!elementData.id || elementData.id.length === 0)) {
                // The following element types do not require an id 
                if (elementData.elementType !== 'enumerationLiteral' && elementData.elementType !== 'comment' && !DataToModelConverter.isValueSpecification(elementData.elementType)) {
                    console.warn(`Mising id on element of type '${elementData.elementType}'.`);
                }
                return;
            }
            this.elementMap.addElement(element, elementData);
        }
        /**
         * Gets the id of the matching built-in primitive type if the element type is a literal type.
         * NOTE: this function must be edited in the partial template file.
         */
        static getTypeIdIfLiteralType(elementType) {
            switch (elementType) {
                case 'literalBoolean':
                    return PRIMITIVE_BOOLEAN_ID$1;
                case 'literalInteger':
                    return PRIMITIVE_INTEGER_ID$1;
                case 'literalReal':
                    return PRIMITIVE_REAL_ID$1;
                case 'literalString':
                    return PRIMITIVE_STRING_ID$1;
                case 'literalUnlimitedNatural':
                    return PRIMITIVE_UNLIMITEDNATURAL_ID;
                default:
                    // TODO: deal with literalNull?			
                    return undefined; // returns undefined because the result is assigned to a data property "type?: string;"
            }
        }
        /**
       * Custom function to create element properties from tagged values.
       * NOTE: this function must be edited in the partial template file.
       */
        mapTaggedValues(elementData, element) {
            if (!elementData.appliedStereotypes)
                return;
            // Get the stereotypes applied to this element. For each stereotype, get the meta properties.	
            // Note that we should not use element.appliedStereotypes because that data is not available
            // at this point.
            elementData.appliedStereotypes.forEach(stereotypeId => {
                // Lookup the stereotype by id. It should be indexed because the profiles are loaded first
                const st = this.elementMap.getElementById(stereotypeId);
                if (!st) {
                    return console.warn(`Element ${element.id} refers to undefined stereotype ${stereotypeId}.`);
                }
                element["stereotypeName"] = st.name; // always generated
                var stereotypeMetaProperties = st.getAllAttributes(); // stereotypes can inherit other stereotypes
                stereotypeMetaProperties.forEach(metaProperty => {
                    if (element.hasOwnProperty(metaProperty.name))
                        return;
                    //  Extend the element with the property. But determine the value first.				
                    let valueSpecification = null;
                    const taggedValue = elementData.taggedValues ? elementData.taggedValues.find(v => v.definition === metaProperty.id) : null;
                    if (taggedValue) {
                        valueSpecification = this.createValueSpecification(taggedValue.specification, element);
                    }
                    else if (metaProperty.defaultValue) {
                        valueSpecification = metaProperty.defaultValue;
                    }
                    element[metaProperty.name] = valueSpecification ? valueSpecification.getValue() : null;
                });
            });
        }
        createVisibilityKind(elementData) {
            switch (elementData) // serialized as string
             {
                case 'public': return exports.VisibilityKind.public;
                case 'private': return exports.VisibilityKind.private;
                case 'protected': return exports.VisibilityKind.protected;
                case 'package': return exports.VisibilityKind.package;
                default: throw `Error reading model. Could not map VisibilityKind value '${elementData}'.`;
            }
        }
        mapElement(elementData, target, owner) {
            target.id = this.createElementId(elementData.id);
            if (elementData.ownedComments) {
                target.ownedComments.push(...elementData.ownedComments.map((e) => { return this.createComment(e, target); }));
            }
            if (elementData.taggedValues) {
                target.taggedValues.push(...elementData.taggedValues.map((e) => { return this.createTaggedValueSpecification(e, target); }));
            }
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveElementReferences });
        }
        resolveElementReferences(target, elementData) {
            if (elementData.appliedStereotypes) {
                target.appliedStereotypes.push(...this.elementMap.getElementsByIdList(elementData.appliedStereotypes));
            }
        }
        mapNamedElement(elementData, target, owner) {
            if (elementData.name) {
                target.name = elementData.name;
            }
            if (elementData.visibility) {
                target.visibility = this.createVisibilityKind(elementData.visibility);
            }
        }
        mapTypedElement(elementData, target, owner) {
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveTypedElementReferences });
        }
        resolveTypedElementReferences(target, elementData) {
            // Special case for TypedElement: if this is a literal specification, the type can be a predefined primitive.
            if (!elementData.type) {
                elementData.type = DataToModelConverter.getTypeIdIfLiteralType(elementData.elementType);
            }
            target.type = elementData.type ? this.elementMap.getElementById(elementData.type) : null;
        }
        createValueSpecification(elementData, owner) {
            switch (elementData.elementType) {
                case "literalUnlimitedNatural":
                    return this.createLiteralUnlimitedNatural(elementData, owner);
                case "literalString":
                    return this.createLiteralString(elementData, owner);
                case "literalReal":
                    return this.createLiteralReal(elementData, owner);
                case "literalNull":
                    return this.createLiteralNull(elementData, owner);
                case "literalInteger":
                    return this.createLiteralInteger(elementData, owner);
                case "literalBoolean":
                    return this.createLiteralBoolean(elementData, owner);
                default: throw `Error reading model. Could not map ValueSpecification of type ${elementData.elementType}.`;
            }
        }
        static isValueSpecification(elementType) {
            switch (elementType) {
                case "literalUnlimitedNatural":
                case "literalString":
                case "literalReal":
                case "literalNull":
                case "literalInteger":
                case "literalBoolean":
                    return true;
                default: return false;
            }
        }
        mapPackageableElement(elementData, target, owner) {
        }
        createPackageableElement(elementData, owner) {
            switch (elementData.elementType) {
                case "interface":
                    return this.createInterface(elementData, owner);
                case "primitiveType":
                    return this.createPrimitiveType(elementData, owner);
                case "enumeration":
                    return this.createEnumeration(elementData, owner);
                case "dataType":
                    return this.createDataType(elementData, owner);
                case "stereotype":
                    return this.createStereotype(elementData, owner);
                case "class":
                    return this.createClass(elementData, owner);
                case "association":
                    return this.createAssociation(elementData, owner);
                case "profile":
                    return this.createProfile(elementData, owner);
                case "package":
                    return this.createPackage(elementData, owner);
                default: throw `Error reading model. Could not map PackageableElement of type ${elementData.elementType}.`;
            }
        }
        static isPackageableElement(elementType) {
            switch (elementType) {
                case "interface":
                case "primitiveType":
                case "enumeration":
                case "dataType":
                case "stereotype":
                case "class":
                case "association":
                case "profile":
                case "package":
                    return true;
                default: return false;
            }
        }
        mapType(elementData, target, owner) {
            if (elementData.isInferred) {
                target.isInferred = elementData.isInferred;
            }
        }
        mapTaggedValueSpecification(elementData, target, owner) {
            if (elementData.specification) {
                target.specification = this.createValueSpecification(elementData.specification, owner);
            }
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveTaggedValueSpecificationReferences });
        }
        resolveTaggedValueSpecificationReferences(target, elementData) {
            if (!elementData.definition)
                console.error(`Unable to set property 'definition'. The following data is missing a 'definition' field: ${JSON.stringify(elementData)}.`);
            const definition = this.elementMap.getElementById(elementData.definition);
            if (definition) {
                target.definition = definition;
            }
            else
                console.error(`Unable to set property 'definition'. Property with id '${elementData.definition}' does not exist.`);
        }
        createTaggedValueSpecification(elementData, owner) {
            const element = new TaggedValueSpecification();
            this.mapTaggedValueSpecification(elementData, element, owner);
            return element;
        }
        mapRedefinableElement(elementData, target, owner) {
            if (elementData.isLeaf) {
                target.isLeaf = elementData.isLeaf;
            }
        }
        mapClassifier(elementData, target, owner) {
            if (elementData.generalizations) {
                target.generalizations.push(...elementData.generalizations.map((e) => { return this.createGeneralization(e, target); }));
            }
            if (elementData.isAbstract) {
                target.isAbstract = elementData.isAbstract;
            }
            if (elementData.isFinalSpecialization) {
                target.isFinalSpecialization = elementData.isFinalSpecialization;
            }
        }
        mapMultiplicityElement(elementData, target, owner) {
            if (elementData.isOrdered) {
                target.isOrdered = elementData.isOrdered;
            }
            if (elementData.isUnique) {
                target.isUnique = elementData.isUnique;
            }
            if (elementData.lowerValue) {
                target.lowerValue = this.createValueSpecification(elementData.lowerValue, target);
            }
            if (elementData.upperValue) {
                target.upperValue = this.createValueSpecification(elementData.upperValue, target);
            }
        }
        mapOrderedElement(elementData, target, owner) {
            if (elementData.order) {
                target.order = elementData.order;
            }
        }
        mapFeature(elementData, target, owner) {
            if (elementData.isStatic) {
                target.isStatic = elementData.isStatic;
            }
        }
        mapStructuralFeature(elementData, target, owner) {
            if (elementData.isReadOnly) {
                target.isReadOnly = elementData.isReadOnly;
            }
        }
        mapStereotypeExtension(elementData, target, owner) {
            if (elementData.isRequired) {
                target.isRequired = elementData.isRequired;
            }
            if (elementData.metaClass) {
                target.metaClass = this.createElementType(elementData.metaClass);
            }
        }
        createStereotypeExtension(elementData, owner) {
            const element = new StereotypeExtension();
            this.mapStereotypeExtension(elementData, element, owner);
            return element;
        }
        mapMemberedClassifier(elementData, target, owner) {
            if (elementData.ownedAttributes) {
                target.ownedAttributes.push(...elementData.ownedAttributes.map((e) => { return this.createProperty(e, target); }).sort(this.elementComparer.compareOrderedElements));
            }
            if (elementData.ownedOperations) {
                target.ownedOperations.push(...elementData.ownedOperations.map((e) => { return this.createOperation(e, target); }).sort(this.elementComparer.compareOrderedElements));
            }
        }
        mapBehavioredClassifier(elementData, target, owner) {
            if (elementData.interfaceRealizations) {
                target.interfaceRealizations.push(...elementData.interfaceRealizations.map((e) => { return this.createInterfaceRealization(e, target); }));
            }
        }
        mapClass(elementData, target, owner) {
            if (elementData.isActive) {
                target.isActive = elementData.isActive;
            }
        }
        createClass(elementData, owner) {
            const element = new Class(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapMemberedClassifier(elementData, element, element);
            this.mapBehavioredClassifier(elementData, element, element);
            this.mapClass(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapStereotype(elementData, target, owner) {
            if (elementData.extends) {
                target.extends.push(...elementData.extends.map((e) => { return this.createStereotypeExtension(e, target); }));
            }
            if (elementData.safeName) {
                target.safeName = elementData.safeName;
            }
        }
        createStereotype(elementData, owner) {
            const element = new Stereotype(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapMemberedClassifier(elementData, element, element);
            this.mapBehavioredClassifier(elementData, element, element);
            this.mapClass(elementData, element, element);
            this.mapStereotype(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapProperty(elementData, target, owner) {
            if (elementData.aggregation) {
                target.aggregation = this.createAggregationKind(elementData.aggregation);
            }
            if (elementData.defaultValue) {
                target.defaultValue = this.createValueSpecification(elementData.defaultValue, target);
            }
            if (elementData.isDerived) {
                target.isDerived = elementData.isDerived;
            }
            if (elementData.isDerivedUnion) {
                target.isDerivedUnion = elementData.isDerivedUnion;
            }
            if (elementData.isID) {
                target.isID = elementData.isID;
            }
            if (elementData.isNavigable) {
                target.isNavigable = elementData.isNavigable;
            }
        }
        createProperty(elementData, owner) {
            const element = new Property(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapOrderedElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapMultiplicityElement(elementData, element, element);
            this.mapFeature(elementData, element, element);
            this.mapStructuralFeature(elementData, element, element);
            this.mapProperty(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapPackage(elementData, target, owner) {
            if (elementData.isNamespaceRoot) {
                target.isNamespaceRoot = elementData.isNamespaceRoot;
            }
            if (elementData.packagedElements) {
                target.packagedElements.push(...elementData.packagedElements.map((e) => { return this.createPackageableElement(e, target); }).sort(this.elementComparer.comparePackageableElements));
            }
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolvePackageReferences });
        }
        resolvePackageReferences(target, elementData) {
            if (elementData.appliedProfiles) {
                target.appliedProfiles.push(...this.elementMap.getElementsByIdList(elementData.appliedProfiles));
            }
        }
        createPackage(elementData, owner) {
            const element = new Package(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapPackage(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapProfile(elementData, target, owner) {
            if (elementData.safeName) {
                target.safeName = elementData.safeName;
            }
        }
        createProfile(elementData, owner) {
            const element = new Profile(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapPackage(elementData, element, element);
            this.mapProfile(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createDataType(elementData, owner) {
            const element = new DataType(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapMemberedClassifier(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createPrimitiveType(elementData, owner) {
            const element = new PrimitiveType(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapMemberedClassifier(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createParameterDirectionKind(elementData) {
            switch (elementData) // serialized as string
             {
                case 'in': return exports.ParameterDirectionKind.in;
                case 'inout': return exports.ParameterDirectionKind.inout;
                case 'out': return exports.ParameterDirectionKind.out;
                case 'return': return exports.ParameterDirectionKind.return;
                default: throw `Error reading model. Could not map ParameterDirectionKind value '${elementData}'.`;
            }
        }
        mapParameter(elementData, target, owner) {
            if (elementData.defaultValue) {
                target.defaultValue = this.createValueSpecification(elementData.defaultValue, target);
            }
            if (elementData.direction) {
                target.direction = this.createParameterDirectionKind(elementData.direction);
            }
            if (elementData.isException) {
                target.isException = elementData.isException;
            }
            if (elementData.isStream) {
                target.isStream = elementData.isStream;
            }
        }
        createParameter(elementData, owner) {
            const element = new Parameter(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapOrderedElement(elementData, element, element);
            this.mapMultiplicityElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapParameter(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapBehavioralFeature(elementData, target, owner) {
            if (elementData.isAbstract) {
                target.isAbstract = elementData.isAbstract;
            }
            if (elementData.ownedParameters) {
                target.ownedParameters.push(...elementData.ownedParameters.map((e) => { return this.createParameter(e, target); }).sort(this.elementComparer.compareOrderedElements));
            }
        }
        mapOperation(elementData, target, owner) {
            if (elementData.isConstructor) {
                target.isConstructor = elementData.isConstructor;
            }
            if (elementData.isQuery) {
                target.isQuery = elementData.isQuery;
            }
        }
        createOperation(elementData, owner) {
            const element = new Operation(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapOrderedElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapFeature(elementData, element, element);
            this.mapBehavioralFeature(elementData, element, element);
            this.mapOperation(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createModel(elementData) {
            const element = new Model(this.modelDelegate, null);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapPackage(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapLiteralUnlimitedNatural(elementData, target, owner) {
            if (elementData.value) {
                target.value = new UnlimitedNatural(elementData.value);
            }
        }
        createLiteralUnlimitedNatural(elementData, owner) {
            const element = new LiteralUnlimitedNatural(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapLiteralUnlimitedNatural(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapLiteralString(elementData, target, owner) {
            if (elementData.value) {
                target.value = elementData.value;
            }
        }
        createLiteralString(elementData, owner) {
            const element = new LiteralString(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapLiteralString(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapLiteralReal(elementData, target, owner) {
            if (elementData.value) {
                target.value = elementData.value;
            }
        }
        createLiteralReal(elementData, owner) {
            const element = new LiteralReal(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapLiteralReal(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createLiteralNull(elementData, owner) {
            const element = new LiteralNull(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapLiteralInteger(elementData, target, owner) {
            if (elementData.value) {
                target.value = elementData.value;
            }
        }
        createLiteralInteger(elementData, owner) {
            const element = new LiteralInteger(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapLiteralInteger(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapLiteralBoolean(elementData, target, owner) {
            if (elementData.value) {
                target.value = elementData.value;
            }
        }
        createLiteralBoolean(elementData, owner) {
            const element = new LiteralBoolean(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapTypedElement(elementData, element, element);
            this.mapLiteralBoolean(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapInterfaceRealization(elementData, target, owner) {
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveInterfaceRealizationReferences });
        }
        resolveInterfaceRealizationReferences(target, elementData) {
            if (!elementData.contract)
                console.error(`Unable to set property 'contract'. The following data is missing a 'contract' field: ${JSON.stringify(elementData)}.`);
            const contract = this.elementMap.getElementById(elementData.contract);
            if (contract) {
                target.contract = contract;
            }
            else
                console.error(`Unable to set property 'contract'. Interface with id '${elementData.contract}' does not exist.`);
        }
        createInterfaceRealization(elementData, owner) {
            const element = new InterfaceRealization(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapInterfaceRealization(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createInterface(elementData, owner) {
            const element = new Interface(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapMemberedClassifier(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapGeneralization(elementData, target, owner) {
            if (elementData.isSubstitutable) {
                target.isSubstitutable = elementData.isSubstitutable;
            }
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveGeneralizationReferences });
        }
        resolveGeneralizationReferences(target, elementData) {
            if (!elementData.general)
                console.error(`Unable to set property 'general'. The following data is missing a 'general' field: ${JSON.stringify(elementData)}.`);
            const general = this.elementMap.getElementById(elementData.general);
            if (general) {
                target.general = general;
            }
            else
                console.error(`Unable to set property 'general'. Classifier with id '${elementData.general}' does not exist.`);
        }
        createGeneralization(elementData, owner) {
            const element = new Generalization(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapGeneralization(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapEnumerationLiteral(elementData, target, owner) {
            if (elementData.specification) {
                target.specification = this.createValueSpecification(elementData.specification, target);
            }
        }
        createEnumerationLiteral(elementData, owner) {
            const element = new EnumerationLiteral(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapOrderedElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapEnumerationLiteral(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapEnumeration(elementData, target, owner) {
            if (elementData.ownedLiterals) {
                target.ownedLiterals.push(...elementData.ownedLiterals.map((e) => { return this.createEnumerationLiteral(e, target); }).sort(this.elementComparer.compareOrderedElements));
            }
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveEnumerationReferences });
        }
        resolveEnumerationReferences(target, elementData) {
            target.baseType = elementData.baseType ? this.elementMap.getElementById(elementData.baseType) : null;
        }
        createEnumeration(elementData, owner) {
            const element = new Enumeration(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapMemberedClassifier(elementData, element, element);
            this.mapEnumeration(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapDocumentReference(elementData, target, owner) {
            if (elementData.location) {
                target.location = this.createDocumentLocationKind(elementData.location);
            }
            if (elementData.name) {
                target.name = elementData.name;
            }
            if (elementData.path) {
                target.path = elementData.path;
            }
        }
        createDocumentReference(elementData, owner) {
            const element = new DocumentReference();
            this.mapDocumentReference(elementData, element, owner);
            return element;
        }
        createDocumentLocationKind(elementData) {
            switch (elementData) // serialized as string
             {
                case 'local': return exports.DocumentLocationKind.local;
                case 'npm': return exports.DocumentLocationKind.npm;
                default: throw `Error reading model. Could not map DocumentLocationKind value '${elementData}'.`;
            }
        }
        mapComment(elementData, target, owner) {
            if (elementData.body) {
                target.body = elementData.body;
            }
        }
        createComment(elementData, owner) {
            const element = new Comment(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapComment(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        mapAssociation(elementData, target, owner) {
            if (elementData.ownedEnds) {
                target.ownedEnds.push(...elementData.ownedEnds.map((e) => { return this.createProperty(e, target); }).sort(this.elementComparer.compareOrderedElements));
            }
            this.referencesToResolve.push({ target: target, data: elementData, resolvefn: this.resolveAssociationReferences });
        }
        resolveAssociationReferences(target, elementData) {
            if (elementData.memberEnds) {
                target.memberEnds.push(...this.elementMap.getElementsByIdList(elementData.memberEnds));
            }
        }
        createAssociation(elementData, owner) {
            const element = new Association(this.modelDelegate, owner);
            this.mapElement(elementData, element, element);
            this.mapNamedElement(elementData, element, element);
            this.mapPackageableElement(elementData, element, element);
            this.mapRedefinableElement(elementData, element, element);
            this.mapType(elementData, element, element);
            this.mapClassifier(elementData, element, element);
            this.mapAssociation(elementData, element, element);
            this.mapTaggedValues(elementData, element); // added by code generation
            this.addElementById(elementData, element);
            return element;
        }
        createAggregationKind(elementData) {
            switch (elementData) // serialized as string
             {
                case 'none': return exports.AggregationKind.none;
                case 'shared': return exports.AggregationKind.shared;
                case 'composite': return exports.AggregationKind.composite;
                default: throw `Error reading model. Could not map AggregationKind value '${elementData}'.`;
            }
        }
    }

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    class Document {
        constructor(modelDelegate) {
            this.modelDelegate = modelDelegate;
            this.id = '';
            this.creator = '';
            this.modelTypeName = '';
            this.modelTypeVersion = '';
            this.model = null;
            this.profiles = null;
            this.references = [];
        }
        /**
        * Returns an Element representing the element whose id property matches the specified string.
        * @returns {elements.Element} The model element matching the specified ID, or null if no matching
        * element was found in the model.
        * @param {string} id The ID of the element to search for.
        */
        findElementById(id) {
            return this.modelDelegate.findElementById(id);
        }
    }

    /*
     * Copyright (c) 2019 Yellicode
     *
     * This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     */
    const NO_ORDER = 0;
    class ElementComparerImpl {
        static getInstance() {
            if (!ElementComparerImpl.instance) {
                ElementComparerImpl.instance = new ElementComparerImpl();
            }
            return ElementComparerImpl.instance;
        }
        compareOrderedElements(x, y) {
            // We use a value of 0 (NO_ORDER) for elements having no order at all.
            // An order of NO_ORDER comes after a set order		
            var xOrder = x.order || NO_ORDER;
            var yOrder = y.order || NO_ORDER;
            if (xOrder === NO_ORDER && yOrder !== NO_ORDER) {
                return 1;
            }
            if (yOrder === NO_ORDER && xOrder !== NO_ORDER) {
                return -1;
            }
            // Both have an order
            const result = xOrder - yOrder;
            if (result !== 0)
                return result;
            // Both have the same order. Fallback by name for features (operations and properties), this is what we also do  
            // in the modeler. For enum members and parameters: keep the order as is.
            return isFeature(x) ? x.name.localeCompare(y.name) : 0;
        }
        comparePackageableElements(x, y) {
            // Packages first
            if (x.elementType === exports.ElementType.package) {
                if (y.elementType !== exports.ElementType.package) {
                    // x is a package, y isn't
                    return -1;
                }
            }
            else if (y.elementType === exports.ElementType.package) {
                // x is not a package, y is
                return 1;
            }
            // Then compare by name
            return x.name.localeCompare(y.name);
        }
        static haveEqualSignatures(x, y) {
            if (x.name !== y.name)
                return false;
            // Same name
            if (x.ownedParameters.length !== y.ownedParameters.length) {
                return false;
            }
            // Same number of parameters
            if (x.ownedParameters.length === 0)
                return true;
            // Same number of parameters (> 0)
            for (let i = 0, len = x.ownedParameters.length; i < len; i++) {
                const typeOfParamX = x.ownedParameters[i].type;
                const typeOfParamY = y.ownedParameters[i].type;
                if (typeOfParamX !== typeOfParamY)
                    return false;
            }
            return true;
        }
    }

    /*
     * Copyright (c) 2019 Yellicode
     *
     * This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     */
    /**
     * Internal class to which all behaviour of the model classes is delegated.
     */
    class ModelDelegateImpl {
        constructor(elementMap) {
            this.elementMap = elementMap;
            // Note that elementMap is null when not initialized through the DataToModelConverter
        }
        // ************************  Document **************************** //     
        findElementById(id) {
            if (!this.elementMap)
                return null;
            return this.elementMap.getElementById(id);
        }
        // **************************  Element ******************************* //     
        getFirstCommentBody(element) {
            if (!element.ownedComments || element.ownedComments.length == 0)
                return ''; // return an empty string, no null or undefined, they are inconvenient when using template literals.      
            return element.ownedComments[0].body;
        }
        // ************************  TypedElement **************************** //     
        getTypeName(typedElement) {
            if (!typedElement.type)
                return '';
            return typedElement.type.name;
        }
        // *****************************  Package **************************** //     
        static getPackagedElementsWhere(pack, predicate) {
            if (!pack.packagedElements)
                return [];
            return pack.packagedElements.filter(predicate);
        }
        static getAllPackagedElementsWhereRecursive(pack, predicate, result) {
            pack.packagedElements.forEach(e => {
                if (predicate(e)) {
                    result.push(e);
                }
                if (ElementTypeUtility.isPackage(e.elementType) && e.packagedElements) {
                    ModelDelegateImpl.getAllPackagedElementsWhereRecursive(e, predicate, result);
                }
            });
        }
        static getAllPackagedElementsWhere(pack, predicate) {
            const result = [];
            if (pack.packagedElements) {
                ModelDelegateImpl.getAllPackagedElementsWhereRecursive(pack, predicate, result);
            }
            return result;
        }
        getNestedPackages(element) {
            return ModelDelegateImpl.getPackagedElementsWhere(element, pe => pe.elementType === exports.ElementType.package);
        }
        getTypes(element) {
            return ModelDelegateImpl.getPackagedElementsWhere(element, pe => 
            // Technically, an Association is also a Type, but it does not seem to make much sense here
            ElementTypeUtility.isType(pe.elementType) && !ElementTypeUtility.isAssociation(pe.elementType));
        }
        getAllTypes(element) {
            return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => 
            // Technically, an Association is also a Type, but it does not seem to make much sense here
            ElementTypeUtility.isType(pe.elementType) && !ElementTypeUtility.isAssociation(pe.elementType));
        }
        getClasses(element) {
            return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isClass(pe.elementType));
        }
        getAllClasses(element) {
            return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isClass(pe.elementType));
        }
        getInterfaces(element) {
            return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isInterface(pe.elementType));
        }
        getAllInterfaces(element) {
            return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isInterface(pe.elementType));
        }
        getDataTypes(element) {
            return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isDataType(pe.elementType));
        }
        getAllDataTypes(element) {
            return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isDataType(pe.elementType));
        }
        getEnumerations(element) {
            return ModelDelegateImpl.getPackagedElementsWhere(element, pe => ElementTypeUtility.isEnumeration(pe.elementType));
        }
        getAllEnumerations(element) {
            return ModelDelegateImpl.getAllPackagedElementsWhere(element, pe => ElementTypeUtility.isEnumeration(pe.elementType));
        }
        // ************************  PackageableElement **************************** //     
        getPackage(packagedElement) {
            return packagedElement.owner;
        }
        /**
        * Gets all packages that own this Package, working inwards from the top Package to the owning package.
        * @returns {Interfaces.Package[]} A collection of Packages.
        */
        getNestingPackages(packagedElement, stopAtNamespaceRoot) {
            // Work outwards, then reverse..
            const result = [];
            let owner = packagedElement.owner;
            while (owner && isPackage(owner)) {
                result.push(owner);
                if (owner.isNamespaceRoot && stopAtNamespaceRoot === true) {
                    break;
                }
                owner = owner.owner;
            }
            result.reverse();
            return result;
        }
        getNamespaceName(packagedElement, separator = '.') {
            return this.getNestingPackages(packagedElement, true).map(p => p.name).join(separator);
        }
        getQualifiedName(packagedElement, separator = '.') {
            const namespaceName = this.getNamespaceName(packagedElement, separator);
            return namespaceName ? `${namespaceName}${separator}${packagedElement.name}` : packagedElement.name;
        }
        // ************************  Generalization **************************** //     
        getSpecific(generalization) {
            return generalization.owner;
        }
        // **************************  Classifier ******************************* //     
        getFirstGeneralization(classifier) {
            if (classifier.generalizations.length === 0)
                return null;
            return classifier.generalizations[0];
        }
        getFirstParent(classifier) {
            const firstGeneralization = this.getFirstGeneralization(classifier);
            return (firstGeneralization) ? firstGeneralization.general : null;
        }
        getParents(classifier) {
            return classifier.generalizations.map(g => g.general);
        }
        /**
        * Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more specific classifiers will
        * appear before more general classifiers.
        */
        getAllParents(classifier) {
            const allParents = [];
            this.getAllParentsRecursive(classifier, allParents);
            return allParents;
        }
        getAllParentsRecursive(classifier, allParents) {
            const ownParents = this.getParents(classifier);
            if (ownParents != null) {
                // More specific parents first.
                ownParents.forEach(p => {
                    const ix = allParents.indexOf(p);
                    // If the parent is already there, remove it and add it again at the end of the list.
                    if (ix > -1) {
                        allParents.splice(ix, 1);
                    }
                    allParents.push(p);
                });
                // add the parents of each parent
                ownParents.forEach(p => {
                    this.getAllParentsRecursive(p, allParents);
                });
            }
        }
        getSpecializations(classifier) {
            if (!this.elementMap)
                return [];
            return this.elementMap.getSpecializationsOf(classifier.id);
        }
        getAllSpecializations(classifier) {
            if (!this.elementMap)
                return [];
            return this.elementMap.getAllSpecializationsOf(classifier.id);
        }
        // /**
        //  * Returns true if one classifier has the other as direct general.     
        //  */
        // private static hasGeneral(x: Interfaces.Classifier, y: Interfaces.Classifier): boolean {
        //     // TODO: recursive?
        //     const firstMatch = x.generalizations.find(g => g.general.id === y.id);
        //     return firstMatch ? true: false;    
        // }
        // ********************  MemberedClassifier **************************** //     
        getAllAttributes(memberedClassifier) {
            const distinctClassifierIds = []; // keep this list to check against recursion
            const result = [];
            this.getAllAttributesRecursive(memberedClassifier, distinctClassifierIds, result);
            return result;
        }
        getAllAttributesRecursive(memberedClassifier, distinctClassifierIds, result) {
            distinctClassifierIds.push(memberedClassifier.id);
            // First add the general members, then the owned
            memberedClassifier.generalizations.forEach(g => {
                const general = g.general;
                if (distinctClassifierIds.indexOf(general.id) === -1) {
                    this.getAllAttributesRecursive(general, distinctClassifierIds, result);
                }
            });
            // Now add the owned members
            result.push(...memberedClassifier.ownedAttributes);
        }
        getAllOperations(memberedClassifier) {
            const distinctClassifierIds = []; // keep this list to check against recursion
            const result = [];
            this.getAllOperationsRecursive(memberedClassifier, distinctClassifierIds, result);
            return result;
        }
        getAllOperationsRecursive(memberedClassifier, distinctClassifierIds, result) {
            distinctClassifierIds.push(memberedClassifier.id); // keep this list to check against recursion
            // First add the general members, then the owned
            memberedClassifier.generalizations.forEach(g => {
                const general = g.general;
                if (distinctClassifierIds.indexOf(general.id) === -1) {
                    this.getAllOperationsRecursive(general, distinctClassifierIds, result);
                }
            });
            // Now add the owned members. Replace any inherited members with the same signature
            memberedClassifier.ownedOperations.forEach(op => {
                // Is there an operation in the result that has the same signature? Then replace it.
                // TODO: can we set a "redefines" reference (referring to the base operation)?             
                _.remove(result, (baseOperation) => ElementComparerImpl.haveEqualSignatures(baseOperation, op));
                result.push(op);
            });
        }
        // ************************  Class  **************************** //         
        getSuperClasses(cls) {
            const result = [];
            if (!cls.generalizations)
                return result;
            cls.generalizations.forEach(g => {
                if (ElementTypeUtility.isClass(g.general.elementType)) {
                    result.push(g.general);
                }
            });
            return result;
        }
        // ************************  MultiplicityElement **************************** //         
        getLower(element) {
            // If element is an operation, return the lower of the return parameter
            const multiplicityElement = element.elementType === exports.ElementType.operation ?
                element.getReturnParameter() :
                element;
            if (!multiplicityElement)
                return null; // the operation has no return parameter
            const lowerValue = multiplicityElement.lowerValue;
            if (!lowerValue)
                return null;
            switch (lowerValue.elementType) {
                case exports.ElementType.literalInteger:
                    return lowerValue.value;
                case exports.ElementType.literalString:
                    const stringValue = lowerValue.getStringValue();
                    const parsed = Number.parseInt(stringValue);
                    return isNaN(parsed) ? null : parsed;
                default:
                    return null;
            }
        }
        getUpper(element) {
            // If element is an operation, return the upper of the return parameter
            const multiplicityElement = element.elementType === exports.ElementType.operation ?
                element.getReturnParameter() :
                element;
            if (!multiplicityElement)
                return null; // the operation has no return parameter
            const upperValue = multiplicityElement.upperValue;
            if (upperValue == null)
                return null;
            switch (upperValue.elementType) {
                case exports.ElementType.literalString:
                case exports.ElementType.literalInteger:
                    const stringValue = upperValue.getStringValue();
                    return new UnlimitedNatural(stringValue);
                case exports.ElementType.literalUnlimitedNatural:
                    return upperValue.value;
                default:
                    return null;
            }
        }
        getLowerBound(element) {
            const lower = this.getLower(element);
            // Do an explicit null check, allowing for 0. An unspecified lower means a lower bound of 1.
            return (lower === null) ? 1 : lower;
        }
        getUpperBound(element) {
            const upper = this.getUpper(element);
            // Do an explicit null check, allowing for 0. An unspecified upper means an upper bound of 1.
            return (upper === null) ? new UnlimitedNatural(1) : upper;
        }
        isMultivalued(element) {
            const upper = this.getUpper(element);
            if (!upper)
                return false;
            return upper.IsInfinity || upper.Value > 1;
        }
        isOptional(element) {
            return this.getLowerBound(element) === 0;
        }
        isOptionalAndSinglevalued(element) {
            if (this.getLowerBound(element) !== 0)
                return false; // not optional
            const upper = this.getUpperBound(element);
            return !upper.IsInfinity && upper.Value === 1;
        }
        isRequiredAndSinglevalued(element) {
            if (this.getLowerBound(element) !== 1)
                return false; // not required
            const upper = this.getUpperBound(element);
            return !upper.IsInfinity && upper.Value === 1;
        }
        // ********************  Default values **************************** //     
        getDefault(hasDefaultValue) {
            if (!hasDefaultValue.defaultValue)
                return null;
            return this.getValue(hasDefaultValue.defaultValue);
        }
        // ********************  ValueSpecification **************************** //     
        getValue(valueSpecification) {
            if ("value" in valueSpecification) { // don't use hasOwnProperty here
                // The valueSpecification is a LiteralInteger, LiteralBoolean, etc.
                return valueSpecification["value"];
            }
            else
                return null; // The valueSpecification is a LiteralNull or an unsupported implementation
        }
        getStringValue(valueSpecification) {
            const rawValue = valueSpecification.getValue();
            if (rawValue === null)
                return null;
            if (valueSpecification.elementType === exports.ElementType.literalUnlimitedNatural) {
                return rawValue.stringValue();
            }
            return rawValue.toString();
        }
        // ********************  EnumerationLiteral **************************** //     
        getEnumeration(literal) {
            return literal.owner;
        }
        getSpecificationValue(literal) {
            if (!literal.specification)
                return null;
            return this.getValue(literal.specification);
        }
        // ********************  Property **************************** //     
        getAssociation(property) {
            // The property can be owned by an association (association.ownedEnds) or by a classifier
            // If owned by an association, the path is short.
            if (isAssociation(property.owner)) {
                return property.owner;
            }
            // The property is not owned by an association, but can still be part of one
            // (association.memberEnds)
            if (!this.elementMap)
                return null;
            return this.elementMap.getAssociationHavingMemberEnd(property);
        }
        // ********************  Operation **************************** //     
        getReturnParameter(operation) {
            const val = operation.ownedParameters.find(p => { return p.direction === exports.ParameterDirectionKind.return; });
            return val || null;
        }
        getInputParameters(operation) {
            return operation.ownedParameters.filter(p => {
                return p.direction === exports.ParameterDirectionKind.in
                    || p.direction === exports.ParameterDirectionKind.inout;
            });
        }
        getOutputParameters(operation) {
            return operation.ownedParameters.filter(p => {
                return p.direction === exports.ParameterDirectionKind.out
                    || p.direction === exports.ParameterDirectionKind.inout
                    || p.direction === exports.ParameterDirectionKind.return;
            });
        }
        getReturnType(operation) {
            const returnParameter = this.getReturnParameter(operation);
            return returnParameter ? returnParameter.type : null;
        }
    }

    class ElementMapImpl {
        constructor() {
            this.elementsById = {};
            this.specializationsById = {};
            this.associationsByEndId = {};
        }
        addElement(element, elementData) {
            if (this.elementsById.hasOwnProperty(element.id)) {
                console.warn(`Duplicate element id '${element.id}'.`);
                return;
            }
            this.elementsById[element.id] = element;
            // Add generalizations to the specialization map
            if (ElementTypeUtility.isClassifier(element.elementType) && elementData) {
                this.addSpecializations(element, elementData);
            }
            // Add association ends to the assciationEnd map
            if (ElementTypeUtility.isAssociation(element.elementType) && elementData) {
                this.addAssociationEnds(element, elementData);
            }
        }
        addAssociationEnds(association, associationData) {
            // Get memberEnds of assocationData instead of association itself: the ends  will not be set here as they are not resolved yet
            // by DataToModelConverter.resolveAssociationReferences().        
            if (!associationData.memberEnds)
                return;
            associationData.memberEnds.forEach(endId => {
                // An association end can only be part of one association.
                if (this.associationsByEndId.hasOwnProperty(endId)) {
                    console.warn(`Association end with id '${endId}' is already part of another association than ${associationData.id}.`);
                }
                this.associationsByEndId[endId] = association;
            });
        }
        addSpecializations(classifier, classifierData) {
            if (!classifierData.generalizations)
                return;
            // Enumerate the classifierData instead of the classifier itself: the generalizations will not be set here as they are not resolved yet
            classifierData.generalizations.forEach(g => {
                let dictionaryEntry;
                // g is a Generalization of element, so element is a Specialization of g
                if (this.specializationsById.hasOwnProperty(g.general)) {
                    dictionaryEntry = this.specializationsById[g.general];
                    dictionaryEntry.push(classifier);
                }
                else {
                    this.specializationsById[g.general] = [classifier];
                }
            });
        }
        getAssociationHavingMemberEnd(end) {
            if (!end || !end.id)
                return null;
            if (!this.associationsByEndId.hasOwnProperty(end.id))
                return null;
            return this.associationsByEndId[end.id];
        }
        hasElement(id) {
            return this.elementsById.hasOwnProperty(id);
        }
        getElementById(id) {
            if (!id || id.length === 0)
                return null;
            if (this.elementsById.hasOwnProperty(id))
                return this.elementsById[id];
            else {
                console.warn(`Unkown element id '${id}'.`);
                return null;
            }
        }
        getElementsByIdList(idList) {
            const result = [];
            if (idList == null)
                return result;
            idList.forEach((id) => {
                const element = this.getElementById(id);
                if (element != null)
                    result.push(element);
            });
            return result;
        }
        getSpecializationsOf(generalId) {
            if (!this.specializationsById.hasOwnProperty(generalId))
                return [];
            return this.specializationsById[generalId];
        }
        getAllSpecializationsOf(generalId) {
            if (!this.specializationsById.hasOwnProperty(generalId))
                return [];
            const specialMap = {};
            this.getAllSpecializationsRecursive(generalId, specialMap);
            // Convert the result to an array
            const result = [];
            for (var specializationId in specialMap) {
                result.push(specialMap[specializationId]);
            }
            return result;
        }
        getAllSpecializationsRecursive(generalId, specialMap) {
            if (!this.specializationsById.hasOwnProperty(generalId)) {
                return;
            }
            const directSpecializations = this.specializationsById[generalId];
            directSpecializations.forEach(s => {
                if (!specialMap.hasOwnProperty(s.id)) {
                    specialMap[s.id] = s;
                }
                // Get the specializations of this specialization
                this.getAllSpecializationsRecursive(s.id, specialMap);
            });
        }
    }

    class ModelReader {
        constructor() {
            /**
             * Contains all profiles that were read from the main document or any referenced documents.
             */
            this.allProfiles = [];
            this.elementMap = new ElementMapImpl();
            this.modelDelegate = new ModelDelegateImpl(this.elementMap);
            this.converter = new DataToModelConverter(this.elementMap, this.modelDelegate, ElementComparerImpl.getInstance());
        }
        static canRead(data) {
            if (!data.modelTypeName)
                return false;
            return ("yellicode yml" === data.modelTypeName.toLowerCase());
        }
        static readDocument(documentData) {
            var instance = new ModelReader();
            return instance.readDocumentRecursive(documentData, false);
        }
        readDocumentRecursive(documentData, isReferencedDocument) {
            // Obsolete: Ids must be prefixed if we are loading a referenced document, because references to it 
            // are prefixed with the document id      
            // const elementIdPrefix = isReferencedDocument ? documentData.id : null;
            // Convert the document's referenced documents first
            this.readReferencedDocumentsRecursive(documentData);
            // Convert the document's profiles first (this allows the converter to resolve references to them)
            const profilesInDocument = documentData.profiles ? this.converter.convert(documentData.profiles, null) : null;
            if (profilesInDocument) {
                profilesInDocument.packagedElements.forEach(p => {
                    if (ElementTypeUtility.isProfile(p.elementType)) { // the element can also be a Enum or other type
                        this.allProfiles.push(p);
                    }
                });
            }
            // Then convert the model, using the profiles
            const modelInDocument = documentData.model ? this.converter.convert(documentData.model, this.allProfiles) : null;
            const document = new Document(this.modelDelegate);
            document.id = documentData.id;
            document.modelTypeName = documentData.modelTypeName;
            document.modelTypeVersion = documentData.modelTypeVersion;
            document.creator = documentData.creator;
            document.profiles = profilesInDocument;
            document.model = modelInDocument;
            return document;
            //return documentData.model ? ModelReader.converter.convert(documentData.model, ModelReader.profiles, elementIdPrefix) : null;
        }
        readReferencedDocumentsRecursive(documentData) {
            if (!documentData.references)
                return;
            documentData.references.forEach(r => {
                if (!r.document)
                    return;
                // Load the document. This will load the document's model elements into memory so that the converter can 
                // resolve any references to it. We don't use the referenced document's main model here, it is not returned 
                // through the API but may be referenced by the main document.
                this.readDocumentRecursive(r.document, true);
            });
        }
    }

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    class ElementFactory {
        static createProperty(owner) {
            let modelDelegate = owner.modelDelegate || new ModelDelegateImpl(null);
            const property = new Property(modelDelegate, owner);
            property.id = core.UniqueId.create();
            return property;
        }
        static createComment(owner, body) {
            let modelDelegate = owner.modelDelegate || new ModelDelegateImpl(null);
            const comment = new Comment(modelDelegate, owner);
            comment.body = body;
            // property.id = UniqueId.create(); // a comment does not need an id
            return comment;
        }
    }

    /*
     * Copyright (c) 2019 Yellicode
     *
     * This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     */
    /**
     * A base class for transforms that need to be applied recursively to all nested packaged elements
     * in a model or package.
     */
    class PackagedElementTransform {
        /**
         * Transforms the package and returns the transformation result.
         * @param pack The package or model to transform.
         */
        transform(pack) {
            if (pack == null)
                return pack;
            this.transformElement(pack);
            this.transformPackageRecursive(pack);
            return pack;
        }
        transformPackageRecursive(pack) {
            if (pack.packagedElements == null)
                return;
            pack.packagedElements.forEach((element) => {
                this.transformElement(element);
                if (ElementTypeUtility.isPackage(element.elementType)) {
                    this.transformPackageRecursive(element);
                }
            });
        }
    }

    /**
     * Transforms a Model or Package by returning just the Package that matches a specified expression.
     */
    class PackageFilterTransform {
        /**
         * Constructor. Creates a new PackageFilterTransform that only includes the package with the specified name.
         * @param expression The name of the package. If the name ends with a forward-slash ('/'), nested
         * packages will be included. The expression is case-insensitive.
         */
        constructor(expression) {
            if (!expression) {
                throw `Unable to filter packages. The filter expression cannot be empty.`;
            }
            const normalizedExpression = expression.toLowerCase();
            if (normalizedExpression.endsWith('/')) {
                this.includeNestedPackages = true;
                this.packageName = normalizedExpression.substring(0, normalizedExpression.length - 1);
            }
            else {
                this.packageName = normalizedExpression;
                this.includeNestedPackages = false;
            }
        }
        /**
         * Transforms the source Model or Package and returns the first Package that matches the expression.
         * The result will be empty if the package could not be found.
         * @param source The Model or Package to transform.
         */
        transform(source) {
            if (!source || !source.packagedElements)
                return source;
            const pack = PackageFilterTransform.findPackageRecursive(source, (pack) => {
                return (pack.name != null) && (pack.name.toLowerCase() === this.packageName);
            });
            if (!pack)
                throw `Unable to filter packages. Could not find any nested package with name '${this.packageName}'.`;
            // Remove any nested packages if needed
            if (!this.includeNestedPackages && pack.packagedElements != null) {
                pack.packagedElements = pack.packagedElements.filter(e => !(ElementTypeUtility.isPackage(e.elementType)));
            }
            return pack;
        }
        static findPackageRecursive(root, predicate) {
            if (predicate(root))
                return root;
            if (root.packagedElements == null)
                return null;
            // We use a for loop so that we can easily return when we 
            for (var i = 0, len = root.packagedElements.length; i < len; i++) {
                const packagedElement = root.packagedElements[i];
                if (packagedElement.elementType === exports.ElementType.package) {
                    const childResult = PackageFilterTransform.findPackageRecursive(packagedElement, predicate);
                    if (childResult != null)
                        return childResult;
                }
            }
            return null;
        }
    }

    (function (RenameTargets) {
        /**
         * No elements are renamed.
         */
        RenameTargets[RenameTargets["none"] = 0] = "none";
        /**
         * Classes are renamed.
         */
        RenameTargets[RenameTargets["classes"] = 1] = "classes";
        /**
         * Interfaces are renamed.
         */
        RenameTargets[RenameTargets["interfaces"] = 2] = "interfaces";
        /**
         * Properties are renamed.
         */
        RenameTargets[RenameTargets["properties"] = 4] = "properties";
        /**
         * Operations are renamed.
         */
        RenameTargets[RenameTargets["operations"] = 8] = "operations";
        /**
         * Operation parameters are renamed.
         */
        RenameTargets[RenameTargets["parameters"] = 16] = "parameters";
        /**
         * Enumerations are renamed.
         */
        RenameTargets[RenameTargets["enumerations"] = 32] = "enumerations";
        /**
         * Enumeration literals are renamed.
         */
        RenameTargets[RenameTargets["enumerationLiterals"] = 64] = "enumerationLiterals";
        /**
         * All members are renamed: properties, operations, parameters and enumerationLiterals.
         */
        RenameTargets[RenameTargets["allMembers"] = 92] = "allMembers";
        /**
         * All elements are renamed.
         */
        RenameTargets[RenameTargets["all"] = 127] = "all";
    })(exports.RenameTargets || (exports.RenameTargets = {}));
    /**
     * A base class for renaming classes, interfaces, properties, operations parameters, enumerations and enumeration literals.
     */
    class RenamingTransform extends PackagedElementTransform {
        /**
         * Constructor. Creates a new RenamingTransform with the specified targets.
         * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
         */
        constructor(targets) {
            super();
            this.targets = targets == null ? exports.RenameTargets.all : targets;
        }
        hasTarget(target) {
            if (this.targets & target)
                return true;
            else
                return false;
        }
        transformElement(element) {
            if (!ElementTypeUtility.isMemberedClassifier(element.elementType))
                return;
            if (this.hasTarget(exports.RenameTargets.classes) && ElementTypeUtility.isClass(element.elementType)) {
                element.name = this.rename(element.name, element);
            }
            if (this.hasTarget(exports.RenameTargets.interfaces) && ElementTypeUtility.isInterface(element.elementType)) {
                element.name = this.rename(element.name, element);
            }
            // The element has OwnedAttributes and OwnedOperations
            var classifier = element;
            if (classifier.ownedAttributes != null && this.hasTarget(exports.RenameTargets.properties)) {
                classifier.ownedAttributes.forEach(att => {
                    att.name = this.rename(att.name, att);
                });
            }
            if (classifier.ownedOperations != null) {
                classifier.ownedOperations.forEach(op => {
                    if (this.hasTarget(exports.RenameTargets.operations)) {
                        op.name = this.rename(op.name, op);
                    }
                    if (this.hasTarget(exports.RenameTargets.parameters)) {
                        op.ownedParameters.forEach(p => {
                            p.name = this.rename(p.name, p);
                        });
                    }
                });
            }
            if (ElementTypeUtility.isEnumeration(element.elementType)) {
                var enumeration = element;
                if (this.hasTarget(exports.RenameTargets.enumerations)) {
                    enumeration.name = this.rename(enumeration.name, enumeration);
                }
                if (enumeration.ownedLiterals != null && this.hasTarget(exports.RenameTargets.enumerationLiterals)) {
                    enumeration.ownedLiterals.forEach(literal => {
                        literal.name = this.rename(literal.name, literal);
                    });
                }
            }
        }
    }
    /**
     * A transform that capitalizes its rename targets, that is, makes the
     * first character uppercase.
     */
    class CapitalizingTransform extends RenamingTransform {
        /**
         * Constructor. Creates a new CapitalizingTransform with the specified targets.
         * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
         */
        constructor(targets) {
            super(targets);
        }
        rename(name, target) {
            return core.NameUtility.capitalize(name);
        }
    }
    /**
     * A transform that uncapitalizes its rename targets, that is, makes the
     * first character lowercase.
     */
    class UnCapitalizingTransform extends RenamingTransform {
        /**
         * Constructor. Creates a new UnCapitalizingTransform with the specified targets.
         * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
         */
        constructor(targets) {
            super(targets);
        }
        rename(name, target) {
            return core.NameUtility.unCapitalize(name);
        }
    }
    /**
     * A transform that converts its rename targets from UpperCamelCase to lowerCamelCase.
     */
    class UpperToLowerCamelCaseTransform extends RenamingTransform {
        /**
           * Constructor. Creates a new UpperToLowerCamelCaseTransform with the specified targets.
           * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
           */
        constructor(targets) {
            super(targets);
        }
        rename(name, target) {
            return core.NameUtility.upperToLowerCamelCase(name);
        }
    }
    /**
     * A transform that converts its rename targets from lowerCamelCase to UpperCamelCase.
     */
    class LowerToUpperCamelCaseTransform extends RenamingTransform {
        /**
           * Constructor. Creates a new LowerToUpperCamelCaseTransform with the specified targets.
           * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
           */
        constructor(targets) {
            super(targets);
        }
        rename(name, target) {
            return core.NameUtility.lowerToUpperCamelCase(name);
        }
    }
    /**
     * A transform that adds a prefix to its rename targets.
     */
    class PrefixingTransform extends RenamingTransform {
        /**
        * Constructor. Creates a new PrefixingTransform with the specified targets.
        * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
        */
        constructor(targets, prefix) {
            super(targets);
            this.prefix = prefix;
        }
        rename(name, target) {
            return this.prefix + name;
        }
    }
    /**
     * A transform that adds a suffix to its rename targets.
     */
    class SuffixingTransform extends RenamingTransform {
        /**
        * Constructor. Creates a new SuffixingTransform with the specified targets.
        * @param targets Optional: indicates which elements to rename. The default is RenameTargets.all.
        */
        constructor(targets, suffix) {
            super(targets);
            this.suffix = suffix;
        }
        rename(name, target) {
            return name + this.suffix;
        }
    }

    /*
    * Copyright (c) 2019 Yellicode
    *
    * This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    (function (DependencyKind) {
        DependencyKind[DependencyKind["none"] = 0] = "none";
        DependencyKind[DependencyKind["generalizations"] = 1] = "generalizations";
        DependencyKind[DependencyKind["interfaceRealizations"] = 2] = "interfaceRealizations";
        DependencyKind[DependencyKind["attributes"] = 4] = "attributes";
        DependencyKind[DependencyKind["operationParameters"] = 8] = "operationParameters";
        DependencyKind[DependencyKind["all"] = 15] = "all";
    })(exports.DependencyKind || (exports.DependencyKind = {}));
    /**
     * Sorts the types within a package (and within each nested package) based on their dependencies, in such a way
     * that dependencies appear before dependents. Dependencies are determined based on generalizations, interface
     * realizations, attributes and operation parameters.
     */
    class DependencySortTransform {
        /**
         * Constructor. Creates a new DependencySortTransform instance.
         * @param dependencyKind An optional DependencyKind value (or a bitwise combination of values)
         * that indicates what types of dependency must be taken into account. The default is DependencyKind.All.
         */
        constructor(dependencyKind) {
            this._options = dependencyKind == null ? exports.DependencyKind.all : dependencyKind;
        }
        transform(pack) {
            if (!pack)
                return pack;
            this.transformPackageRecursive(pack);
            return pack;
        }
        transformPackageRecursive(pack) {
            if (!pack.packagedElements)
                return;
            // Get all siblings that are relevant for building a depencency graph.        
            const allTypes = pack.packagedElements.filter(pe => isType(pe));
            // Build a dependency graph of each element, see https://www.npmjs.com/package/toposort for the docs
            var graph = [];
            allTypes.forEach((t) => {
                let elementDependencies = DependencySortTransform.getTypeDependencies(t, this._options, allTypes);
                if (elementDependencies.length > 0) {
                    elementDependencies.forEach((dependency) => {
                        graph.push([t, dependency]);
                    });
                }
            });
            if (graph.length > 0) {
                // Sort, and reverse because we need a dependency graph
                pack.packagedElements = toposort.array(pack.packagedElements, graph).reverse();
            }
            // Transform nested packages, recursively        
            pack.packagedElements.forEach((element) => {
                if (isPackage(element)) {
                    this.transformPackageRecursive(element);
                }
            });
        }
        static getTypeDependencies(element, options, allTypes) {
            var result = [];
            // Dependencies based on generalizations
            if (options & exports.DependencyKind.generalizations && isClassifier(element)) {
                DependencySortTransform.pushGeneralizationDependencies(element, allTypes, result);
            }
            // Dependencies based on interface realization
            if (options & exports.DependencyKind.interfaceRealizations && isBehavioredClassifier(element)) {
                DependencySortTransform.pushInterfaceRealizationDependencies(element, allTypes, result);
            }
            // Dependencies based on members
            if (isMemberedClassifier(element)) {
                if (options & exports.DependencyKind.attributes) {
                    DependencySortTransform.pushOwnedAttributeDependencies(element, allTypes, result);
                }
                if (options & exports.DependencyKind.operationParameters) {
                    DependencySortTransform.pushOwnedOperationDependencies(element, allTypes, result);
                }
            }
            return result;
        }
        static pushGeneralizationDependencies(element, allTypes, dependencies) {
            if (!element.generalizations || !element.generalizations.length)
                return;
            element.generalizations.forEach(g => {
                if (g.general === element)
                    return;
                if (allTypes.indexOf(g.general) > -1 && dependencies.indexOf(g.general) === -1) {
                    dependencies.push(g.general);
                }
            });
        }
        static pushInterfaceRealizationDependencies(element, allTypes, dependencies) {
            if (!element.interfaceRealizations || !element.interfaceRealizations.length)
                return;
            element.interfaceRealizations.forEach(ir => {
                if (allTypes.indexOf(ir.contract) > -1 && dependencies.indexOf(ir.contract) === -1) {
                    dependencies.push(ir.contract);
                }
            });
        }
        static pushOwnedOperationDependencies(element, allTypes, dependencies) {
            if (!element.ownedOperations || !element.ownedOperations.length)
                return;
            element.ownedOperations.forEach(op => {
                if (!op.ownedParameters || !op.ownedParameters.length)
                    return;
                op.ownedParameters.forEach(p => {
                    if (!p.type)
                        return;
                    if (allTypes.indexOf(p.type) > -1 && dependencies.indexOf(p.type) === -1) {
                        dependencies.push(p.type);
                    }
                });
            });
        }
        static pushOwnedAttributeDependencies(element, allTypes, dependencies) {
            if (!element.ownedAttributes || !element.ownedAttributes.length)
                return;
            element.ownedAttributes.forEach(att => {
                if (!att.type)
                    return;
                if (allTypes.indexOf(att.type) > -1 && dependencies.indexOf(att.type) === -1) {
                    dependencies.push(att.type);
                }
            });
        }
    }

    /*
     * Copyright (c) 2019 Yellicode
     *
     * This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     */
    /**
     * Transforms packageable element elements of one element type to another element type. For example, this transform lets
     * you transform all classes in a model or package to interfaces.
     */
    class ElementTypeTransform extends PackagedElementTransform {
        constructor(sourceElementType, targetElementType) {
            super();
            if (!sourceElementType)
                throw 'TypeTransform sourceType cannot be null.';
            if (!targetElementType)
                throw 'TypeTransform targetType cannot be null.';
            if (sourceElementType === targetElementType) {
                // Warn but don't crash
                console.warn(`Invalid TypeTransform arguments: the source and target type are both of type '${exports.ElementType[sourceElementType]}'.`);
            }
            this.sourceElementType = sourceElementType;
            this.targetElementType = targetElementType;
            this.sourceElementSelector = ElementTypeTransform.createTypeSelector(sourceElementType);
        }
        transformElement(element) {
            if (!this.sourceElementSelector(element) || this.sourceElementType === this.targetElementType)
                return;
            // Note that we don't check compatibility of existing relationships here. For example, we don't check the types of Generalizations when
            // a Class that has generalizations is transformed to an Interface (that has the same generalizations). 
            // The caller is responsible for transforming these generalizations as well.
            // Remove features that the type doesn't have         
            // ElementTypeTransform.removeOldSourceFeatures(element, this.targetElementType); // todo: disabled as long as this does not seem to add any value. 
            // Force the new elementType, even though it is readonly
            element.elementType = this.targetElementType;
            // Now add features that the type needs
            ElementTypeTransform.addNewTargetFeatures(element, this.sourceElementType);
        }
        static addNewTargetFeatures(transformedElement, sourceElementType) {
            // Get access to the internal model ModelDelegate
            const modelDelegate = transformedElement.modelDelegate;
            // Implement MemberedClassifier members
            if (isMemberedClassifier(transformedElement) && !ElementTypeUtility.isMemberedClassifier(sourceElementType)) {
                transformedElement.ownedAttributes = [];
                transformedElement.ownedOperations = [];
                transformedElement.getAllAttributes = () => { return modelDelegate.getAllAttributes(transformedElement); };
                transformedElement.getAllOperations = () => { return modelDelegate.getAllOperations(transformedElement); };
            }
            // Implement BehavioredClassifier members
            if (isBehavioredClassifier(transformedElement) && !ElementTypeUtility.isBehavioredClassifier(sourceElementType)) {
                transformedElement.interfaceRealizations = [];
            }
            // Implement Classifier members
            if (isClassifier(transformedElement) && !ElementTypeUtility.isClassifier(sourceElementType)) {
                transformedElement.generalizations = [];
                transformedElement.isAbstract = false;
                transformedElement.isFinalSpecialization = false;
                transformedElement.getAllParents = () => { return modelDelegate.getAllParents(transformedElement); };
                transformedElement.getAllSpecializations = () => { return modelDelegate.getAllSpecializations(transformedElement); };
                transformedElement.getFirstGeneralization = () => { return modelDelegate.getFirstGeneralization(transformedElement); };
                transformedElement.getFirstParent = () => { return modelDelegate.getFirstParent(transformedElement); };
                transformedElement.getParents = () => { return modelDelegate.getParents(transformedElement); };
                transformedElement.getSpecializations = () => { return modelDelegate.getSpecializations(transformedElement); };
            }
            // Implement Enumeration members
            if (isEnumeration(transformedElement) && !ElementTypeUtility.isEnumeration(sourceElementType)) {
                transformedElement.baseType = null;
                transformedElement.ownedLiterals = [];
            }
            // Implement Class members
            if (isClass(transformedElement) && !ElementTypeUtility.isClass(sourceElementType)) {
                transformedElement.isActive = true;
                transformedElement.getSuperClasses = () => { return modelDelegate.getSuperClasses(transformedElement); };
            }
            // Implement Stereotype members
            if (isStereotype(transformedElement) && !ElementTypeUtility.isStereotype(sourceElementType)) {
                transformedElement.extends = [];
                transformedElement.safeName = transformedElement.name; // sorry, it's not perfect
            }
        }
        static removeOldSourceFeatures(unTransformedElement, targetElementType) {
            // Remove MemberedClassifier members
            if (isMemberedClassifier(unTransformedElement) && !ElementTypeUtility.isMemberedClassifier(targetElementType)) {
                delete unTransformedElement.ownedAttributes;
                delete unTransformedElement.ownedOperations;
                delete unTransformedElement.getAllAttributes;
                delete unTransformedElement.getAllOperations;
            }
            // Remove BehavioredClassifier members
            if (isBehavioredClassifier(unTransformedElement) && !ElementTypeUtility.isBehavioredClassifier(targetElementType)) {
                delete unTransformedElement.interfaceRealizations;
            }
            // Remove Classifier members
            if (isClassifier(unTransformedElement) && !ElementTypeUtility.isClassifier(targetElementType)) {
                delete unTransformedElement.generalizations;
                delete unTransformedElement.isAbstract;
                delete unTransformedElement.isFinalSpecialization;
                delete unTransformedElement.getAllParents;
                delete unTransformedElement.getAllSpecializations;
                delete unTransformedElement.getFirstGeneralization;
                delete unTransformedElement.getFirstParent;
                delete unTransformedElement.getParents;
                delete unTransformedElement.getSpecializations;
            }
            // Remove Enumeration members
            if (isEnumeration(unTransformedElement) && !ElementTypeUtility.isEnumeration(targetElementType)) {
                delete unTransformedElement.baseType;
                delete unTransformedElement.ownedLiterals;
            }
            // Remove Class members
            if (isClass(unTransformedElement) && !ElementTypeUtility.isClass(targetElementType)) {
                delete unTransformedElement.isActive;
                delete unTransformedElement.getSuperClasses;
            }
            // Remove Stereotype members
            if (isStereotype(unTransformedElement) && !ElementTypeUtility.isStereotype(targetElementType)) {
                delete unTransformedElement.extends;
                delete unTransformedElement.safeName;
            }
        }
        static createTypeSelector(elementType) {
            // Do a strict elementType comparison here
            return (t) => { return t.elementType === elementType; };
            // Alternatively, we could use the 'is...' functions to also include descendent types of elementType, 
            // but this might be confusing.
            // switch (elementType) {
            //     case ElementType.class:                
            //         return isClass;                
            //     case ElementType.dataType:
            //         return isDataType;
            //     case ElementType.enumeration:
            //         return isEnumeration;
            //     case ElementType.interface:
            //         return isInterface;
            //     case ElementType.primitiveType:
            //         return isPrimitiveType;
            //     case ElementType.stereotype:
            //         return isStereotype;
            //     default:
            //         throw `Unsupported element type ${ElementType[elementType]}.`;
            // }
        }
    }

    /**
     * Default implementation of the TypeNameProvider interface. This implementation
     * returns type names as-is, but allows inheritors to provide their own implementation
     * by overriding getTypeNameForType and/or getTypeNameForTypedElement.
     */
    class DefaultTypeNameProvider {
        getTypeName(typeOrTypedElement) {
            if (isTypedElement(typeOrTypedElement)) {
                // The argument is a typedElement            
                const isMultiValued = isMultiplicityElement(typeOrTypedElement) && typeOrTypedElement.isMultivalued();
                return this.getTypeNameForTypedElement(typeOrTypedElement, isDataType(typeOrTypedElement.type), isMultiValued);
            }
            else {
                // The argument is a type
                return this.getTypeNameForType(typeOrTypedElement, isDataType(typeOrTypedElement));
            }
        }
        /**
        * Returns the name of the provided type. This function is also called by getTypeNameOfTypedElement() if that function is not overridden.
        * @param type The type information.
        * @param isDataType Indicates if the type is a data type (that is, an Enumeration, PrimitiveType or DataType).
        */
        getTypeNameForType(type, isDataType$$1) {
            // Note: we don't use isDataType in this default implementation, but it is considered relevant for implementers.
            return type ? type.name : null;
        }
        /**
        * Returns the name of the provided element's type. Internally, this function calls getTypeNameForType for the type, but
        * you should override this function if you need to provide different type names for a type depending on the context.
        * For example, you may return a different type name for a property or parameter that is multi-valued.
        * @param typedElement Any element that has a type.
        * @param isDataType Indicates if the element's type is a data type (that is, an Enumeration, PrimitiveType or DataType).
        * @param isMultiValued Indicates if the TypedElement is multi-valued (that is, has an upper bound greater than 1).
        */
        getTypeNameForTypedElement(typedElement, isDataType$$1, isMultiValued) {
            // Note: we don't use isMultiValued in this default implementation, but it is considered relevant for implementers.
            return this.getTypeNameForType(typedElement.type, isDataType$$1);
        }
        /**
         * DEPRECATED: Returns the name of the provided element's data type. Override this function to map primitives and other data types
         * (both built-in or types exported from a profile) to the target language. The default implementation calls the
         * getDataTypeNameForType function using the type of the typedElement.
         * @param typedElement Any TypedElement instance.
         * @deprecated Please override getTypeNameForTypedElement instead.
         */
        getDataTypeName(typedElement) {
            console.warn(`DefaultTypeNameProvider.getDataTypeName is deprecated. Please override getTypeNameForTypedElement instead.`);
            const isMultiValued = isMultiplicityElement(typedElement) && typedElement.isMultivalued();
            return this.getTypeNameForTypedElement(typedElement, true, isMultiValued);
        }
        /**
        * DEPRECATED: Returns the name of the provided data type. Override this function to map primitives and other data types
        * (both built-in or types exported from a profile) to the target language.
        * @param type The type information.
        * @deprecated Please override getTypeNameForType instead.
        */
        getDataTypeNameForType(type) {
            console.warn(`DefaultTypeNameProvider.getDataTypeNameForType is deprecated. Please override getTypeNameForType instead.`);
            return this.getTypeNameForType(type, true);
        }
        /**
         * DEPRECATED: Returns the name of the provided element's complex type (any type that is not a DataType). Override this function to provide
         * a custom name for the complex type. The default implementation calls the getComplexTypeNameForType function using
         * the type of the typedElement.
         * @param typedElement Any TypedElement instance.
         * @deprecated Please override getTypeNameForTypedElement instead.
         */
        getComplexTypeName(typedElement) {
            console.warn(`DefaultTypeNameProvider.getComplexTypeName is deprecated. Please override getTypeNameForTypedElement instead.`);
            const isMultiValued = isMultiplicityElement(typedElement) && typedElement.isMultivalued();
            return this.getTypeNameForTypedElement(typedElement, false, isMultiValued);
        }
        /**
        * DEPRECATED: Returns the name of the provided complex type (any type that is not a DataType). Override this function to provide
        * a custom name for the complex type.
        * @param type The type information.
        * @deprecated Please override getTypeNameForType instead.
        */
        getComplexTypeNameForType(type) {
            console.warn(`DefaultTypeNameProvider.getComplexTypeNameForType is deprecated. Please override getTypeNameForType instead.`);
            return this.getTypeNameForType(type, false);
        }
    }

    /*
     * Copyright (c) 2019 Yellicode
     *
     * This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     */

    exports.isPrimitiveBoolean = isPrimitiveBoolean;
    exports.isPrimitiveInteger = isPrimitiveInteger;
    exports.isPrimitiveReal = isPrimitiveReal;
    exports.isPrimitiveString = isPrimitiveString;
    exports.isPrimitiveObject = isPrimitiveObject;
    exports.UnlimitedNatural = UnlimitedNatural;
    exports.ElementTypeUtility = ElementTypeUtility;
    exports.isNamedElement = isNamedElement;
    exports.isTypedElement = isTypedElement;
    exports.isValueSpecification = isValueSpecification;
    exports.isPackageableElement = isPackageableElement;
    exports.isType = isType;
    exports.isRedefinableElement = isRedefinableElement;
    exports.isClassifier = isClassifier;
    exports.isStructuredClassifier = isStructuredClassifier;
    exports.isMultiplicityElement = isMultiplicityElement;
    exports.isOrderedElement = isOrderedElement;
    exports.isFeature = isFeature;
    exports.isStructuralFeature = isStructuralFeature;
    exports.isMemberedClassifier = isMemberedClassifier;
    exports.isBehavioredClassifier = isBehavioredClassifier;
    exports.isClass = isClass;
    exports.isStereotype = isStereotype;
    exports.isRelationship = isRelationship;
    exports.isProperty = isProperty;
    exports.isPackage = isPackage;
    exports.isProfile = isProfile;
    exports.isDataType = isDataType;
    exports.isPrimitiveType = isPrimitiveType;
    exports.isParameter = isParameter;
    exports.isBehavioralFeature = isBehavioralFeature;
    exports.isOperation = isOperation;
    exports.isModel = isModel;
    exports.isLiteralSpecification = isLiteralSpecification;
    exports.isLiteralUnlimitedNatural = isLiteralUnlimitedNatural;
    exports.isLiteralString = isLiteralString;
    exports.isLiteralReal = isLiteralReal;
    exports.isLiteralNull = isLiteralNull;
    exports.isLiteralInteger = isLiteralInteger;
    exports.isLiteralBoolean = isLiteralBoolean;
    exports.isDirectedRelationship = isDirectedRelationship;
    exports.isInterfaceRealization = isInterfaceRealization;
    exports.isInterface = isInterface;
    exports.isGeneralization = isGeneralization;
    exports.isEnumerationLiteral = isEnumerationLiteral;
    exports.isEnumeration = isEnumeration;
    exports.isComment = isComment;
    exports.isAssociation = isAssociation;
    exports.ProfileUtility = ProfileUtility;
    exports.ModelReader = ModelReader;
    exports.ElementFactory = ElementFactory;
    exports.PackagedElementTransform = PackagedElementTransform;
    exports.PackageFilterTransform = PackageFilterTransform;
    exports.RenamingTransform = RenamingTransform;
    exports.CapitalizingTransform = CapitalizingTransform;
    exports.UnCapitalizingTransform = UnCapitalizingTransform;
    exports.UpperToLowerCamelCaseTransform = UpperToLowerCamelCaseTransform;
    exports.LowerToUpperCamelCaseTransform = LowerToUpperCamelCaseTransform;
    exports.PrefixingTransform = PrefixingTransform;
    exports.SuffixingTransform = SuffixingTransform;
    exports.DependencySortTransform = DependencySortTransform;
    exports.ElementTypeTransform = ElementTypeTransform;
    exports.DefaultTypeNameProvider = DefaultTypeNameProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
